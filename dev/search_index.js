var documenterSearchIndex = {"docs":
[{"location":"lib/library/#Library","page":"Library","title":"Library","text":"","category":"section"},{"location":"lib/library/","page":"Library","title":"Library","text":"Documentation for SatelliteToolbox.jl.","category":"page"},{"location":"lib/library/","page":"Library","title":"Library","text":"Modules = [SatelliteToolbox]\nPrivate = false","category":"page"},{"location":"lib/library/#SatelliteToolbox.ltan_to_raan-Tuple{Time, Union{DateTime, Number}}","page":"Library","title":"SatelliteToolbox.ltan_to_raan","text":"ltan_to_raan(ltan::Union{Number, Time}, t::Union{Number, DateTime}) -> Float64\n\nCompute the RAAN [0, 2π] [rad] so that the local time of ascending node (LTAN) is ltan at instant t [UT1].\n\nltan can be represented as a Number, indicating the hour, or by a Time object.\n\nt can be represented as a Julian Day [UT1] or DateTime [UT1].\n\n\n\n\n\n","category":"method"},{"location":"lib/library/#SatelliteToolbox.ltdn_to_raan-Tuple{Time, Union{DateTime, Number}}","page":"Library","title":"SatelliteToolbox.ltdn_to_raan","text":"ltdn_to_raan(ltdn::Union{Number, Time}, t::Union{Number, DateTime}) -> Float64\n\nCompute the RAAN [0, 2π] [rad] so that the local time of descending node (LTAN) is ltdn at instant t [UT1].\n\nltdn can be represented as a Number, indicating the hour, or by a Time object.\n\nt can be represented as a Julian Day [UT1] or DateTime [UT1].\n\n\n\n\n\n","category":"method"},{"location":"lib/library/#SatelliteToolbox.orbital_angular_velocity-Union{Tuple{T3}, Tuple{T2}, Tuple{T1}, Tuple{T1, T2, T3}} where {T1<:Number, T2<:Number, T3<:Number}","page":"Library","title":"SatelliteToolbox.orbital_angular_velocity","text":"orbital_angular_velocity(a::Number, e::Number, i::Number; kwargs...) -> T\norbital_angular_velocity(orb::Orbit{Tepoch, T}; kwargs...) where {Tepoch<:Number, T<:Number} -> T\n\nCompute the angular velocity [rad/s] of an object in an orbit with semi-major axis a [m], eccentricity e, and inclination i [rad]. The orbit can also be specified by orb (see Orbit).\n\nnote: Note\nThe output type T in the first signature is obtained by promoting the inputs to a float type.\n\nKeywords\n\nperturbation::Symbol: Symbol to select the perturbation terms that will be used.   (Default: :J2)\nm0::Number: Standard gravitational parameter for Earth [m³ / s²].   (Default = GM_EARTH)\nJ2::Number: J₂ perturbation term. (Default = EGM08_J2)\nJ4::Number: J₄ perturbation term. (Default = EGM08_J4)\nR0::Number: Earth's equatorial radius [m]. (Default = EARTHEQUATORIALRADIUS)\n\nPerturbations\n\nThe keyword argument perturbation can be used to select the perturbation terms that will be considered in the computation. The possible values are:\n\n:J0: Consider a Keplerian orbit.\n:J2: Consider the perturbation terms up to J2.\n:J4: Consider the perturbation terms J2, J4, and J2².\n\nIf perturbation is omitted, it defaults to :J2.\n\n\n\n\n\n","category":"method"},{"location":"lib/library/#SatelliteToolbox.orbital_angular_velocity_to_semimajor_axis-Union{Tuple{T3}, Tuple{T2}, Tuple{T1}, Tuple{T1, T2, T3}} where {T1<:Number, T2<:Number, T3<:Number}","page":"Library","title":"SatelliteToolbox.orbital_angular_velocity_to_semimajor_axis","text":"orbital_angular_velocity_to_semimajor_axis(angvel::Number, e::Number, i::Number; kwargs...) -> T, Bool\n\nCompute the semi-major axis [m] that will provide an angular velocity angvel [rad / s] in an orbit with eccentricity e and inclination i [rad].\n\nNotice that the angular velocity angvel is related to the nodal period, i.e. the time between two consecutive passages by the ascending node.\n\nnote: Note\nThe output type T in the first signature is obtained by promoting the inputs to a float type.\n\nKeywords\n\nmax_iterations::Int: Maximum number of iterations allowed in the Newton-Raphson   algorithm. (Default = 20)\nperturbation::Symbol: Symbol to select the perturbation terms that will be used.   (Default: :J2)\ntolerance::Union{Nothing, Number}: Residue tolerances to verify if the numerical method   has converged. If it is nothing, √eps(T) will be used, where T is the internal   type for the computations. Notice that the residue function unit is [deg / min].   (Default = nothing)\nm0::Number: Standard gravitational parameter for Earth [m³ / s²].   (Default = GM_EARTH)\nJ2::Number: J₂ perturbation term. (Default = EGM08_J2)\nJ4::Number: J₄ perturbation term. (Default = EGM08_J4)\nR0::Number: Earth's equatorial radius [m]. (Default = EARTHEQUATORIALRADIUS)\n\nReturns\n\nT: Semi-major axis [m].\nBool: true if the numerical method converged, false otherwise.\n\nPerturbations\n\nThe keyword argument perturbation can be used to select the perturbation terms that will be considered in the computation. The possible values are:\n\n:J0: Consider a Keplerian orbit.\n:J2: Consider the perturbation terms up to J2.\n:J4: Consider the perturbation terms J2, J4, and J2².\n\nIf perturbation is omitted, it defaults to :J2.\n\n\n\n\n\n","category":"method"},{"location":"lib/library/#SatelliteToolbox.orbital_period-Tuple{Number, Number, Number}","page":"Library","title":"SatelliteToolbox.orbital_period","text":"orbital_period(a::Number, e::Number, i::Number; kwargs...) -> T\norbital_period(orb::Orbit{Tepoch, T}; kwargs...) where {Tepoch<:Number, T<:Number} -> T\n\nCompute the orbital period [s] of an object in an orbit with semi-major axis a [m], eccentricity e, and inclination i [rad]. The orbit can also be specified by orb (see Orbit).\n\nnote: Note\nThe output type T in the first signature is obtained by promoting the inputs to a float type.\n\nKeywords\n\nperturbation::Symbol: Symbol to select the perturbation terms that will be used.   (Default: :J2)\nm0::Number: Standard gravitational parameter for Earth [m³ / s²].   (Default = GM_EARTH)\nJ2::Number: J₂ perturbation term. (Default = EGM08_J2)\nJ4::Number: J₄ perturbation term. (Default = EGM08_J4)\nR0::Number: Earth's equatorial radius [m]. (Default = EARTHEQUATORIALRADIUS)\n\nPerturbations\n\nThe keyword argument perturbation can be used to select the perturbation terms that will be considered in the computation. The possible values are:\n\n:J0: Consider a Keplerian orbit.\n:J2: Consider the perturbation terms up to J2.\n:J4: Consider the perturbation terms J2, J4, and J2².\n\nIf perturbation is omitted, it defaults to :J2.\n\n\n\n\n\n","category":"method"},{"location":"lib/library/#SatelliteToolbox.raan_time_derivative-Union{Tuple{T3}, Tuple{T2}, Tuple{T1}, Tuple{T1, T2, T3}} where {T1<:Number, T2<:Number, T3<:Number}","page":"Library","title":"SatelliteToolbox.raan_time_derivative","text":"raan_time_derivative(a::Number, e::Number, i::Number; kwargs...) -> T\n\nCompute the time derivative of the right ascension of the ascending node (RAAN) [rad / s] in an orbit with semi-major axis a [m], eccentricity e, and inclination i [rad]. The orbit can also be specified by orb (see Orbit).\n\nnote: Note\nThe output type T in the first signature is obtained by promoting the inputs to a float type.\n\nKeywords\n\nperturbation::Symbol: Symbol to select the perturbation terms that will be used.   (Default: :J2)\nm0::Number: Standard gravitational parameter for Earth [m³ / s²].   (Default = GM_EARTH)\nJ2::Number: J₂ perturbation term. (Default = EGM08_J2)\nJ4::Number: J₄ perturbation term. (Default = EGM08_J4)\nR0::Number: Earth's equatorial radius [m]. (Default = EARTHEQUATORIALRADIUS)\n\nPerturbations\n\nThe keyword argument perturbation can be used to select the perturbation terms that will be considered in the computation. The possible values are:\n\n:J0: Consider a Keplerian orbit.\n:J2: Consider the perturbation terms up to J2.\n:J4: Consider the perturbation terms J2, J4, and J2².\n\nIf perturbation is omitted, it defaults to :J2.\n\n\n\n\n\n","category":"method"},{"location":"lib/library/#SatelliteToolbox.raan_to_ltan-Tuple{Number, Union{DateTime, Number}}","page":"Library","title":"SatelliteToolbox.raan_to_ltan","text":"raan_to_ltan(raan::Number, t::Union{Number, DateTime}) -> Float64\n\nCompute the local time of the ascending node (LTAN) given the raan at instant t [UT1].\n\nt can be represented as a Julian Day [UT1] or DateTime [UT1].\n\n\n\n\n\n","category":"method"},{"location":"lib/library/#SatelliteToolbox.raan_to_ltdn-Tuple{Number, Union{DateTime, Number}}","page":"Library","title":"SatelliteToolbox.raan_to_ltdn","text":"raan_to_ltdn(raan::Number, t::Union{Number, DateTime}) -> Float64\n\nCompute the local time of the ascending node (LTDN) given the raan at instant t [UT1].\n\nt can be represented as a Julian Day [UT1] or DateTime [UT1].\n\n\n\n\n\n","category":"method"},{"location":"#SatelliteToolbox.jl","page":"Home","title":"SatelliteToolbox.jl","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"CurrentModule = SatelliteToolbox\nDocTestSetup = quote\n    using SatelliteToolbox\nend","category":"page"},{"location":"","page":"Home","title":"Home","text":"The SatelliteToolbox.jl contains a set of packages with functions to perform analysis and build simulations related to satellites. It is used on a daily basis on projects at the Brazilian National Institute for Space Research (INPE).","category":"page"},{"location":"","page":"Home","title":"Home","text":"The set of packages are listed bellow. All of them are loaded and reexported in this one.","category":"page"},{"location":"","page":"Home","title":"Home","text":"SatelliteToolboxAtmosphericModels.jl: Atmospheric models.\nSatelliteToolboxBase.jl: Base functions and type definitions.\nSatelliteToolboxCelestialBodies.jl: Celestial bodies.\nSatelliteToolboxGeomagneticField.jl: Geomagnetic field models.\nSatelliteToolboxGravityModels.jl: Gravity models.\nSatelliteToolboxLegendre.jl: Legendre associated functions and its time-derivatives.\nSatelliteToolboxPropagators.jl: Orbit propagators.\nSatelliteToolboxSgp4.jl: SGP4/SDP4 orbit propagator.\nSatelliteToolboxTle.jl: Creating, fetching, and parsing TLEs.\nSatelliteToolboxTransformations.jl: Transformations (reference frames, time, etc.).","category":"page"},{"location":"#Installation","page":"Home","title":"Installation","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"This package can be installed using:","category":"page"},{"location":"","page":"Home","title":"Home","text":"julia> using Pkg\njulia> Pkg.add(\"SatelliteToolbox\")","category":"page"},{"location":"#Documentation","page":"Home","title":"Documentation","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"This page contains tutorials with examples of analyses that can be performed using the SatelliteToolbox.jl ecosystem. For the documentation of the functions, please refer to the related package documentation page.","category":"page"},{"location":"","page":"Home","title":"Home","text":"warning: Warning\nThis documentation is under construction, and more tutorials will be added.","category":"page"},{"location":"tutorials/iss_observation/#ISS-Observation-Instants","page":"ISS Observation","title":"ISS Observation Instants","text":"","category":"section"},{"location":"tutorials/iss_observation/","page":"ISS Observation","title":"ISS Observation","text":"In this tutorial, we will compute the instants in which we can theoretically observe the ISS from our location. Actually, we will compute the moments an observer on the Earth's surface has a direct line of sight to the ISS.","category":"page"},{"location":"tutorials/iss_observation/#Theory","page":"ISS Observation","title":"Theory","text":"","category":"section"},{"location":"tutorials/iss_observation/","page":"ISS Observation","title":"ISS Observation","text":"We can verify if we have a line of sight to an object by computing the elevation lambda of its position vector represented in a local reference frame. Let's use the NED (North-East-Down) reference: its X axis points toward the North, its Y axis points toward the East, and its Z axis points toward the Earth's center, as shown in the following figure.","category":"page"},{"location":"tutorials/iss_observation/","page":"ISS Observation","title":"ISS Observation","text":"(Image: Elevation in NED Reference Frame)","category":"page"},{"location":"tutorials/iss_observation/","page":"ISS Observation","title":"ISS Observation","text":"If the angle lambda is greater than zero, we can theoretically observe the object we are analyzing because it is above the horizon at the desired location. We can compute this angle using:","category":"page"},{"location":"tutorials/iss_observation/","page":"ISS Observation","title":"ISS Observation","text":"beginequation*\n  lambda = atanleft(-fracR_NEDzsqrtR_NEDx^2 + R_NEDy^2right)\nendequation*","category":"page"},{"location":"tutorials/iss_observation/","page":"ISS Observation","title":"ISS Observation","text":"where R_NEDi it the i-axis component of the object position vector vecR represented in the NED reference frame.","category":"page"},{"location":"tutorials/iss_observation/#Algorithm","page":"ISS Observation","title":"Algorithm","text":"","category":"section"},{"location":"tutorials/iss_observation/","page":"ISS Observation","title":"ISS Observation","text":"We need to perform the following tasks to check when ISS enters our field of view:","category":"page"},{"location":"tutorials/iss_observation/","page":"ISS Observation","title":"ISS Observation","text":"Obtain the ISS position during the desired period;\nConvert the position vector to the NED reference frame;\nObtain the elevation for each instant; and\nCheck when the elevation is greater than zero.","category":"page"},{"location":"tutorials/iss_observation/#Code","page":"ISS Observation","title":"Code","text":"","category":"section"},{"location":"tutorials/iss_observation/","page":"ISS Observation","title":"ISS Observation","text":"Before starting, let's load all the packages in the SatelliteToolbox.jl ecosystem:","category":"page"},{"location":"tutorials/iss_observation/","page":"ISS Observation","title":"ISS Observation","text":"julia> using SatelliteToolbox","category":"page"},{"location":"tutorials/iss_observation/","page":"ISS Observation","title":"ISS Observation","text":"We first need to obtain the mean elements of the ISS to propagate its orbit. We can do this by using the Celestrak TLE fetcher. The following code creates the fetcher and downloads the latest available ISS TLE:","category":"page"},{"location":"tutorials/iss_observation/","page":"ISS Observation","title":"ISS Observation","text":"julia> f = create_tle_fetcher(CelestrakTleFetcher)\nCelestrakTleFetcher(\"https://celestrak.org/NORAD/elements/gp.php\")\n\njulia> tles = fetch_tles(f; satellite_name = \"ISS (ZARYA)\")\n[ Info: Fetch TLEs from Celestrak using satellite name: \"ISS (ZARYA)\" ...\n1-element Vector{TLE}:\n TLE: ISS (ZARYA) (Epoch = 2023-07-02T16:14:23.672)\n\njulia> iss_tle = tles[1]\nTLE:\n                      Name : ISS (ZARYA)\n          Satellite number : 25544\n  International designator : 98067A\n        Epoch (Year / Day) : 23 / 183.67666287 (2023-07-02T16:14:23.672)\n        Element set number : 999\n              Eccentricity :   0.00045810\n               Inclination :  51.64230000 deg\n                      RAAN : 251.73890000 deg\n       Argument of perigee :  98.25980000 deg\n              Mean anomaly :  37.01280000 deg\n           Mean motion (n) :  15.50610282 revs / day\n         Revolution number : 40419\n                        B* :   0.00021501 1 / er\n                     ṅ / 2 :   0.00012101 rev / day²\n                     n̈ / 6 :            0 rev / day³","category":"page"},{"location":"tutorials/iss_observation/","page":"ISS Observation","title":"ISS Observation","text":"The mean elements we obtained are encoded in a TLE by NORAD. Hence, we must use the SGP4/SDP4 algorithm to propagate its orbit. We can initialize the propagator as follows:","category":"page"},{"location":"tutorials/iss_observation/","page":"ISS Observation","title":"ISS Observation","text":"julia> orbp = Propagators.init(Val(:SGP4), iss_tle)\nOrbitPropagatorSgp4{Float64, Float64}:\n   Propagator name : SGP4 Orbit Propagator\n  Propagator epoch : 2023-07-02T16:14:23.672\n  Last propagation : 2023-07-02T16:14:23.672","category":"page"},{"location":"tutorials/iss_observation/","page":"ISS Observation","title":"ISS Observation","text":"Let's say we want to check when the ISS will stay under our field of view within one day from this TLE epoch. The following code propagates the TLE for one day using a step of one second:","category":"page"},{"location":"tutorials/iss_observation/","page":"ISS Observation","title":"ISS Observation","text":"julia> ret = Propagators.propagate!.(orbp, 0:1:86400)\n86401-element Vector{Tuple{StaticArraysCore.SVector{3, Float64}, StaticArraysCore.SVector{3, Float64}}}:\n ([4.3241138662552e6, 3.658818213831297e6, 3.737410008328138e6], [-1520.7633082033235, 6181.330955217756, -4275.4053760819315])\n ([4.322590349691385e6, 3.6649972144279014e6, 3.733132227568888e6], [-1526.2732556957171, 6176.663987437403, -4280.179483156526])\n ([4.321061324147931e6, 3.67117154413503e6, 3.7288496754281903e6], [-1531.7812633324513, 6171.989143201469, -4284.948124245782])\n ⋮\n ([-4.523980159202273e6, -3.810874556321396e6, -3.3522994708746294e6], [1497.4675552368813, -5876.71613186301, 4670.189355793778])\n ([-4.522479829177213e6, -3.8167488378395094e6, -3.347627153102706e6], [1503.2022238337156, -5871.8808804082, 4674.448700122841])","category":"page"},{"location":"tutorials/iss_observation/","page":"ISS Observation","title":"ISS Observation","text":"Each element in the returned array is a tuple with two vectors. The first is the satellite position [m], and the second is the velocity [m / s]. We only need to check its position. Thus, let's obtain this information for each instant:","category":"page"},{"location":"tutorials/iss_observation/","page":"ISS Observation","title":"ISS Observation","text":"julia> vr_teme = first.(ret)\n86401-element Vector{StaticArraysCore.SVector{3, Float64}}:\n [4.3241138662552e6, 3.658818213831297e6, 3.737410008328138e6]\n [4.322590349691385e6, 3.6649972144279014e6, 3.733132227568888e6]\n [4.321061324147931e6, 3.67117154413503e6, 3.7288496754281903e6]\n ⋮\n [-4.523980159202273e6, -3.810874556321396e6, -3.3522994708746294e6]\n [-4.522479829177213e6, -3.8167488378395094e6, -3.347627153102706e6]","category":"page"},{"location":"tutorials/iss_observation/","page":"ISS Observation","title":"ISS Observation","text":"This step concludes the first step of the algorithm.","category":"page"},{"location":"tutorials/iss_observation/","page":"ISS Observation","title":"ISS Observation","text":"The information obtained by the SGP4 is represented in the True-Equator, Mean-Equinox (TEME) reference frame, which is a quasi-inertial frame. Now, we need to convert it to a frame fixed on Earth since we need to compute the elevation angle in a specific position at Earth's surface. We can do this using the function r_eci_to_ecef. It returns a matrix that rotates an Earth-centered inertial (ECI) frame to an Earth-centered, Earth-fixed (ECEF) frame.  For our simple example, we will use the PEF (pseudo-Earth fixed) frame as the ECEF. All the vectors returned by the propagator can be converted as follows:","category":"page"},{"location":"tutorials/iss_observation/","page":"ISS Observation","title":"ISS Observation","text":"julia> vr_pef = r_eci_to_ecef.(TEME(), PEF(), Propagators.epoch(orbp) .+ (collect(0:1:86400) ./ 86400)) .* vr_teme\n86401-element Vector{StaticArraysCore.SVector{3, Float64}}:\n [-3.1517745650685215e6, -4.706509167226944e6, 3.737410008328138e6]\n [-3.148954811670437e6, -4.711801726204846e6, 3.733132227568888e6]\n [-3.146131833297915e6, -4.717088716679321e6, 3.7288496754281903e6]\n ⋮\n [3.3857219006283223e6, 4.850365818830511e6, -3.3522994708746294e6]\n [3.383108804842527e6, 4.855406297217666e6, -3.347627153102706e6]","category":"page"},{"location":"tutorials/iss_observation/","page":"ISS Observation","title":"ISS Observation","text":"note: Note\nThe code Propagators.epoch(orbp) .+ (collect(0:1:86400) ./ 86400) obtains the Julian Day [UTC] of each propagation instant.","category":"page"},{"location":"tutorials/iss_observation/","page":"ISS Observation","title":"ISS Observation","text":"We can now convert the ECEF vectors to the NED frame using the function ecef_to_ned. However, we must input the geodetic location we are analyzing. Here, we will use the location of the city of São José dos Campos, SP, Brazil:","category":"page"},{"location":"tutorials/iss_observation/","page":"ISS Observation","title":"ISS Observation","text":"Latitude: 23.1791 S.\nLongitude: 45.8872 W.\nAltitude: 593 m.","category":"page"},{"location":"tutorials/iss_observation/","page":"ISS Observation","title":"ISS Observation","text":"julia> vr_ned = ecef_to_ned.(vr_pef, -23.1791 |> deg2rad, -45.8872 |> deg2rad, 593; translate = true)\n86401-element Vector{StaticArraysCore.SVector{3, Float64}}:\n [3.8867951998111717e6, -5.538957086708884e6, 6.7568967896751845e6]\n [3.885130946017213e6, -5.540616594591433e6, 6.749915536859117e6]\n [3.8834616159196747e6, -5.542269910950413e6, 6.742934017679935e6]\n ⋮\n [-3.540243127040135e6, 5.8070592063407935e6, 6.090776675161325e6]\n [-3.5380883263308997e6, 5.808691621810904e6, 6.097614606058563e6]","category":"page"},{"location":"tutorials/iss_observation/","page":"ISS Observation","title":"ISS Observation","text":"This step concludes the second step of the algorithm.","category":"page"},{"location":"tutorials/iss_observation/","page":"ISS Observation","title":"ISS Observation","text":"note: Note\nWe must set the keyword translate to true because we do not want only to rotate the reference frame. We also wish the frame origin for the returned vectors to be translated from the Earth's center to the city location.","category":"page"},{"location":"tutorials/iss_observation/","page":"ISS Observation","title":"ISS Observation","text":"The elevation in the third step can be easily computed using the presented formula:","category":"page"},{"location":"tutorials/iss_observation/","page":"ISS Observation","title":"ISS Observation","text":"julia> vλ = map(v -> atand(-v[3], sqrt(v[1]^2 + v[2]^2)), vr_ned)\n86401-element Vector{Float64}:\n -44.95878130917832\n -44.92746141286671\n -44.89614037059145\n   ⋮\n -41.8461848156166\n -41.876994453587045","category":"page"},{"location":"tutorials/iss_observation/","page":"ISS Observation","title":"ISS Observation","text":"Finally, we need to find the indices related to elevations greater than zero:","category":"page"},{"location":"tutorials/iss_observation/","page":"ISS Observation","title":"ISS Observation","text":"julia> ids = findall(>=(0), vλ)\n3102-element Vector{Int64}:\n  1409\n  1410\n  1411\n     ⋮\n 85164\n 85165","category":"page"},{"location":"tutorials/iss_observation/","page":"ISS Observation","title":"ISS Observation","text":"Those are the instants that we will have a direct line of sight to the ISS. We can discover the related time using:","category":"page"},{"location":"tutorials/iss_observation/","page":"ISS Observation","title":"ISS Observation","text":"julia> using Dates\n\njulia> getindex(Propagators.epoch(orbp) .+ (collect(0:1:86400) ./ 86400) .|> julian2datetime, ids)\n3102-element Vector{DateTime}:\n 2023-07-02T16:37:51.672\n 2023-07-02T16:37:52.672\n 2023-07-02T16:37:53.672\n ⋮\n 2023-07-03T15:53:46.672\n 2023-07-03T15:53:47.672","category":"page"}]
}
