var documenterSearchIndex = {"docs":
[{"location":"man/orbit/anomalies/#Anomalies","page":"Anomalies","title":"Anomalies","text":"","category":"section"},{"location":"man/orbit/anomalies/","page":"Anomalies","title":"Anomalies","text":"CurrentModule = SatelliteToolbox\nDocTestSetup = quote\n    using SatelliteToolbox\nend","category":"page"},{"location":"man/orbit/anomalies/","page":"Anomalies","title":"Anomalies","text":"There are three types of anomalies[1] that can be used to describe the position of the satellite in the orbit plane with respect to the argument of perigee:","category":"page"},{"location":"man/orbit/anomalies/","page":"Anomalies","title":"Anomalies","text":"The mean anomaly (M);\nThe eccentric anomaly (E); and\nThe true anomaly (f).","category":"page"},{"location":"man/orbit/anomalies/","page":"Anomalies","title":"Anomalies","text":"This package contains the following functions that can be used to convert one to another:","category":"page"},{"location":"man/orbit/anomalies/","page":"Anomalies","title":"Anomalies","text":"function M_to_E(e::Number, M::Number, tol::Number = 1e-10)\nfunction M_to_f(e::Number, M::Number, tol::Number = 1e-10)\nfunction E_to_f(e::Number, E::Number)\nfunction E_to_M(e::Number, E::Number)\nfunction f_to_E(e::Number,f::Number)\nfunction f_to_E(orb::Orbit)\nfunction f_to_M(e::Number, f::Number)\nfunction f_to_M(orb::Orbit)","category":"page"},{"location":"man/orbit/anomalies/","page":"Anomalies","title":"Anomalies","text":"where:","category":"page"},{"location":"man/orbit/anomalies/","page":"Anomalies","title":"Anomalies","text":"M is the mean anomaly [rad];\nE is the eccentric anomaly [rad];\nf is the true anomaly [rad];\ne is the eccentricity;\norb is an instance of the structure Orbit;\ntol is used to select the tolerance for the cases in which the conversion is performed by a numerical method, such as the Newton-Raphson algorithm.","category":"page"},{"location":"man/orbit/anomalies/","page":"Anomalies","title":"Anomalies","text":"All the returned values are in [rad].","category":"page"},{"location":"man/orbit/anomalies/","page":"Anomalies","title":"Anomalies","text":"julia> M_to_E(0.04, pi/4)\n0.8144932819286269\n\njulia> M_to_f(0.04, pi/4)\n0.8440031124631683\n\njulia> f_to_M(0.04, pi/4)\n0.7300148523821107\n\njulia> M_to_f(0, 0.343)\n0.3430000000000001\n\njulia> M_to_f(0.04, 0.343)\n0.37122803399203647","category":"page"},{"location":"man/orbit/anomalies/","page":"Anomalies","title":"Anomalies","text":"[1]: In astronomy, anomaly is an angle.","category":"page"},{"location":"man/transformations/ecef_eci/#ECEF-and-ECI","page":"ECEF and ECI","title":"ECEF and ECI","text":"","category":"section"},{"location":"man/transformations/ecef_eci/","page":"ECEF and ECI","title":"ECEF and ECI","text":"CurrentModule = SatelliteToolbox\nDocTestSetup = quote\n    using SatelliteToolbox\nend","category":"page"},{"location":"man/transformations/ecef_eci/","page":"ECEF and ECI","title":"ECEF and ECI","text":"This package currently provides two models to transform reference systems: the IAU-76/FK5 and the IAU-2006/2010 (CIO approach). The following table lists the available coordinate frames and how they can be referenced in the functions that will be described later on.","category":"page"},{"location":"man/transformations/ecef_eci/","page":"ECEF and ECI","title":"ECEF and ECI","text":"Reference Type Coordinate frame name\nITRF() ECEF International Terrestrial Reference Frame\nPEF() ECEF Pseudo-Earth Fixed reference frame\nTIRS() ECEF Terrestrial Intermediate Reference System\nMOD() ECI Mean-Of-Date reference frame\nTOD() ECI True-Of-Data reference frame\nGCRF() ECI Geocentric Celestial Reference Frame (GCRF)\nJ2000() ECI J2000 reference frame\nTEME() ECI True Equator, Mean Equinox reference frame\nCIRS() ECI Celetial Intermediate Reference System","category":"page"},{"location":"man/transformations/ecef_eci/","page":"ECEF and ECI","title":"ECEF and ECI","text":"note: Note\nECEF stands for Earth-Centered, Earth-Fixed whereas ECI stands for Earth-Centered Inertial.","category":"page"},{"location":"man/transformations/ecef_eci/","page":"ECEF and ECI","title":"ECEF and ECI","text":"warning: Warning\nIn all the functions that will be presented here, it is not possible yet to mix frames between the IAU-76/FK5 and IAU-2006/2010 models in the same call. Hence, if it is required to compute the rotation between frames in different models, then the recommended approach is to first compute the rotation from the origin frame to the ITRF or GCRF, and then compute the rotation from the ITRF or GCRF to the destination frame. However, this will only work for past dates since EOP data is required.","category":"page"},{"location":"man/transformations/ecef_eci/#EOP-Data","page":"ECEF and ECI","title":"EOP Data","text":"","category":"section"},{"location":"man/transformations/ecef_eci/","page":"ECEF and ECI","title":"ECEF and ECI","text":"The conversions here sometimes requires additional data related to the Earth orientation. This information is provided by IERS (International Earth Rotation and Reference Systems Service). The SatelliteToolbox.jl has the capability to automatically download and parse the IERS EOP (Earth Orientation Parameters) data.","category":"page"},{"location":"man/transformations/ecef_eci/","page":"ECEF and ECI","title":"ECEF and ECI","text":"The function that will automatically download the files, store them in the file system, and parse the data is:","category":"page"},{"location":"man/transformations/ecef_eci/","page":"ECEF and ECI","title":"ECEF and ECI","text":"function get_iers_eop(data_type::Symbol = :IAU1980; force_download = false)","category":"page"},{"location":"man/transformations/ecef_eci/","page":"ECEF and ECI","title":"ECEF and ECI","text":"in which:","category":"page"},{"location":"man/transformations/ecef_eci/","page":"ECEF and ECI","title":"ECEF and ECI","text":"data_type is a symbol that specify what kind of data is desired (:IAU1980 for IAU1980 data and :IAU2000A for IAU2000A data). If omitted, then it defaults to :IAU1980.\nThe files are obtained on a daily-basis by the package RemoteFiles.jl. If the user wants to force the download, then the keyword force_download should be set to true.\nThis function returns an instance of the structure EOPData_IAU1980 or EOPData_IAU2000A depending on the selection of data_type. The returned value should be passed to the reference frame conversion functions as described in the following.","category":"page"},{"location":"man/transformations/ecef_eci/","page":"ECEF and ECI","title":"ECEF and ECI","text":"julia> eop_IAU1980 = get_iers_eop();\n[ Info: Downloading file 'EOP_IAU1980.TXT' from 'https://datacenter.iers.org/data/latestVersion/223_EOP_C04_14.62-NOW.IAU1980223.txt' with cURL.\n\njulia> eop_IAU2000A = get_iers_eop(:IAU2000A);\n[ Info: Downloading file 'EOP_IAU2000A.TXT' from 'https://datacenter.iers.org/data/latestVersion/224_EOP_C04_14.62-NOW.IAU2000A224.txt' with cURL.","category":"page"},{"location":"man/transformations/ecef_eci/#ECEF-to-ECEF","page":"ECEF and ECI","title":"ECEF to ECEF","text":"","category":"section"},{"location":"man/transformations/ecef_eci/","page":"ECEF and ECI","title":"ECEF and ECI","text":"One ECEF frame can be converted to another one by the following function:","category":"page"},{"location":"man/transformations/ecef_eci/","page":"ECEF and ECI","title":"ECEF and ECI","text":"function r_ecef_to_ecef([T,] ECEFo, ECEFf, JD_UTC::Number, eop_data)","category":"page"},{"location":"man/transformations/ecef_eci/","page":"ECEF and ECI","title":"ECEF and ECI","text":"where it will be computed the rotation from the ECEF reference frame ECEFo to the ECEF reference frame ECEFf at the Julian Day [UTC] JD_UTC. The rotation description that will be used is given by T, which can be DCM or Quaternion. If T is omitted, then it defaults to DCM. The EOP data eop_data in this case is always necessary. Hence, the user must initialize it as described in the section EOP Data.","category":"page"},{"location":"man/transformations/ecef_eci/","page":"ECEF and ECI","title":"ECEF and ECI","text":"julia> r_ecef_to_ecef(PEF(), ITRF(), date_to_jd(1986,6,19,21,35,0), eop_IAU1980)\n3×3 StaticArrays.SMatrix{3, 3, Float64, 9} with indices SOneTo(3)×SOneTo(3):\n  1.0          0.0         -4.3531e-7\n -6.30011e-13  1.0         -1.44727e-6\n  4.3531e-7    1.44727e-6   1.0\n\njulia> r_ecef_to_ecef(TIRS(), ITRF(), date_to_jd(1986,6,19,21,35,0), eop_IAU2000A)\n3×3 StaticArrays.SMatrix{3, 3, Float64, 9} with indices SOneTo(3)×SOneTo(3):\n  1.0          3.08408e-11  -4.3531e-7\n -3.14708e-11  1.0          -1.44727e-6\n  4.3531e-7    1.44727e-6    1.0\n\njulia> r_ecef_to_ecef(Quaternion, PEF(), ITRF(), date_to_jd(1986,6,19,21,35,0), eop_IAU1980)\nQuaternion{Float64}:\n  + 0.9999999999997147 - 7.236343481310813e-7.i + 2.1765518308012794e-7.j + 0.0.k\n\njulia> r_ecef_to_ecef(Quaternion, TIRS(), ITRF(), date_to_jd(1986,6,19,21,35,0), eop_IAU2000A)\nQuaternion{Float64}:\n  + 0.9999999999997146 - 7.236343481345639e-7.i + 2.176551830689726e-7.j + 1.5577911634233308e-11.k","category":"page"},{"location":"man/transformations/ecef_eci/#ECI-to-ECI","page":"ECEF and ECI","title":"ECI to ECI","text":"","category":"section"},{"location":"man/transformations/ecef_eci/","page":"ECEF and ECI","title":"ECEF and ECI","text":"One ECI frame can be converted to another ECI frame by one of the following functions:","category":"page"},{"location":"man/transformations/ecef_eci/","page":"ECEF and ECI","title":"ECEF and ECI","text":"function r_ecef_to_eci([T,] ECIo, ECIf, JD_UTC::Number [, eop_data])\nfunction r_ecef_to_eci([T,] ECIo, JD_UTCo::Number, ECIf, JD_UTCf::Number [, eop_data])","category":"page"},{"location":"man/transformations/ecef_eci/","page":"ECEF and ECI","title":"ECEF and ECI","text":"where it will be computed compute the rotation from the ECI reference frame ECIo to another ECI reference frame ECIf. If the origin and destination frame contain only one of date frame, then the first signature is used and JD_UTC is the epoch of this frame. On the other hand, if the origin and destination frame contain two of date frame[1], e.g. TOD => MOD, then the second signature must be used in which JD_UTCo is the epoch of the origin frame and JD_UTCf is the epoch of the destination frame. The rotation description that will be used is given by T, which can be DCM or Quaternion. If T is omitted, then it defaults to DCM. The EOP data eop_data, as described in section EOP Data, is required in some conversions, as described in the following table.","category":"page"},{"location":"man/transformations/ecef_eci/","page":"ECEF and ECI","title":"ECEF and ECI","text":"[1]: TEME is an of date frame.","category":"page"},{"location":"man/transformations/ecef_eci/","page":"ECEF and ECI","title":"ECEF and ECI","text":"Model ECIo ECIf EOP Data Function Signature\nIAU-76/FK5 GCRF J2000 EOP IAU1980 First\nIAU-76/FK5 GCRF MOD EOP IAU1980 First\nIAU-76/FK5 GCRF TOD EOP IAU1980 First\nIAU-76/FK5 GCRF TEME EOP IAU1980 First\nIAU-76/FK5 J2000 GCRF EOP IAU1980 First\nIAU-76/FK5 J2000 MOD Not required First\nIAU-76/FK5 J2000 TOD Not required First\nIAU-76/FK5 J2000 TEME Not required First\nIAU-76/FK5 MOD GCRF EOP IAU1980 First\nIAU-76/FK5 MOD J2000 Not required First\nIAU-76/FK5 MOD TOD Not required Second\nIAU-76/FK5 MOD TEME Not required Second\nIAU-76/FK5 TOD GCRF EOP IAU1980 First\nIAU-76/FK5 TOD J2000 Not required First\nIAU-76/FK5 TOD MOD Not required Second\nIAU-76/FK5 TOD TEME Not required Second\nIAU-76/FK5 TEME GCRF EOP IAU1980 First\nIAU-76/FK5 TEME J2000 Not required First\nIAU-76/FK5 TEME MOD Not required Second\nIAU-76/FK5 TEME TOD Not required Second\nIAU-2006/2010 GCRF CIRS Not required¹ First\nIAU-2006/2010 CIRS CIRS Not required¹ Second","category":"page"},{"location":"man/transformations/ecef_eci/","page":"ECEF and ECI","title":"ECEF and ECI","text":"¹: In this case, the terms that account for the free-core nutation and time dependent effects of the Celestial Intermediate Pole (CIP) position with respect to the GCRF will not be available, reducing the precision.","category":"page"},{"location":"man/transformations/ecef_eci/","page":"ECEF and ECI","title":"ECEF and ECI","text":"note: Note\nIn this function, if EOP corrections are not provided, then MOD and TOD frames will be computed considering the original IAU-76/FK5 theory. Otherwise, the corrected frame will be used.","category":"page"},{"location":"man/transformations/ecef_eci/","page":"ECEF and ECI","title":"ECEF and ECI","text":"julia> r_eci_to_eci(DCM, GCRF(), J2000(), date_to_jd(1986, 6, 19, 21, 35, 0), eop_IAU1980)\n3×3 StaticArrays.SMatrix{3, 3, Float64, 9} with indices SOneTo(3)×SOneTo(3): \n  1.0          -2.45463e-12   4.56602e-10\n  2.45473e-12   1.0          -1.84455e-9\n -4.56602e-10   1.84455e-9    1.0\n\njulia> r_eci_to_eci(Quaternion, TEME(), GCRF(), date_to_jd(1986, 6, 19, 21, 35, 0), eop_IAU1980)\nQuaternion{Float64}:\n  + 0.9999986335698654 + 1.8300414020900853e-5.i + 0.0006653038276169474.j - 0.0015132396749411375.k\n\njulia> r_eci_to_eci(TOD(), date_to_jd(1986,6,19,21,35,0), TOD(), date_to_jd(1987,5,19,3,0,0), eop_IAU1980)\n3×3 StaticArrays.SMatrix{3, 3, Float64, 9} with indices SOneTo(3)×SOneTo(3): \n 1.0          -0.000224087  -9.73784e-5\n 0.000224086   1.0          -5.79859e-6\n 9.73797e-5    5.77677e-6    1.0\n\njulia> r_eci_to_eci(Quaternion, TOD(), JD_J2000, MOD(), JD_J2000, eop_IAU1980)\nQuaternion{Float64}:\n  + 0.9999999993282687 - 1.400220690336851e-5.i + 1.3473593746216003e-5.j - 3.107834312843103e-5.k\n\njulia> r_eci_to_eci(J2000(), TEME(), date_to_jd(1986,6,19,21,35,0))\n3×3 StaticArrays.SMatrix{3, 3, Float64, 9} with indices SOneTo(3)×SOneTo(3): \n  0.999995    0.0030265    0.00133055\n -0.00302645  0.999995    -3.86125e-5\n -0.00133066  3.45854e-5   0.999999\n\njulia> r_eci_to_eci(CIRS(), GCRF(), date_to_jd(1986,6,19,21,35,0), eop_IAU2000A)\n3×3 StaticArrays.SMatrix{3, 3, Float64, 9} with indices SOneTo(3)×SOneTo(3): \n 0.999999     3.88379e-8  -0.00133066\n 7.18735e-9   1.0          3.45882e-5\n 0.00133066  -3.45882e-5   0.999999\n\njulia> r_eci_to_eci(Quaternion, CIRS(), GCRF(), date_to_jd(1986,6,19,21,35,0), eop_IAU2000A)\nQuaternion{Float64}:\n  + 0.9999997785177528 + 1.7294102099105917e-5.i + 0.0006653310148723835.j + 7.912627369563795e-9.k","category":"page"},{"location":"man/transformations/ecef_eci/#ECEF-to-ECI","page":"ECEF and ECI","title":"ECEF to ECI","text":"","category":"section"},{"location":"man/transformations/ecef_eci/","page":"ECEF and ECI","title":"ECEF and ECI","text":"One ECEF frame can be convert to one ECI frame using the following function:","category":"page"},{"location":"man/transformations/ecef_eci/","page":"ECEF and ECI","title":"ECEF and ECI","text":"function r_ecef_to_eci([T,] ECEF, ECI, JD_UTC::Number [, eop_data])","category":"page"},{"location":"man/transformations/ecef_eci/","page":"ECEF and ECI","title":"ECEF and ECI","text":"where it will be compute the rotation from the ECEF frame ECEF to the ECI frame ECI at the Julian Day [UTC] JD_UTC. The rotation description that will be used is given by T, which can be DCM or Quaternion. If it is omitted, then it defaults to DCM. The EOP data eop_data, as described in section EOP Data, is required in some conversions, as described in the following table.","category":"page"},{"location":"man/transformations/ecef_eci/","page":"ECEF and ECI","title":"ECEF and ECI","text":"Model ECI ECEF EOP Data\nIAU-76/FK5 GCRF ITRF EOP IAU1980\nIAU-76/FK5 J2000 ITRF EOP IAU1980\nIAU-76/FK5 MOD ITRF EOP IAU1980\nIAU-76/FK5 TOD ITRF EOP IAU1980\nIAU-76/FK5 TEME ITRF EOP IAU1980\nIAU-76/FK5 GCRF PEF EOP IAU1980\nIAU-76/FK5 J2000 PEF Not required¹\nIAU-76/FK5 MOD PEF Not required¹\nIAU-76/FK5 TOD PEF Not required¹\nIAU-76/FK5 TEME PEF Not required¹\nIAU-2006/2010 CIRS ITRF EOP IAU2000A\nIAU-2006/2010 GCRF ITRF EOP IAU2000A\nIAU-2006/2010 CIRS TIRS Not required¹\nIAU-2006/2010 GCRF TIRS Not required¹ ²","category":"page"},{"location":"man/transformations/ecef_eci/","page":"ECEF and ECI","title":"ECEF and ECI","text":"¹: In this case, the Julian Time UTC will be assumed equal to Julian Time UT1 to compute the Greenwich Mean Sidereal Time. This is an approximation, but should be sufficiently accurate for some applications. Notice that, if EOP Data is provided, the Julian Day UT1 will be accurately computed.","category":"page"},{"location":"man/transformations/ecef_eci/","page":"ECEF and ECI","title":"ECEF and ECI","text":"²: In this case, the terms that account for the free-core nutation and time dependent effects of the Celestial Intermediate Pole (CIP) position with respect to the GCRF will not be available, reducing the precision.","category":"page"},{"location":"man/transformations/ecef_eci/","page":"ECEF and ECI","title":"ECEF and ECI","text":"note: Note\nIn this function, if EOP corrections are not provided, then MOD and TOD frames will be computed considering the original IAU-76/FK5 theory. Otherwise, the corrected frame will be used.","category":"page"},{"location":"man/transformations/ecef_eci/","page":"ECEF and ECI","title":"ECEF and ECI","text":"julia> r_ecef_to_eci(DCM, ITRF(), GCRF(), date_to_jd(1986, 06, 19, 21, 35, 0), eop_IAU1980)\n3×3 StaticArrays.SMatrix{3, 3, Float64, 9} with indices SOneTo(3)×SOneTo(3): \n -0.619267      0.78518     -0.00132979\n -0.78518      -0.619267     3.33492e-5\n -0.000797313   0.00106478   0.999999\n\njulia> r_ecef_to_eci(ITRF(), GCRF(), date_to_jd(1986, 06, 19, 21, 35, 0), eop_IAU1980)\n3×3 StaticArrays.SMatrix{3, 3, Float64, 9} with indices SOneTo(3)×SOneTo(3): \n -0.619267      0.78518     -0.00132979\n -0.78518      -0.619267     3.33492e-5\n -0.000797313   0.00106478   0.999999\n\njulia> r_ecef_to_eci(ITRF(), GCRF(), date_to_jd(1986, 06, 19, 21, 35, 0), eop_IAU2000A)\n3×3 StaticArrays.SMatrix{3, 3, Float64, 9} with indices SOneTo(3)×SOneTo(3): \n -0.619267      0.78518     -0.00132979\n -0.78518      -0.619267     3.33502e-5\n -0.000797312   0.00106478   0.999999\n\njulia> r_ecef_to_eci(PEF(), J2000(), date_to_jd(1986, 06, 19, 21, 35, 0))\n3×3 StaticArrays.SMatrix{3, 3, Float64, 9} with indices SOneTo(3)×SOneTo(3): \n -0.619271      0.785176    -0.00133066\n -0.785177     -0.619272     3.45854e-5\n -0.000796885   0.00106622   0.999999\n\njulia> r_ecef_to_eci(PEF(), J2000(), date_to_jd(1986, 06, 19, 21, 35, 0), eop_IAU1980)\n3×3 StaticArrays.SMatrix{3, 3, Float64, 9} with indices SOneTo(3)×SOneTo(3): \n -0.619267      0.78518     -0.00133066\n -0.78518      -0.619267     3.45854e-5\n -0.000796879   0.00106623   0.999999\n\njulia> r_ecef_to_eci(TIRS(), GCRF(), date_to_jd(1986, 06, 19, 21, 35, 0))\n3×3 StaticArrays.SMatrix{3, 3, Float64, 9} with indices SOneTo(3)×SOneTo(3): \n -0.619271      0.785176    -0.00133066\n -0.785177     -0.619272     3.45884e-5\n -0.000796885   0.00106623   0.999999\n\njulia> r_ecef_to_eci(Quaternion, ITRF(), GCRF(), date_to_jd(1986, 06, 19, 21, 35, 0), eop_IAU1980)\nQuaternion{Float64}:\n  + 0.4363098936462618 - 0.0005909969666939257.i + 0.00030510511316206974.j + 0.8997962182293519.k\n\njulia> r_ecef_to_eci(Quaternion, ITRF(), GCRF(), date_to_jd(1986, 06, 19, 21, 35, 0), eop_IAU2000A)\nQuaternion{Float64}:\n  + 0.4363098936309669 - 0.000590996988144556.i + 0.0003051056555230158.j + 0.8997962182365703.k","category":"page"},{"location":"man/transformations/ecef_eci/#ECI-to-ECEF","page":"ECEF and ECI","title":"ECI to ECEF","text":"","category":"section"},{"location":"man/transformations/ecef_eci/","page":"ECEF and ECI","title":"ECEF and ECI","text":"One ECI frame can be converted to one ECEF frame using the following function:","category":"page"},{"location":"man/transformations/ecef_eci/","page":"ECEF and ECI","title":"ECEF and ECI","text":"function r_eci_to_ecef([T,] ECI, ECEF, JD_UTC::Number [, eop_data])","category":"page"},{"location":"man/transformations/ecef_eci/","page":"ECEF and ECI","title":"ECEF and ECI","text":"which has the same characteristics of the function r_ecef_to_eci described in Section ECEF to ECI, but with the inputs ECI  and ECEF swapped.","category":"page"},{"location":"man/transformations/ecef_eci/","page":"ECEF and ECI","title":"ECEF and ECI","text":"note: Note\nThis function actually calls r_ecef_to_eci first and then uses inv_rotation. Hence, it has a slightly overhead on top of r_ecef_to_eci, which should be negligible for both rotation representations that are supported.","category":"page"},{"location":"man/transformations/ecef_eci/","page":"ECEF and ECI","title":"ECEF and ECI","text":"julia> r_eci_to_ecef(DCM, GCRF(), ITRF(), date_to_jd(1986, 06, 19, 21, 35, 0), eop_IAU1980)\n3×3 StaticArrays.SMatrix{3, 3, Float64, 9} with indices SOneTo(3)×SOneTo(3): \n -0.619267    -0.78518     -0.000797313\n  0.78518     -0.619267     0.00106478\n -0.00132979   3.33492e-5   0.999999\n\njulia> r_eci_to_ecef(GCRF(), ITRF(), date_to_jd(1986, 06, 19, 21, 35, 0), eop_IAU1980)\n3×3 StaticArrays.SMatrix{3, 3, Float64, 9} with indices SOneTo(3)×SOneTo(3): \n -0.619267    -0.78518     -0.000797313\n  0.78518     -0.619267     0.00106478\n -0.00132979   3.33492e-5   0.999999\n\njulia> r_eci_to_ecef(GCRF(), ITRF(), date_to_jd(1986, 06, 19, 21, 35, 0), eop_IAU2000A)\n3×3 StaticArrays.SMatrix{3, 3, Float64, 9} with indices SOneTo(3)×SOneTo(3): \n -0.619267    -0.78518     -0.000797312\n  0.78518     -0.619267     0.00106478\n -0.00132979   3.33502e-5   0.999999\n\njulia> r_eci_to_ecef(J2000(), PEF(), date_to_jd(1986, 06, 19, 21, 35, 0))\n3×3 StaticArrays.SMatrix{3, 3, Float64, 9} with indices SOneTo(3)×SOneTo(3): \n -0.619271    -0.785177    -0.000796885\n  0.785176    -0.619272     0.00106622\n -0.00133066   3.45854e-5   0.999999\n\njulia> r_eci_to_ecef(J2000(), PEF(), date_to_jd(1986, 06, 19, 21, 35, 0), eop_IAU1980)\n3×3 StaticArrays.SMatrix{3, 3, Float64, 9} with indices SOneTo(3)×SOneTo(3): \n -0.619267    -0.78518     -0.000796879\n  0.78518     -0.619267     0.00106623\n -0.00133066   3.45854e-5   0.999999\n\njulia> r_eci_to_ecef(GCRF(), TIRS(), date_to_jd(1986, 06, 19, 21, 35, 0))\n3×3 StaticArrays.SMatrix{3, 3, Float64, 9} with indices SOneTo(3)×SOneTo(3): \n -0.619271    -0.785177    -0.000796885\n  0.785176    -0.619272     0.00106623\n -0.00133066   3.45884e-5   0.999999\n\njulia> r_eci_to_ecef(Quaternion, GCRF(), ITRF(), date_to_jd(1986, 06, 19, 21, 35, 0), eop_IAU1980)\nQuaternion{Float64}:\n  + 0.4363098936462618 + 0.0005909969666939257.i - 0.00030510511316206974.j - 0.8997962182293519.k\n\njulia> r_eci_to_ecef(Quaternion, GCRF(), ITRF(), date_to_jd(1986, 06, 19, 21, 35, 0), eop_IAU2000A)\nQuaternion{Float64}:\n  + 0.4363098936309669 + 0.000590996988144556.i - 0.0003051056555230158.j - 0.8997962182365703.k","category":"page"},{"location":"man/orbit/general/#General-functions","page":"General analysis","title":"General functions","text":"","category":"section"},{"location":"man/orbit/general/","page":"General analysis","title":"General analysis","text":"CurrentModule = SatelliteToolbox\nDocTestSetup = quote\n    using SatelliteToolbox\nend","category":"page"},{"location":"man/orbit/general/","page":"General analysis","title":"General analysis","text":"This package contains some functions that helps in analysis of orbits.","category":"page"},{"location":"man/orbit/general/#Angular-velocity","page":"General analysis","title":"Angular velocity","text":"","category":"section"},{"location":"man/orbit/general/","page":"General analysis","title":"General analysis","text":"The angular velocity of an object in orbit when considering a Keplerian orbit (unperturbed model) is given by:","category":"page"},{"location":"man/orbit/general/","page":"General analysis","title":"General analysis","text":"n = n_0 = sqrt fracmu_0a^3 ","category":"page"},{"location":"man/orbit/general/","page":"General analysis","title":"General analysis","text":"where mu_0 is the standard gravitational parameter for Earth, and a is the semi-major axis.","category":"page"},{"location":"man/orbit/general/","page":"General analysis","title":"General analysis","text":"If the perturbation terms up to J_2 are considered, then the angular velocity is computed by:","category":"page"},{"location":"man/orbit/general/","page":"General analysis","title":"General analysis","text":"n = n_0 + frac34 cdot fracR_0^2 cdot J_2a^2left(1-e^2right)^2 cdot n_0 cdot leftsqrt1-e^2cdot(3cos^2(i)-1) + (5cos^2(i) - 1) right","category":"page"},{"location":"man/orbit/general/","page":"General analysis","title":"General analysis","text":"where e is the eccentricity, i is the inclination, and R_0 is the Earth equatorial radius.","category":"page"},{"location":"man/orbit/general/","page":"General analysis","title":"General analysis","text":"In this package, the angular velocity [rad/s] can be computed by the following functions:","category":"page"},{"location":"man/orbit/general/","page":"General analysis","title":"General analysis","text":"function angvel(a::Number, e::Number, i::Number, pert::Symbol = :J2)\nfunction angvel(orb::Orbit, pert::Symbol = :J2)","category":"page"},{"location":"man/orbit/general/","page":"General analysis","title":"General analysis","text":"where:","category":"page"},{"location":"man/orbit/general/","page":"General analysis","title":"General analysis","text":"a is the semi-major axis [m];\ne is the eccentricity;\ni is the inclination [rad];\npert selects the perturbation terms it should be used, it can be :J0, :J2, or :J4[1]; and\norb is an instance of Orbit.","category":"page"},{"location":"man/orbit/general/","page":"General analysis","title":"General analysis","text":"julia> angvel(7130982.0, 0.001111, deg2rad(98.405))\n0.0010471974485046116\n\njulia> angvel(7130982.0, 0.001111, deg2rad(98.405), :J0)\n0.0010484431282179","category":"page"},{"location":"man/orbit/general/#Time-derivative-of-the-argument-of-perigee","page":"General analysis","title":"Time-derivative of the argument of perigee","text":"","category":"section"},{"location":"man/orbit/general/","page":"General analysis","title":"General analysis","text":"The time-derivative of the argument of perigee dotomega when considering perturbation terms up to J_2 is:","category":"page"},{"location":"man/orbit/general/","page":"General analysis","title":"General analysis","text":"dotomega = frac34 cdot fracR_0^2 cdot J_2a^2left(1-e^2right)^2 cdot n_0 cdot (5cos^2(i) - 1)","category":"page"},{"location":"man/orbit/general/","page":"General analysis","title":"General analysis","text":"where R_0 is the Earth equatorial radius, a is the semi-major axis, e is the eccentricity, i is the inclination, and n_0 is the unperturbed orbital angular velocity.","category":"page"},{"location":"man/orbit/general/","page":"General analysis","title":"General analysis","text":"In the unperturbed model (Keplerian orbit), the time-derivative of the argument of perigee is always 0.","category":"page"},{"location":"man/orbit/general/","page":"General analysis","title":"General analysis","text":"In this package, the time-derivative of the argument of perigee [rad/s] can be computed by the following functions:","category":"page"},{"location":"man/orbit/general/","page":"General analysis","title":"General analysis","text":"function dargp(a::Number, e::Number, i::Number, pert::Symbol = :J2)\nfunction dargp(orb::Orbit, pert::Symbol = :J2)","category":"page"},{"location":"man/orbit/general/","page":"General analysis","title":"General analysis","text":"where:","category":"page"},{"location":"man/orbit/general/","page":"General analysis","title":"General analysis","text":"a is the semi-major axis [m];\ne is the eccentricity;\ni is the inclination [rad];\npert selects the perturbation terms it should be used, it can be :J0, :J2, or :J4[1]; and\norb is an instance of Orbit.","category":"page"},{"location":"man/orbit/general/","page":"General analysis","title":"General analysis","text":"julia> dargp(7130982, 0.001111, deg2rad(98.405))\n-6.082892348533058e-7\n\njulia> dargp(7130982, 0.001111, deg2rad(63.435))\n-2.433253158726004e-12\n\njulia> dargp(7130982, 0.001111, deg2rad(98.405), :J0)\n0.0","category":"page"},{"location":"man/orbit/general/#Time-derivative-of-the-RAAN","page":"General analysis","title":"Time-derivative of the RAAN","text":"","category":"section"},{"location":"man/orbit/general/","page":"General analysis","title":"General analysis","text":"The time-derivative of the RAAN (right-ascension of the ascending node) dotOmega when considering perturbation terms up to J_2 is:","category":"page"},{"location":"man/orbit/general/","page":"General analysis","title":"General analysis","text":"dotOmega = -frac32 cdot fracR_0^2 cdot J_2a^2left(1-e^2right)^2 cdot n_0 cdot cos(i)","category":"page"},{"location":"man/orbit/general/","page":"General analysis","title":"General analysis","text":"where R_0 is the Earth equatorial radius, a is the semi-major axis, e is the eccentricity, i is the inclination, and n_0 is the unperturbed orbital angular velocity.","category":"page"},{"location":"man/orbit/general/","page":"General analysis","title":"General analysis","text":"In the unperturbed model (Keplerian orbit), the time-derivative of the RAAN is always 0.","category":"page"},{"location":"man/orbit/general/","page":"General analysis","title":"General analysis","text":"In this package, the time-derivative of the RAAN [rad/s] can be computed by the following functions:","category":"page"},{"location":"man/orbit/general/","page":"General analysis","title":"General analysis","text":"function draan(a::Number, e::Number, i::Number, pert::Symbol = :J2)\nfunction draan(orb::Orbit, pert::Symbol = :J2)","category":"page"},{"location":"man/orbit/general/","page":"General analysis","title":"General analysis","text":"where:","category":"page"},{"location":"man/orbit/general/","page":"General analysis","title":"General analysis","text":"a is the semi-major axis [m];\ne is the eccentricity;\ni is the inclination [rad];\npert selects the perturbation terms it should be used, it can be :J0, :J2, or :J4[1]; and\norb is an instance of Orbit.","category":"page"},{"location":"man/orbit/general/","page":"General analysis","title":"General analysis","text":"julia> draan(7130982, 0.001111, deg2rad(98.405))\n1.9909533223838115e-7\n\njulia> draan(7130982, 0.001111, deg2rad(98.405), :J0)\n0.0","category":"page"},{"location":"man/orbit/general/#Period","page":"General analysis","title":"Period","text":"","category":"section"},{"location":"man/orbit/general/","page":"General analysis","title":"General analysis","text":"The orbital period of an object in orbit is given by:","category":"page"},{"location":"man/orbit/general/","page":"General analysis","title":"General analysis","text":"T = frac2pin","category":"page"},{"location":"man/orbit/general/","page":"General analysis","title":"General analysis","text":"where n is the angular velocity as described in Angular velocity.","category":"page"},{"location":"man/orbit/general/","page":"General analysis","title":"General analysis","text":"In this package, the orbital period [s] can be computed by the following functions:","category":"page"},{"location":"man/orbit/general/","page":"General analysis","title":"General analysis","text":"function period(a::Number, e::Number, i::Number, pert::Symbol = :J2)\nfunction period(orb::Orbit, pert::Symbol = :J2)","category":"page"},{"location":"man/orbit/general/","page":"General analysis","title":"General analysis","text":"where:","category":"page"},{"location":"man/orbit/general/","page":"General analysis","title":"General analysis","text":"a is the semi-major axis [m];\ne is the eccentricity;\ni is the inclination [rad];\npert selects the perturbation terms it should be used, it can be :J0, :J2, or :J4[1]; and\norb is an instance of Orbit.","category":"page"},{"location":"man/orbit/general/","page":"General analysis","title":"General analysis","text":"julia> period(7130982, 0.001111, deg2rad(98.405))/60\n100.00000980636328\n\njulia> period(7130982, 0.001111, deg2rad(98.405), :J0)/60\n99.88119746433748","category":"page"},{"location":"man/orbit/general/","page":"General analysis","title":"General analysis","text":"","category":"page"},{"location":"man/orbit/general/","page":"General analysis","title":"General analysis","text":"[1]: If pert is :J0, then it will be considered a Keplerian, unperturbed orbit to compute the values. If pert is :J2, then it will be considered the perturbation terms up to J_2 to compute the values. Otherwise, if pert is :J4, then it will be considered the perturbation terms J_2, J_4, and J_2^2 to compute the values. If pert is omitted, then it defaults to :J2.","category":"page"},{"location":"man/earth/geomagnetic_field_models/#Earth-geomagnetic-field-models","page":"Earth geomagnetic field models","title":"Earth geomagnetic field models","text":"","category":"section"},{"location":"man/earth/geomagnetic_field_models/","page":"Earth geomagnetic field models","title":"Earth geomagnetic field models","text":"CurrentModule = SatelliteToolbox\nDocTestSetup = quote\n    using SatelliteToolbox\nend","category":"page"},{"location":"man/earth/geomagnetic_field_models/","page":"Earth geomagnetic field models","title":"Earth geomagnetic field models","text":"Currently, there is two models in this toolbox to compute the Earth geomagnetic field: the IGFR model and the simplified dipole model.","category":"page"},{"location":"man/earth/geomagnetic_field_models/#IGRF","page":"Earth geomagnetic field models","title":"IGRF","text":"","category":"section"},{"location":"man/earth/geomagnetic_field_models/","page":"Earth geomagnetic field models","title":"Earth geomagnetic field models","text":"There is a native Julia implementation of the International Geomagnetic Reference Field (IGRF) v13. This can be accessed by two functions:","category":"page"},{"location":"man/earth/geomagnetic_field_models/","page":"Earth geomagnetic field models","title":"Earth geomagnetic field models","text":"igrf13syn: This is the native Julia implementation of the original FORTRAN source-code with the same input parameters.\nigrf: An independent (more readable) implementation of the IGRF model. However, it is not as fast as igrf13syn yet (~20% slower).","category":"page"},{"location":"man/earth/geomagnetic_field_models/","page":"Earth geomagnetic field models","title":"Earth geomagnetic field models","text":"The igrf function has the following signature:","category":"page"},{"location":"man/earth/geomagnetic_field_models/","page":"Earth geomagnetic field models","title":"Earth geomagnetic field models","text":"function igrf(date::Number, [r,h]::Number, λ::Number, Ω::Number, T[, P, dP]; show_warns = true)","category":"page"},{"location":"man/earth/geomagnetic_field_models/","page":"Earth geomagnetic field models","title":"Earth geomagnetic field models","text":"It computes the geomagnetic field vector [nT] at the date date [Year A.D.] and position (r, λ, Ω).","category":"page"},{"location":"man/earth/geomagnetic_field_models/","page":"Earth geomagnetic field models","title":"Earth geomagnetic field models","text":"The position representation is defined by T. If T is Val(:geocentric), then the input must be geocentric coordinates:","category":"page"},{"location":"man/earth/geomagnetic_field_models/","page":"Earth geomagnetic field models","title":"Earth geomagnetic field models","text":"Distance from the Earth center r [m];\nGeocentric latitude λ (-pi2, +pi2) [rad]; and\nGeocentric longitude Ω (-pi, +pi) [rad].","category":"page"},{"location":"man/earth/geomagnetic_field_models/","page":"Earth geomagnetic field models","title":"Earth geomagnetic field models","text":"If T is Val(:geodetic), then the input must be geodetic coordinates:","category":"page"},{"location":"man/earth/geomagnetic_field_models/","page":"Earth geomagnetic field models","title":"Earth geomagnetic field models","text":"Altitude above the reference ellipsoid h (WGS-84) [m];\nGeodetic latitude λ (-pi2, +pi2) [rad]; and\nGeodetic longitude Ω (-pi, +pi) [rad].","category":"page"},{"location":"man/earth/geomagnetic_field_models/","page":"Earth geomagnetic field models","title":"Earth geomagnetic field models","text":"If T is omitted, then it defaults to Val(:geocentric).","category":"page"},{"location":"man/earth/geomagnetic_field_models/","page":"Earth geomagnetic field models","title":"Earth geomagnetic field models","text":"Notice that the output vector will be represented in the same reference system selected by the parameter T (geocentric or geodetic). The Y-axis of the output reference system always points East. In case of geocentric coordinates, the Z-axis points toward the center of Earth and the X-axis completes a right-handed coordinate system. In case of geodetic coordinates, the X-axis is tangent to the ellipsoid at the selected location and points toward North, whereas the Z-axis completes a right-hand coordinate system.","category":"page"},{"location":"man/earth/geomagnetic_field_models/","page":"Earth geomagnetic field models","title":"Earth geomagnetic field models","text":"The optional arguments P and dP must be two matrices with at least 14x14 real numbers. If they are present, then they will be used to store the Legendre coefficients and their derivatives. In this case, no allocation will be performed when computing the magnetic field. If they are not present, then 2 allocations will happen to create them.","category":"page"},{"location":"man/earth/geomagnetic_field_models/","page":"Earth geomagnetic field models","title":"Earth geomagnetic field models","text":"If the keyword show_warns is true (default), then warnings will be printed to STDOUT.","category":"page"},{"location":"man/earth/geomagnetic_field_models/","page":"Earth geomagnetic field models","title":"Earth geomagnetic field models","text":"The latitude λ and longitude Ω can be passed in degrees instead of radians by using the function igrfd. All the other arguments and keywords of this function are the same as those in the function igrf.","category":"page"},{"location":"man/earth/geomagnetic_field_models/","page":"Earth geomagnetic field models","title":"Earth geomagnetic field models","text":"note: Note\nThe IGRF v13 implemented here can be used to compute the geomagnetic field from 1900 up to 2030. Notice, however, that for dates after 2025 the accuracy is reduced.","category":"page"},{"location":"man/earth/geomagnetic_field_models/","page":"Earth geomagnetic field models","title":"Earth geomagnetic field models","text":"julia> igrf(2017.12313, 640e3, 50*pi/180, 25*pi/180, Val(:geodetic))\n3-element StaticArrays.SVector{3, Float64} with indices SOneTo(3):\n 15365.787505205592\n  1274.9958640697\n 34201.21820333791\n\njulia> igrfd(2017.12313, 640e3, 50, 25, Val(:geodetic))\n3-element StaticArrays.SVector{3, Float64} with indices SOneTo(3):\n 15365.787505205592\n  1274.9958640697\n 34201.21820333791\n\njulia> igrf(2017.12313, 6371e3+640e3, 50*pi/180, 25*pi/180, Val(:geocentric))\n3-element StaticArrays.SVector{3, Float64} with indices SOneTo(3):\n 15165.486702524944\n  1269.7264334427598\n 34243.04928373083\n\njulia> igrfd(2017.12313, 6371e3+640e3, 50, 25, Val(:geocentric))\n3-element StaticArrays.SVector{3, Float64} with indices SOneTo(3):\n 15165.486702524944\n  1269.7264334427598\n 34243.04928373083","category":"page"},{"location":"man/earth/geomagnetic_field_models/","page":"Earth geomagnetic field models","title":"Earth geomagnetic field models","text":"julia> igrf(2026, 6371e3+640e3, 50*pi/180, 25*pi/180)\n┌ Warning: The magnetic field computed with this IGRF version may be of reduced accuracy for years greater than 2025.\n└ @ SatelliteToolbox ~/.julia/dev/SatelliteToolbox/src/earth/geomagnetic_field_models/igrf/igrf.jl:103\n3-element StaticArrays.SVector{3, Float64} with indices SOneTo(3):\n 15118.591511098817\n  1588.129544718571\n 34668.84185460438\n\njulia> igrfd(2026, 6371e3+640e3, 50, 25)\n┌ Warning: The magnetic field computed with this IGRF version may be of reduced accuracy for years greater than 2025.\n└ @ SatelliteToolbox ~/.julia/dev/SatelliteToolbox/src/earth/geomagnetic_field_models/igrf/igrf.jl:103\n3-element StaticArrays.SVector{3, Float64} with indices SOneTo(3):\n 15118.591511098817\n  1588.129544718571\n 34668.84185460438\n\njulia> igrf(2026, 6371e3+640e3, 50*pi/180, 25*pi/180; show_warns = false)\n3-element StaticArrays.SVector{3, Float64} with indices SOneTo(3):\n 15118.591511098817\n  1588.129544718571\n 34668.84185460438\n\njulia> igrfd(2026, 6371e3+640e3, 50, 25; show_warns = false)\n3-element StaticArrays.SVector{3, Float64} with indices SOneTo(3):\n 15118.591511098817\n  1588.129544718571\n 34668.84185460438","category":"page"},{"location":"man/earth/geomagnetic_field_models/","page":"Earth geomagnetic field models","title":"Earth geomagnetic field models","text":"info: Info\nFor compatibility reasons, the v12 of the IGRF model is still available using the function igrf12syn.","category":"page"},{"location":"man/earth/geomagnetic_field_models/#Simplified-dipole-model","page":"Earth geomagnetic field models","title":"Simplified dipole model","text":"","category":"section"},{"location":"man/earth/geomagnetic_field_models/","page":"Earth geomagnetic field models","title":"Earth geomagnetic field models","text":"This model assumes that the Earth geomagnetic field is a perfect dipole. The approximation is not good, but it can be sufficient for some analysis, such as those carried out at the Pre-Phase A of a space mission, when the uncertainties are very high.","category":"page"},{"location":"man/earth/geomagnetic_field_models/","page":"Earth geomagnetic field models","title":"Earth geomagnetic field models","text":"The functions that can be used to compute the Earth geomagnetic field using this simplified model are:","category":"page"},{"location":"man/earth/geomagnetic_field_models/","page":"Earth geomagnetic field models","title":"Earth geomagnetic field models","text":"    function geomag_dipole(r_e::AbstractVector, pole_lat::Number, pole_lon::Number, m::Number)\n    function geomag_dipole(r_e::AbstractVector, year::Number = 2019)","category":"page"},{"location":"man/earth/geomagnetic_field_models/","page":"Earth geomagnetic field models","title":"Earth geomagnetic field models","text":"In the first, the geomagnetic field [nT] is computed using the simplified dipole model at position r_e (ECEF reference frame). This function considers that the latitude of the South magnetic pole (which lies in the North hemisphere) is pole_lat [rad] and the longitude is pole_lon [rad]. Furthermore, the dipole moment is considered to be m [A.m²].","category":"page"},{"location":"man/earth/geomagnetic_field_models/","page":"Earth geomagnetic field models","title":"Earth geomagnetic field models","text":"In the second, the geomagnetic field [nT] is computed using the simplified dipole model at position r_e (ECEF reference frame). This function uses the year year to obtain the position of the South magnetic pole (which lies in the North hemisphere) and the dipole moment. If year is omitted, then it will be considered as 2019.","category":"page"},{"location":"man/earth/geomagnetic_field_models/","page":"Earth geomagnetic field models","title":"Earth geomagnetic field models","text":"note: Note\nIn both functions, the output vector will be represented in the ECEF reference frame.","category":"page"},{"location":"man/earth/geomagnetic_field_models/","page":"Earth geomagnetic field models","title":"Earth geomagnetic field models","text":"julia> r_e = [0;0;R0+200e3];\n\njulia> geomag_dipole(r_e)\n3-element StaticArrays.SVector{3, Float64} with indices SOneTo(3):\n   1286.02428617178\n  -4232.804339060698\n -53444.68086319672\n\njulia> geomag_dipole(r_e, 1986)\n3-element StaticArrays.SVector{3, Float64} with indices SOneTo(3):\n   1715.2656071053527\n  -4964.598060841779\n -54246.30480714958\n\njulia> r_e = [R0+200e3;0;0];\n\njulia> geomag_dipole(r_e)\n3-element StaticArrays.SVector{3, Float64} with indices SOneTo(3):\n -2572.04857234356\n -4232.804339060698\n 26722.34043159836\n\njulia> geomag_dipole(r_e, 1986)\n3-element StaticArrays.SVector{3, Float64} with indices SOneTo(3):\n -3430.5312142107055\n -4964.598060841779\n 27123.15240357479","category":"page"},{"location":"man/earth/space_indices/#Space-indices","page":"Space indices","title":"Space indices","text":"","category":"section"},{"location":"man/earth/space_indices/","page":"Space indices","title":"Space indices","text":"The SatelliteToolbox.jl can automatically fetch some space indices that are used in some computations, notably in the earth atmospheric models. First, it is necessary to initialize the related files, which is done by the function:","category":"page"},{"location":"man/earth/space_indices/","page":"Space indices","title":"Space indices","text":"function init_space_indices(...)","category":"page"},{"location":"man/earth/space_indices/","page":"Space indices","title":"Space indices","text":"When called without arguments, it will download all the supported files, if necessary. For more information about the many configuration options, please, see the function documentation.","category":"page"},{"location":"man/earth/space_indices/","page":"Space indices","title":"Space indices","text":"The supported files are:","category":"page"},{"location":"man/earth/space_indices/","page":"Space indices","title":"Space indices","text":"File Download frequency Information\nDTCFILE.TXT Daily This file contains the exospheric temperature variation caused by the Dst index. This is used for the JB2008 atmospheric model.\nfluxtable.txt Daily This file contains the F10.7 flux data in different formats.\nSOLFSMY.TXT Daily This files contains the indices necessary for the JB2008 atmospheric model.\nWDC Files Once / Daily* This set of files contain the Kp and Ap indices.","category":"page"},{"location":"man/earth/space_indices/","page":"Space indices","title":"Space indices","text":"*: The WDC files are separated by year. The file related to the current year is downloaded on a daily-basis and the files related to the previous years are downloaded only once.","category":"page"},{"location":"man/earth/space_indices/","page":"Space indices","title":"Space indices","text":"After the initialization of the files, the space indices can be obtained by the following function:","category":"page"},{"location":"man/earth/space_indices/","page":"Space indices","title":"Space indices","text":"function get_space_index(IND, JD::Number, ...)","category":"page"},{"location":"man/earth/space_indices/","page":"Space indices","title":"Space indices","text":"in which JD is the Julian Day in which the index will be computed, and IND is the desired space index as described in the following table.","category":"page"},{"location":"man/earth/space_indices/","page":"Space indices","title":"Space indices","text":"IND Space index\nF10() 10.7-cm adjusted solar flux\nF10adj() 10.7-cm adjusted solar flux\nF10obs() 10.7-cm observed solar flux\nF10M() Average of 10.7-cm adjusted solar flux\nF10Madj() Average of 10.7-cm adjusted solar flux\nF10Mobs() Average of 10.7-cm observed solar flux\nKp() Kp index (daily mean)\nKp_vect() A vector containing the Kp index for the following hours of the day: 0-3h, 3-6h, 6-9h, 9-12h, 12-15h, 15-18h, 18-20h, 20-23h\nAp() Ap index (daily mean)\nAp_vect() A vector containing the Ap index for the following hours of the day: 0-3h, 3-6h, 6-9h, 9-12h, 12-15h, 15-18h, 18-20h, 20-23h\nS10() EUV index (26-34 nm) scaled to F10.7\nM10() MG2 index scaled to F10.7\nY10() Solar X-ray & Lya index scaled to F10.7\nS81a() EUV 81-day averaged centered index\nM81a() MG2 81-day averaged centered index\nY81a() Solar X-ray & Lya 81-day averaged centered index\nDstΔTc() Exospheric temperature variation due to Dst","category":"page"},{"location":"man/earth/space_indices/","page":"Space indices","title":"Space indices","text":"note: Note\nThe index DstΔTc() is interpolated to the selected instant of the Julian Day, whereas all the other indices are constants within the seleteced day.","category":"page"},{"location":"man/earth/space_indices/","page":"Space indices","title":"Space indices","text":"note: Note\nFor the indices F10M(), F10Madj(), and F10Mobs(), one can use an optional keyword window::Int that defines the size in days of the moving average window. If it is not specified, then it defaults to 81 days.","category":"page"},{"location":"man/earth/space_indices/","page":"Space indices","title":"Space indices","text":"julia> init_space_indices()\n[ Info: Downloading file 'DTCFILE.TXT' from 'http://sol.spacenvironment.net/jb2008/indices/DTCFILE.TXT'.\n[ Info: Downloading file 'fluxtable.txt' from 'ftp://ftp.geolab.nrcan.gc.ca/data/solar_flux/daily_flux_values/fluxtable.txt'.\n[ Info: Downloading file 'SOLFSMY.TXT' from 'http://sol.spacenvironment.net/jb2008/indices/SOLFSMY.TXT'.\n[ Info: Downloading file 'kp2017.wdc' from 'ftp://ftp.gfz-potsdam.de/pub/home/obs/kp-ap/wdc/kp2017.wdc'.\n[ Info: Downloading file 'kp2015.wdc' from 'ftp://ftp.gfz-potsdam.de/pub/home/obs/kp-ap/wdc/kp2015.wdc'.\n[ Info: Downloading file 'kp2016.wdc' from 'ftp://ftp.gfz-potsdam.de/pub/home/obs/kp-ap/wdc/kp2016.wdc'.\n[ Info: Downloading file 'kp2018.wdc' from 'ftp://ftp.gfz-potsdam.de/pub/home/obs/kp-ap/wdc/kp2018.wdc'.\n\njulia> get_space_index(F10(), date_to_jd(2018, 6, 19, 18, 35, 00))\n79.0\n\njulia> get_space_index(F10M(), date_to_jd(2018, 6, 19, 18, 35, 00))\n73.47037037037039\n\njulia> get_space_index(F10M(), date_to_jd(2018, 6, 19, 18, 35, 00); window = 51)\n74.60196078431372\n\njulia> get_space_index(Ap(), date_to_jd(2018, 6, 19, 18, 35, 00))\n5.125","category":"page"},{"location":"man/transformations/geodetic_geocentric/#Geodetic-and-Geocentric","page":"Geodetic and Geocentric","title":"Geodetic and Geocentric","text":"","category":"section"},{"location":"man/transformations/geodetic_geocentric/","page":"Geodetic and Geocentric","title":"Geodetic and Geocentric","text":"CurrentModule = SatelliteToolbox\nDocTestSetup = quote\n    using SatelliteToolbox\nend","category":"page"},{"location":"man/transformations/geodetic_geocentric/","page":"Geodetic and Geocentric","title":"Geodetic and Geocentric","text":"There are three functions that can help to convert between geodetic and geocentric representations. Notice that currently all Geodetic representations are based on the WGS84 reference ellipsoid.","category":"page"},{"location":"man/transformations/geodetic_geocentric/#ECEF-to-Geodetic","page":"Geodetic and Geocentric","title":"ECEF to Geodetic","text":"","category":"section"},{"location":"man/transformations/geodetic_geocentric/","page":"Geodetic and Geocentric","title":"Geodetic and Geocentric","text":"It is possible to convert a position vector represented in an Earth-Centered, Earth-Fixed frame (ECEF) r_e to the Geodetic latitude, longitude, and altitude by the following function:","category":"page"},{"location":"man/transformations/geodetic_geocentric/","page":"Geodetic and Geocentric","title":"Geodetic and Geocentric","text":"function ecef_to_geodetic(r_e::AbstractVector)","category":"page"},{"location":"man/transformations/geodetic_geocentric/","page":"Geodetic and Geocentric","title":"Geodetic and Geocentric","text":"which returns a tuple with:","category":"page"},{"location":"man/transformations/geodetic_geocentric/","page":"Geodetic and Geocentric","title":"Geodetic and Geocentric","text":"The Geocentric latitude [rad];\nThe longitude [rad]; and\nThe altitude above the reference ellipsoid [m].","category":"page"},{"location":"man/transformations/geodetic_geocentric/","page":"Geodetic and Geocentric","title":"Geodetic and Geocentric","text":"julia> ecef_to_geodetic([R0;0;0])\n(0.0, 0.0, 0.0)\n\njulia> ecef_to_geodetic([0;R0;0])\n(0.0, 1.5707963267948966, 0.0)\n\njulia> ecef_to_geodetic([0;0;R0])\n(1.5707963267948966, 0.0, 21384.685754820704)","category":"page"},{"location":"man/transformations/geodetic_geocentric/#Geodetic-to-ECEF","page":"Geodetic and Geocentric","title":"Geodetic to ECEF","text":"","category":"section"},{"location":"man/transformations/geodetic_geocentric/","page":"Geodetic and Geocentric","title":"Geodetic and Geocentric","text":"The Geodetic latitude lat [rad], longitude lon [rad], and altitude h [m] can be converted to a vector represented in an ECEF reference frame by the following function:","category":"page"},{"location":"man/transformations/geodetic_geocentric/","page":"Geodetic and Geocentric","title":"Geodetic and Geocentric","text":"function geodetic_to_ecef(lat::Number, lon::Number, h::Number)","category":"page"},{"location":"man/transformations/geodetic_geocentric/","page":"Geodetic and Geocentric","title":"Geodetic and Geocentric","text":"in which a 3x1 vector will be returned.","category":"page"},{"location":"man/transformations/geodetic_geocentric/","page":"Geodetic and Geocentric","title":"Geodetic and Geocentric","text":"julia> geodetic_to_ecef(0,0,0)\n3-element StaticArrays.SVector{3, Float64} with indices SOneTo(3):\n 6.378137e6\n 0.0\n 0.0\n\njulia> geodetic_to_ecef(deg2rad(-22),deg2rad(-45),0)\n3-element StaticArrays.SVector{3, Float64} with indices SOneTo(3):\n  4.1835869067109847e6\n -4.1835869067109837e6\n -2.3744128953028163e6","category":"page"},{"location":"man/transformations/geodetic_geocentric/#Geocentric-to-Geodetic","page":"Geodetic and Geocentric","title":"Geocentric to Geodetic","text":"","category":"section"},{"location":"man/transformations/geodetic_geocentric/","page":"Geodetic and Geocentric","title":"Geodetic and Geocentric","text":"Given a Geocentric latitude ϕ_gc [rad] and distance from the center of Earth r [m], one can obtain the Geodetic coordinates (Geodetic latitude and altitude above the reference ellipsoid - WGS84) using the following function:","category":"page"},{"location":"man/transformations/geodetic_geocentric/","page":"Geodetic and Geocentric","title":"Geodetic and Geocentric","text":"function geocentric_to_geodetic(ϕ_gc::Number, r::Number)","category":"page"},{"location":"man/transformations/geodetic_geocentric/","page":"Geodetic and Geocentric","title":"Geodetic and Geocentric","text":"in which a tuple with two values will be returned:","category":"page"},{"location":"man/transformations/geodetic_geocentric/","page":"Geodetic and Geocentric","title":"Geodetic and Geocentric","text":"The Geodetic latitude [rad]; and\nThe altitude about the reference ellipsoid (WGS-84) [m].","category":"page"},{"location":"man/transformations/geodetic_geocentric/","page":"Geodetic and Geocentric","title":"Geodetic and Geocentric","text":"note: Note\nThe longitude is the same in both Geodetic and Geocentric representations.","category":"page"},{"location":"man/transformations/geodetic_geocentric/","page":"Geodetic and Geocentric","title":"Geodetic and Geocentric","text":"julia> geocentric_to_geodetic(deg2rad(-22), R0)\n(-0.3863099329112617, 3013.9291869809385)\n\njulia> geocentric_to_geodetic(0, R0)\n(0.0, 0.0)","category":"page"},{"location":"man/transformations/geodetic_geocentric/#Geodetic-to-Geocentric","page":"Geodetic and Geocentric","title":"Geodetic to Geocentric","text":"","category":"section"},{"location":"man/transformations/geodetic_geocentric/","page":"Geodetic and Geocentric","title":"Geodetic and Geocentric","text":"Given a Geodetic latitude ϕ_gd [rad] and altitude above the reference ellipsoid h [m], one can obtain the Geocentric coordinates (Geocentric latitude and position from the center of Earth) using the following function:","category":"page"},{"location":"man/transformations/geodetic_geocentric/","page":"Geodetic and Geocentric","title":"Geodetic and Geocentric","text":"function geodetic_to_geocentric(ϕ_gd::Number, h::Number)","category":"page"},{"location":"man/transformations/geodetic_geocentric/","page":"Geodetic and Geocentric","title":"Geodetic and Geocentric","text":"in which a tuple with two values will be returned:","category":"page"},{"location":"man/transformations/geodetic_geocentric/","page":"Geodetic and Geocentric","title":"Geodetic and Geocentric","text":"The Geocentric latitude [rad]; and\nThe distance from the center of Earth [m].","category":"page"},{"location":"man/transformations/geodetic_geocentric/","page":"Geodetic and Geocentric","title":"Geodetic and Geocentric","text":"note: Note\nThe longitude is the same in both Geodetic and Geocentric representations.","category":"page"},{"location":"man/transformations/geodetic_geocentric/","page":"Geodetic and Geocentric","title":"Geodetic and Geocentric","text":"julia> geodetic_to_geocentric(deg2rad(-22), 0)\n(-0.38164509973650357, 6.375157677217675e6)\n\njulia> geodetic_to_geocentric(0,0)\n(0.0, 6.378137e6)","category":"page"},{"location":"man/earth/atmospheric_models/#Earth-atmospheric-models","page":"Earth atmospheric models","title":"Earth atmospheric models","text":"","category":"section"},{"location":"man/earth/atmospheric_models/","page":"Earth atmospheric models","title":"Earth atmospheric models","text":"CurrentModule = SatelliteToolbox\nDocTestSetup = quote\n    using SatelliteToolbox\nend","category":"page"},{"location":"man/earth/atmospheric_models/","page":"Earth atmospheric models","title":"Earth atmospheric models","text":"This package implements natively three atmospheric models:","category":"page"},{"location":"man/earth/atmospheric_models/","page":"Earth atmospheric models","title":"Earth atmospheric models","text":"Exponential atmospheric model according to [1];\nJacchia-Roberts 1971;\nJacchia-Bowman 2008; and\nNRLMSISE-00.","category":"page"},{"location":"man/earth/atmospheric_models/#Exponential-atmospheric-model","page":"Earth atmospheric models","title":"Exponential atmospheric model","text":"","category":"section"},{"location":"man/earth/atmospheric_models/","page":"Earth atmospheric models","title":"Earth atmospheric models","text":"This model assumes that the atmospheric density is computed by:","category":"page"},{"location":"man/earth/atmospheric_models/","page":"Earth atmospheric models","title":"Earth atmospheric models","text":"rho(h) = rho_0 cdot exp leftlbrace - frach - h_0H rightrbrace","category":"page"},{"location":"man/earth/atmospheric_models/","page":"Earth atmospheric models","title":"Earth atmospheric models","text":"in which rho_0, h_0, and H are parameters obtained from tables. Reference [1] provides a discretization of those parameters based on the selected height h that was obtained after evaluation of some accurate models.","category":"page"},{"location":"man/earth/atmospheric_models/","page":"Earth atmospheric models","title":"Earth atmospheric models","text":"In this toolbox, the model can be evaluated using the following function:","category":"page"},{"location":"man/earth/atmospheric_models/","page":"Earth atmospheric models","title":"Earth atmospheric models","text":"function expatmosphere(h::Number)","category":"page"},{"location":"man/earth/atmospheric_models/","page":"Earth atmospheric models","title":"Earth atmospheric models","text":"in which h is the desired height in meters.","category":"page"},{"location":"man/earth/atmospheric_models/","page":"Earth atmospheric models","title":"Earth atmospheric models","text":"julia> expatmosphere(700e3)\n3.614e-14","category":"page"},{"location":"man/earth/atmospheric_models/","page":"Earth atmospheric models","title":"Earth atmospheric models","text":"warning: Warning\nNotice that this model does not consider important effects such as the Sun activity, the geomagnetic activity, the local time at the desired location, etc.  Hence, although this can be used for fast evaluations, the accuracy is not good.","category":"page"},{"location":"man/earth/atmospheric_models/#Jacchia-Roberts-1971","page":"Earth atmospheric models","title":"Jacchia-Roberts 1971","text":"","category":"section"},{"location":"man/earth/atmospheric_models/","page":"Earth atmospheric models","title":"Earth atmospheric models","text":"This is an analytic atmospheric model based on the Jacchia's 1970 model. It was published in:","category":"page"},{"location":"man/earth/atmospheric_models/","page":"Earth atmospheric models","title":"Earth atmospheric models","text":"Roberts, C. E (1971). An analytic model for upper atmosphere densities based upon Jacchia's 1970 models. Celestial mechanics, Vol. 4 (3-4), p. 368-377, DOI: 10.1007/BF01231398.","category":"page"},{"location":"man/earth/atmospheric_models/","page":"Earth atmospheric models","title":"Earth atmospheric models","text":"Although it is quite old, this model is still used for some applications, like computing the estimated reentry time for an object on low Earth orbits.","category":"page"},{"location":"man/earth/atmospheric_models/","page":"Earth atmospheric models","title":"Earth atmospheric models","text":"In this toolbox, the model can be evaluated using the following function:","category":"page"},{"location":"man/earth/atmospheric_models/","page":"Earth atmospheric models","title":"Earth atmospheric models","text":"function jr1971(JD::Number, glat::Number, glon::Number, h::Number, F10::Number, F10ₐ::Number, Kp::Number)","category":"page"},{"location":"man/earth/atmospheric_models/","page":"Earth atmospheric models","title":"Earth atmospheric models","text":"in which:","category":"page"},{"location":"man/earth/atmospheric_models/","page":"Earth atmospheric models","title":"Earth atmospheric models","text":"JD: Julian day.\nglat: Geodetic latitude [rad].\nglon: Geodetic longitude [rad].\nh: Altitude [m].\nF10: 10.7-cm solar flux [10⁻²² W/(M² Hz)].\nF10ₐ: 10.7-cm averaged solar flux, 81-day centered on input time.\nKp: Kp geomagnetic index (with a delay of 3 hours).","category":"page"},{"location":"man/earth/atmospheric_models/","page":"Earth atmospheric models","title":"Earth atmospheric models","text":"Unfortunately, it does not support fetching the space indices automatically yet.","category":"page"},{"location":"man/earth/atmospheric_models/","page":"Earth atmospheric models","title":"Earth atmospheric models","text":"This function returns an object of type JR1971_Output that contains the following fields:","category":"page"},{"location":"man/earth/atmospheric_models/","page":"Earth atmospheric models","title":"Earth atmospheric models","text":"nN2: Number density of N₂ [1/m³].\nnO2: Number density of O₂ [1/m³].\nnO: Number density of O [1/m³].\nnAr: Number density of Ar [1/m³].\nnHe: Number density of He [1/m³].\nnH: Number density of H [1/m³].\nrho: Total density [kg/m³].\nT_exo: Exospheric temperature [K].\nTz: Temperature at the selected altitude [K].","category":"page"},{"location":"man/earth/atmospheric_models/","page":"Earth atmospheric models","title":"Earth atmospheric models","text":"julia> jr1971(date_to_jd(2018, 6, 19, 18, 35, 0), deg2rad(-22), deg2rad(-45), 700e3, 79, 73.5, 1.34)\nJR1971_Output{Float64}\n  nN2: Float64 2.8434980991303828e7\n  nO2: Float64 174222.87498004676\n  nO: Float64 1.4139107014677634e11\n  nAr: Float64 8.972570981074634\n  nHe: Float64 8.773885389988534e11\n  nH: Float64 5.702781005702269e10\n  rho: Float64 9.684902904883958e-15\n  T_exo: Float64 832.0244272210394\n  Tz: Float64 832.0204436414625","category":"page"},{"location":"man/earth/atmospheric_models/#Jacchia-Bowman-2008","page":"Earth atmospheric models","title":"Jacchia-Bowman 2008","text":"","category":"section"},{"location":"man/earth/atmospheric_models/","page":"Earth atmospheric models","title":"Earth atmospheric models","text":"This is an empirical thermospheric density model based on the Jacchia theory. It was published in:","category":"page"},{"location":"man/earth/atmospheric_models/","page":"Earth atmospheric models","title":"Earth atmospheric models","text":"Bowman, B. R., Tobiska, W. K., Marcos, F. A., Huang, C. Y., Lin, C. S., Burke, W. J (2008). A new empirical thermospheric density model JB2008 using new solar and geomagnetic indices. In the proeceeding of the AIAA/AAS Astrodynamics Specialist Conference, Honolulu, Hawaii.","category":"page"},{"location":"man/earth/atmospheric_models/","page":"Earth atmospheric models","title":"Earth atmospheric models","text":"For more information, visit http://sol.spacenvironment.net/jb2008.","category":"page"},{"location":"man/earth/atmospheric_models/","page":"Earth atmospheric models","title":"Earth atmospheric models","text":"In this toolbox, the model can be evaluated using the following functions:","category":"page"},{"location":"man/earth/atmospheric_models/","page":"Earth atmospheric models","title":"Earth atmospheric models","text":"function jb2008(JD::Number, glat::Number, glon::Number, h::Number)\nfunction jb2008(JD::Number, glat::Number, glon::Number, h::Number, F10::Number, F10ₐ::Number, S10::Number, S10ₐ::Number, M10::Number, M10ₐ::Number, Y10::Number, Y10ₐ::Number, DstΔTc::Number)","category":"page"},{"location":"man/earth/atmospheric_models/","page":"Earth atmospheric models","title":"Earth atmospheric models","text":"in which:","category":"page"},{"location":"man/earth/atmospheric_models/","page":"Earth atmospheric models","title":"Earth atmospheric models","text":"JD: Julian day.\nglat: Geocentric latitude [rad].\nglon: Geocentric longitude [rad].\nh: Altitude [m].\nF10: 10.7-cm solar flux [10⁻²² W/(M² Hz)] (Tabular time 1 day earlier).\nF10ₐ: 10.7-cm averaged solar flux, 81-day centered on input time (Tabular         time 1 day earlier).\nS10: EUV index (26-34 nm) scaled to F10.7 (Tabular time 1 day earlier).\nS10ₐ: EUV 81-day averaged centered index (Tabular time 1 day earlier).\nM10: MG2 index scaled to F10.7 (Tabular time 2 days earlier).\nM10ₐ: MG2 81-day averaged centered index (Tabular time 2 days earlier).\nY10: Solar X-ray & Lya index scaled to F10.7 (Tabular time 5 days earlier).\nY10ₐ: Solar X-ray & Lya 81-day averaged centered index (Tabular time 5 days         earlier).\nDstΔTc: Temperature variation related to the Dst.","category":"page"},{"location":"man/earth/atmospheric_models/","page":"Earth atmospheric models","title":"Earth atmospheric models","text":"If the parameters related with the space indices are not provided (first signature), then they will be automatically obtained. This, however, requires the initialization of the space indices (see [Space indices]).","category":"page"},{"location":"man/earth/atmospheric_models/","page":"Earth atmospheric models","title":"Earth atmospheric models","text":"These functions returns an object of type JB2008_Output that contains the following fields:","category":"page"},{"location":"man/earth/atmospheric_models/","page":"Earth atmospheric models","title":"Earth atmospheric models","text":"nN2: Number density of N₂ [1/m³].\nnO2: Number density of O₂ [1/m³].\nnO: Number density of O [1/m³].\nnAr: Number density of Ar [1/m³].\nnHe: Number density of He [1/m³].\nnH: Number density of H [1/m³].\nrho: Total density [kg/m³].\nT_exo: Exospheric temperature [K].\nTz: Temperature at the selected altitude [K].","category":"page"},{"location":"man/earth/atmospheric_models/","page":"Earth atmospheric models","title":"Earth atmospheric models","text":"julia> jb2008(date_to_jd(2018, 6, 19, 18, 35, 0), deg2rad(-22), deg2rad(-45), 700e3, 79, 73.5, 55.1, 53.8, 78.9, 73.3, 80.2, 71.7, 50)\nJB2008_Output{Float64}\n  nN2: Float64 2.6541724729332495e7\n  nO2: Float64 193981.21643718384\n  nO: Float64 7.674571609797285e10\n  nAr: Float64 13.375957587876071\n  nHe: Float64 4.642052516165976e11\n  nH: Float64 4.072455917445681e10\n  rho: Float64 5.193318161219548e-15\n  T_exo: Float64 819.7144509572893\n  Tz: Float64 826.7686603272322","category":"page"},{"location":"man/earth/atmospheric_models/#NRLMSISE-00","page":"Earth atmospheric models","title":"NRLMSISE-00","text":"","category":"section"},{"location":"man/earth/atmospheric_models/","page":"Earth atmospheric models","title":"Earth atmospheric models","text":"The NRLMSIS-00 empirical atmosphere model was developed by Mike Picone, Alan Hedin, and Doug Drob based on the MSISE90 model:","category":"page"},{"location":"man/earth/atmospheric_models/","page":"Earth atmospheric models","title":"Earth atmospheric models","text":"Picone, J. M., Hedin, A. E., Drob, D. P., Aikin, A. C (2002). NRLMSISE-00 empirical model of the atmosphere: Statistical comparisons and scientific issues. Journal of Geophysical Research: Space Physics, Vol. 107 (A12), p. SIA 15-1 – SIA 15-16, DOI: 10.1029/2002JA009430.","category":"page"},{"location":"man/earth/atmospheric_models/","page":"Earth atmospheric models","title":"Earth atmospheric models","text":"In this toolbox, the model can be evaluated using the following function:","category":"page"},{"location":"man/earth/atmospheric_models/","page":"Earth atmospheric models","title":"Earth atmospheric models","text":"function nrlmsise00(JD::Number, alt::Number, g_lat::Number, g_long::Number [, f107A::Number, f107::Number, ap::Union{Number,AbstractVector}]; output_si::Bool = true, dversion::Bool = true)","category":"page"},{"location":"man/earth/atmospheric_models/","page":"Earth atmospheric models","title":"Earth atmospheric models","text":"in which:","category":"page"},{"location":"man/earth/atmospheric_models/","page":"Earth atmospheric models","title":"Earth atmospheric models","text":"JD: Julian Day [UTC].\nalt: Altitude [m].\ng_lat: Geodetic latitude [rad].\ng_long: Geodetic longitude [rad].\nf107A: 81 day average of F10.7 flux (centered on day of year doy).\nf107: Daily F10.7 flux for previous day.\nap: Magnetic index.","category":"page"},{"location":"man/earth/atmospheric_models/","page":"Earth atmospheric models","title":"Earth atmospheric models","text":"If the keyword output_si is true, then the output will be in [m⁻³] for species number density and [kg/m⁻³] for the total density. Otherwise, the units will be [cm⁻³] and [g/cm⁻³], respectively.","category":"page"},{"location":"man/earth/atmospheric_models/","page":"Earth atmospheric models","title":"Earth atmospheric models","text":"The keyword dversion can be used to select which algorithm will be used to compute the model. If it is set to true, then it will call the gtd7d function that includes the anomalous oxygen in the total density. Otherwise, the function gtd7 will be called and the anomalous oxygen will not be added in the total density.","category":"page"},{"location":"man/earth/atmospheric_models/","page":"Earth atmospheric models","title":"Earth atmospheric models","text":"The parameter ap can be a number or a vector. If it is a number, then it must be the daily magnetic index. If it is a vector, then it must contain 7 elements as follows:","category":"page"},{"location":"man/earth/atmospheric_models/","page":"Earth atmospheric models","title":"Earth atmospheric models","text":"Index Description\n1 Daily AP.\n2 3 hour AP index for current time.\n3 3 hour AP index for 3 hours before current time.\n4 3 hour AP index for 6 hours before current time.\n5 3 hour AP index for 9 hours before current time.\n6 Average of eight 3 hour AP indices from 12 to 33 hours prior to current time.\n7 Average of eight 3 hour AP indices from 36 to 57 hours prior to current time.","category":"page"},{"location":"man/earth/atmospheric_models/","page":"Earth atmospheric models","title":"Earth atmospheric models","text":"If the parameters related with the space indices are not provided (f107A, f107, and ap), then they will be automatically obtained. This, however, requires the initialization of the space indices (see [Space indices]).","category":"page"},{"location":"man/earth/atmospheric_models/","page":"Earth atmospheric models","title":"Earth atmospheric models","text":"The function return an object of type NRLMSISE00_Output that contains the following fields:","category":"page"},{"location":"man/earth/atmospheric_models/","page":"Earth atmospheric models","title":"Earth atmospheric models","text":"den_N: Nitrogen number density [U].\nden_N2: N₂ number density [U].\nden_O: Oxygen number density [U].\nden_aO: Anomalous Oxygen number density [U].\nden_O2: O₂ number density [U].\nden_H: Hydrogen number density [U].\nden_He: Helium number density [U].\nden_Ar: Argon number density [U].\nden_Total: Total mass density [T/U] (this value has different meanings for routines gtd7 and gtd7d).\nT_exo: Exospheric temperature [K].\nT_alt: Temperature at the selected altitude [K].\nflags: Flags used to compute NRLMSISE-00 model.","category":"page"},{"location":"man/earth/atmospheric_models/","page":"Earth atmospheric models","title":"Earth atmospheric models","text":"Notice that:","category":"page"},{"location":"man/earth/atmospheric_models/","page":"Earth atmospheric models","title":"Earth atmospheric models","text":"If flags[:output_m_kg] is false, then [U] is [cm⁻³] and [T] is [g/cm⁻³].\nIf flags[:output_m_kg] is true, then [U] is [m⁻³] and [T] is [kg/m⁻³].","category":"page"},{"location":"man/earth/atmospheric_models/","page":"Earth atmospheric models","title":"Earth atmospheric models","text":"julia> nrlmsise00(date_to_jd(2018, 6, 19, 18, 35, 0), 700e3, deg2rad(-22), deg2rad(-45), 73.5, 79, 5.13)\nNRLMSISE00_Output{Float64}\n  den_N: Float64 5.597834653523333e9\n  den_N2: Float64 5.743312510585916e7\n  den_O: Float64 1.2705655159941983e11\n  den_aO: Float64 2.4185558056141124e9\n  den_O2: Float64 340464.9752380828\n  den_H: Float64 1.2667781795293002e11\n  den_He: Float64 6.248499395447589e11\n  den_Ar: Float64 23.18462060029951\n  den_Total: Float64 7.930928885098513e-15\n  T_exo: Float64 837.4122645268103\n  T_alt: Float64 837.4119807046409\n  flags: NRLMSISE00_Flags","category":"page"},{"location":"man/earth/atmospheric_models/","page":"Earth atmospheric models","title":"Earth atmospheric models","text":"note: Note\nIf the user wants more control over the NRLMSISE-00, they can use the low-level functions gtd7 and gtd7d, which has the same functionality as available in the FORTRAN version of the model. See the documentation of the functions for more information.","category":"page"},{"location":"man/earth/atmospheric_models/#References","page":"Earth atmospheric models","title":"References","text":"","category":"section"},{"location":"man/earth/atmospheric_models/","page":"Earth atmospheric models","title":"Earth atmospheric models","text":"[1] Vallado, D. A., McClain, W. D (2013). Fundamentals of astrodynamics and applications. Hawthorne, CA: Microcosm Press.","category":"page"},{"location":"man/orbit/propagators/#Orbit-propagators","page":"Orbit propagators","title":"Orbit propagators","text":"","category":"section"},{"location":"man/orbit/propagators/","page":"Orbit propagators","title":"Orbit propagators","text":"CurrentModule = SatelliteToolbox\nDocTestSetup = quote\n    using SatelliteToolbox\nend","category":"page"},{"location":"man/orbit/propagators/","page":"Orbit propagators","title":"Orbit propagators","text":"Currently, there are four orbit propagators available: Two Body, J2, J4 and SGP4.  All coded in Julia (no external libraries required).","category":"page"},{"location":"man/orbit/propagators/#Two-Body","page":"Orbit propagators","title":"Two Body","text":"","category":"section"},{"location":"man/orbit/propagators/","page":"Orbit propagators","title":"Orbit propagators","text":"This algorithm assumes a Keplerian orbit, i.e. considers that the Earth is spherical with the gravitational force computed by Newton's laws.","category":"page"},{"location":"man/orbit/propagators/#J2","page":"Orbit propagators","title":"J2","text":"","category":"section"},{"location":"man/orbit/propagators/","page":"Orbit propagators","title":"Orbit propagators","text":"This algorithm considers the perturbation terms up to J2 and the drag effects. The implementation available here was adapted from [1].","category":"page"},{"location":"man/orbit/propagators/#J4","page":"Orbit propagators","title":"J4","text":"","category":"section"},{"location":"man/orbit/propagators/","page":"Orbit propagators","title":"Orbit propagators","text":"This algorithm considers the perturbation terms J2, J2², and J4 and the drag effects. The implementation available here was adapted from [1].","category":"page"},{"location":"man/orbit/propagators/#SGP4","page":"Orbit propagators","title":"SGP4","text":"","category":"section"},{"location":"man/orbit/propagators/","page":"Orbit propagators","title":"Orbit propagators","text":"The SGP4 algorithm here was based on [2,3]. It contains the deep space support that is automatically selected based on the input orbit. Hence, technically, it is the SPG4/SDP4 algorithm, which will be called just SGP4 here.","category":"page"},{"location":"man/orbit/propagators/#Initialization","page":"Orbit propagators","title":"Initialization","text":"","category":"section"},{"location":"man/orbit/propagators/","page":"Orbit propagators","title":"Orbit propagators","text":"All the propagators need to be initialized first using the API function init_orbit_propagator. The functions signature for each algorithm can be seen as follows.","category":"page"},{"location":"man/orbit/propagators/#Initialization-of-Two-body,-J2,-and-J4","page":"Orbit propagators","title":"Initialization of Two body, J2, and J4","text":"","category":"section"},{"location":"man/orbit/propagators/","page":"Orbit propagators","title":"Orbit propagators","text":"The orbit propagators two body, J2, and J4 can be initialized using three different methods.","category":"page"},{"location":"man/orbit/propagators/","page":"Orbit propagators","title":"Orbit propagators","text":"function init_orbit_propagator(T, epoch::Number, a_0::Number, e_0::Number, i_0::Number, Ω_0::Number, ω_0::Number, f_0::Number)","category":"page"},{"location":"man/orbit/propagators/","page":"Orbit propagators","title":"Orbit propagators","text":"where:","category":"page"},{"location":"man/orbit/propagators/","page":"Orbit propagators","title":"Orbit propagators","text":"T is the type of the orbit propagator (Val(:twobody) for Two Body, Val(:J2} for J2, and Val{:J4) for J4).\nepoch: Initial orbit epoch [Julian Day].\na_0: Initial semi-major axis [m].\ne_0: Initial eccentricity.\ni_0: Initial inclination [rad].\nΩ_0: Initial right ascension of the ascending node [rad].\nω_0: Initial argument of perigee [rad].\nf_0: Initial true anomaly [rad].","category":"page"},{"location":"man/orbit/propagators/","page":"Orbit propagators","title":"Orbit propagators","text":"note: Note\nThe inputs are the mean orbital elements.","category":"page"},{"location":"man/orbit/propagators/","page":"Orbit propagators","title":"Orbit propagators","text":"function init_orbit_propagator(T, orb_0::Orbit)","category":"page"},{"location":"man/orbit/propagators/","page":"Orbit propagators","title":"Orbit propagators","text":"where:","category":"page"},{"location":"man/orbit/propagators/","page":"Orbit propagators","title":"Orbit propagators","text":"T is the type of the orbit propagator (Val(:twobody) for Two Body, Val(:J2} for J2, and Val{:J4) for J4).\norb_0: Initial orbital elements (see Orbit).","category":"page"},{"location":"man/orbit/propagators/","page":"Orbit propagators","title":"Orbit propagators","text":"function init_orbit_propagator(T, tle::TLE)","category":"page"},{"location":"man/orbit/propagators/","page":"Orbit propagators","title":"Orbit propagators","text":"where:","category":"page"},{"location":"man/orbit/propagators/","page":"Orbit propagators","title":"Orbit propagators","text":"T is the type of the orbit propagator (Val(:twobody) for Two Body, Val(:J2} for J2, and Val{:J4) for J4).\ntle: TLE that will be used to initialize the propagator (see TLE).","category":"page"},{"location":"man/orbit/propagators/","page":"Orbit propagators","title":"Orbit propagators","text":"There are some optional parameters that depend on the orbit propagator type that can be used to customize the algorithm. Those options are listed as follows:","category":"page"},{"location":"man/orbit/propagators/","page":"Orbit propagators","title":"Orbit propagators","text":"Two Body","category":"page"},{"location":"man/orbit/propagators/","page":"Orbit propagators","title":"Orbit propagators","text":"μ: Standard gravitational parameter of the central body [m³/s²] (Default = m0).","category":"page"},{"location":"man/orbit/propagators/","page":"Orbit propagators","title":"Orbit propagators","text":"J2 Orbit Propagator","category":"page"},{"location":"man/orbit/propagators/","page":"Orbit propagators","title":"Orbit propagators","text":"dn_o2: First time derivative of mean motion divided by 2 [rad/s²] (Default = 0).\nddn_o6: Second time derivative of mean motion divided by 6 [rad/s³] (Default = 0).\nj2_gc: J2 orbit propagator gravitational constants (see J2_GravCte) (Default = j2_gc_egm08).","category":"page"},{"location":"man/orbit/propagators/","page":"Orbit propagators","title":"Orbit propagators","text":"warning: Warning\nThe two first options are not available when the TLE is used because this information is provided by the TLE.","category":"page"},{"location":"man/orbit/propagators/","page":"Orbit propagators","title":"Orbit propagators","text":"J4 Orbit Propagator","category":"page"},{"location":"man/orbit/propagators/","page":"Orbit propagators","title":"Orbit propagators","text":"dn_o2: First time derivative of mean motion divided by 2 [rad/s²] (Default = 0).\nddn_o6: Second time derivative of mean motion divided by 6 [rad/s³] (Default = 0).\nj4_gc: J4 orbit propagator gravitational constants (see J4_GravCte) (Default = j4_gc_egm08).","category":"page"},{"location":"man/orbit/propagators/","page":"Orbit propagators","title":"Orbit propagators","text":"warning: Warning\nThe two first options are not available when the TLE is used because this information is provided by the TLE.","category":"page"},{"location":"man/orbit/propagators/#Initialization-using-the-angular-velocity","page":"Orbit propagators","title":"Initialization using the angular velocity","text":"","category":"section"},{"location":"man/orbit/propagators/","page":"Orbit propagators","title":"Orbit propagators","text":"If the orbit is defined in terms of the angular velocity (mean motion) instead of the semi-major axis, then it is possible to use the function angvel_to_a to convert:","category":"page"},{"location":"man/orbit/propagators/","page":"Orbit propagators","title":"Orbit propagators","text":"function angvel_to_a(n::Number, e::Number, i::Number, pert::Symbol = :J2)","category":"page"},{"location":"man/orbit/propagators/","page":"Orbit propagators","title":"Orbit propagators","text":"It computes the semi-major axis that will provide an angular velocity n [rad/s] in an orbit with eccentricity e and inclination i [rad], using the perturbation terms specified by the symbol pert.","category":"page"},{"location":"man/orbit/propagators/","page":"Orbit propagators","title":"Orbit propagators","text":"Notice that the angular velocity n is related to the nodal period, i.e. the time between two consecutive passages by the ascending node.","category":"page"},{"location":"man/orbit/propagators/","page":"Orbit propagators","title":"Orbit propagators","text":"pert can be:","category":"page"},{"location":"man/orbit/propagators/","page":"Orbit propagators","title":"Orbit propagators","text":":J0: Consider a Keplerian orbit.\n:J2: Consider the perturbation terms up to J2.\n:J4: Consider the perturbation terms J2, J4, and J2².","category":"page"},{"location":"man/orbit/propagators/","page":"Orbit propagators","title":"Orbit propagators","text":"If pert is omitted, then it defaults to :J2.","category":"page"},{"location":"man/orbit/propagators/#Initialization-of-SGP4","page":"Orbit propagators","title":"Initialization of SGP4","text":"","category":"section"},{"location":"man/orbit/propagators/","page":"Orbit propagators","title":"Orbit propagators","text":"The SGP4/SDP4 propagator is meant to be used together with a TLE. Hence, the initialization using user-defined orbital elements is not available through the API. If this is really required, then the user must access the low-level function sgp4_init.","category":"page"},{"location":"man/orbit/propagators/","page":"Orbit propagators","title":"Orbit propagators","text":"The API function to initialize the SGP4 using a TLE is:","category":"page"},{"location":"man/orbit/propagators/","page":"Orbit propagators","title":"Orbit propagators","text":"function init_orbit_propagator(T, tle::TLE, sgp4_gc::SGP4_GravCte = sgp4_gc_wgs84)","category":"page"},{"location":"man/orbit/propagators/","page":"Orbit propagators","title":"Orbit propagators","text":"where:","category":"page"},{"location":"man/orbit/propagators/","page":"Orbit propagators","title":"Orbit propagators","text":"T must be Val(:sgp4);\ntle: TLE that will be used to initialize the propagator (see TLE).\nsgp4_gc: Gravitational constants (see SGP4_GravCte) (Default = sgp4_gc_wgs84).","category":"page"},{"location":"man/orbit/propagators/#Propagation","page":"Orbit propagators","title":"Propagation","text":"","category":"section"},{"location":"man/orbit/propagators/","page":"Orbit propagators","title":"Orbit propagators","text":"After the orbit propagator is initialized, the orbit can be propagated by the API functions propagate!, propagate_to_epoch!, and step!.","category":"page"},{"location":"man/orbit/propagators/","page":"Orbit propagators","title":"Orbit propagators","text":"The function propagate! has two signature. The first one is","category":"page"},{"location":"man/orbit/propagators/","page":"Orbit propagators","title":"Orbit propagators","text":"function propagate!(orbp, t::Number) where T","category":"page"},{"location":"man/orbit/propagators/","page":"Orbit propagators","title":"Orbit propagators","text":"in which the orbit will be propagated by t [s] from the orbit epoch, which is defined in the initialization and is never changed. This function returns a tuple with three values:","category":"page"},{"location":"man/orbit/propagators/","page":"Orbit propagators","title":"Orbit propagators","text":"The mean Keplerian elements represented in the inertial reference frame encapsulated in an instance of the structure Orbit [SI units].\nThe position vector represented in the inertial reference frame [m].\nThe velocity vector represented in the inertial reference frame [m].","category":"page"},{"location":"man/orbit/propagators/","page":"Orbit propagators","title":"Orbit propagators","text":"The second signature of propagate! is:","category":"page"},{"location":"man/orbit/propagators/","page":"Orbit propagators","title":"Orbit propagators","text":"function propagate!(orbp, t::AbstractVector) where T","category":"page"},{"location":"man/orbit/propagators/","page":"Orbit propagators","title":"Orbit propagators","text":"where the orbit will be propagated for every value in the vector t [s], which is a number of seconds from the orbit epoch. In this case, an array of tuples with be returned with each element equivalent to that described for the first case.","category":"page"},{"location":"man/orbit/propagators/","page":"Orbit propagators","title":"Orbit propagators","text":"The function propagate_to_epoch! also have two signatures similar to propagate!:","category":"page"},{"location":"man/orbit/propagators/","page":"Orbit propagators","title":"Orbit propagators","text":"function propagate_to_epoch!(orbp, JD::Number) where T\nfunction propagate_to_epoch!(orbp, JD::AbstractVector) where T","category":"page"},{"location":"man/orbit/propagators/","page":"Orbit propagators","title":"Orbit propagators","text":"It also returns the same information. However, the input argument JD is an epoch [Julian Day] to which the orbit will be propagated instead of the number of seconds from the orbit epoch.","category":"page"},{"location":"man/orbit/propagators/","page":"Orbit propagators","title":"Orbit propagators","text":"warning: Warning\nThe conversion from Julian Day to seconds that propagate_to_epoch! must perform can introduce numerical errors.","category":"page"},{"location":"man/orbit/propagators/","page":"Orbit propagators","title":"Orbit propagators","text":"The step! function has the following signature:","category":"page"},{"location":"man/orbit/propagators/","page":"Orbit propagators","title":"Orbit propagators","text":"function step!(orbp, Δt::Number)","category":"page"},{"location":"man/orbit/propagators/","page":"Orbit propagators","title":"Orbit propagators","text":"where the orbit is propagated by Δt [s] from the last propagation instant. This function returns the same information of the first signature of propagate! method.","category":"page"},{"location":"man/orbit/propagators/","page":"Orbit propagators","title":"Orbit propagators","text":"In all cases, the structure orbp is modified by updating the orbit elements related to the last propagation instant.","category":"page"},{"location":"man/orbit/propagators/","page":"Orbit propagators","title":"Orbit propagators","text":"note: Note\nAll the algorithms can be used to propagate the orbit forward or backward in time.","category":"page"},{"location":"man/orbit/propagators/#Reference-systems","page":"Orbit propagators","title":"Reference systems","text":"","category":"section"},{"location":"man/orbit/propagators/","page":"Orbit propagators","title":"Orbit propagators","text":"The inertial reference system in which the propagated values are represented depends on the reference system used to represent the input data. For TLE representation, it is very common to use the TEME (True Equator, Mean Equinox) frame. For more information, see [1].","category":"page"},{"location":"man/orbit/propagators/#Examples","page":"Orbit propagators","title":"Examples","text":"","category":"section"},{"location":"man/orbit/propagators/","page":"Orbit propagators","title":"Orbit propagators","text":"julia> orbp = init_orbit_propagator(Val(:twobody), 0.0, 7130982.0, 0.001111, 98.405*pi/180, pi/2, 0.0, 0.0);\n\njulia> r, v = propagate!(orbp, collect(0:3:24)*60*60);\n\njulia> r\n9-element Vector{StaticArrays.SVector{3, Float64}}:\n [5.303715994246266e-7, 7.123059478998e6, 3.5865499807263485e-6]\n [-987245.0339074, 2.279596565043737e6, -6.681575536568594e6]\n [-634570.3707618034, -5.665101888147292e6, -4.2947087297387365e6]\n [577611.4579814273, -5.943853474162778e6, 3.9092165113412146e6]\n [1.0074912863926954e6, 1.8203277350449404e6, 6.818600146130346e6]\n [70133.24345801045, 7.106899203983666e6, 474654.76927706896]\n [-962529.335994023, 2.728545148066921e6, -6.514302167875479e6]\n [-688667.0923408244, -5.360798284037417e6, -4.660829924676904e6]\n [518047.6023245827, -6.195799234254951e6, 3.506094300388868e6]","category":"page"},{"location":"man/orbit/propagators/","page":"Orbit propagators","title":"Orbit propagators","text":"julia> orbp = init_orbit_propagator(Val(:J2), KeplerianElements(0.0, 7130982.0, 0.001111, 98.405*pi/180, pi/2, 0.0, 0.0));\n\njulia> r, v = propagate!(orbp, collect(0:3:24)*60*60);\n\njulia> r\n9-element Vector{StaticArrays.SVector{3, Float64}}:\n [5.303715994246266e-7, 7.123059478998e6, 3.5865499807263485e-6]\n [-996350.5627457234, 2.1863731572358934e6, -6.711368000337593e6]\n [-587227.7524935548, -5.7823782285582125e6, -4.1425579248947604e6]\n [649426.5668227341, -5.775582427402986e6, 4.143016122164814e6]\n [972827.4418155277, 2.1969250985300676e6, 6.711636962150092e6]\n [-76509.36506314446, 7.122652836575141e6, 475.6194989516842]\n [-1.0197591007937173e6, 2.1755856272075106e6, -6.711096628510466e6]\n [-524958.6812806559, -5.788492655727532e6, -4.1421039186690417e6]\n [711547.4809893238, -5.76810618709308e6, 4.1434780500537464e6]","category":"page"},{"location":"man/orbit/propagators/","page":"Orbit propagators","title":"Orbit propagators","text":"julia> orbp = init_orbit_propagator(Val(:J2), KeplerianElements(date_to_jd(1986,6,19,0,0,0), 7130982.0, 0.001111, 98.405*pi/180, pi/2, 0.0, 0.0));\n\njulia> r, v = propagate_to_epoch!(orbp, date_to_jd(1986,6,19,0,0,0) .+ collect(0:3:24)/24);\n\njulia> r\n9-element Vector{StaticArrays.SVector{3, Float64}}:\n [5.303715994246266e-7, 7.123059478998e6, 3.5865499807263485e-6]\n [-996350.5627457234, 2.1863731572358934e6, -6.711368000337593e6]\n [-587227.7524935548, -5.7823782285582125e6, -4.1425579248947604e6]\n [649426.5668227341, -5.775582427402986e6, 4.143016122164814e6]\n [972827.4418155277, 2.1969250985300676e6, 6.711636962150092e6]\n [-76509.36506314446, 7.122652836575141e6, 475.6194989516842]\n [-1.0197591007937173e6, 2.1755856272075106e6, -6.711096628510466e6]\n [-524958.6812806559, -5.788492655727532e6, -4.1421039186690417e6]\n [711547.4809893238, -5.76810618709308e6, 4.1434780500537464e6]","category":"page"},{"location":"man/orbit/propagators/","page":"Orbit propagators","title":"Orbit propagators","text":"julia> orbp = init_orbit_propagator(Val(:J4), KeplerianElements(date_to_jd(1986,6,19,0,0,0), 7130982.0, 0.001111, 98.405*pi/180, pi/2, 0.0, 0.0));\n\njulia> r, v = propagate!(orbp, (0:3:24)*60*60);\n\njulia> r\n9-element Vector{StaticArrays.SVector{3, Float64}}:\n [5.303715994246266e-7, 7.123059478998e6, 3.5865499807263485e-6]\n [-996366.9594239298, 2.186158292807681e6, -6.711435734688962e6]\n [-587137.7897539997, -5.782642810012012e6, -4.1422016958516645e6]\n [649557.2207401077, -5.775184062789546e6, 4.1435504138820255e6]\n [972752.5982245656, 2.197783769856242e6, 6.711365970396049e6]\n [-76783.52150567244, 7.122649846215868e6, -625.3751192685057]\n [-1.0198435837402515e6, 2.1742954115535105e6, -6.7115029548768755e6]\n [-524633.8411768015, -5.789415102204635e6, -4.1408569964067223e6]\n [711884.4065749163, -5.76704002364843e6, 4.1449026893434837e6]","category":"page"},{"location":"man/orbit/propagators/","page":"Orbit propagators","title":"Orbit propagators","text":"julia> tle_scd1 = tle\"\"\"\n       SCD 1\n       1 22490U 93009B   18350.91204528  .00000219  00000-0  10201-4 0  9996\n       2 22490  24.9683 170.6788 0043029 357.3326 117.9323 14.44539175364603\n       \"\"\"[1];\n\njulia> orbp = init_orbit_propagator(Val(:sgp4), tle_scd1);\n\njulia> r, v = propagate!(orbp, (0:3:24)*60*60);\n\njulia> r\n9-element Vector{StaticArrays.SVector{3, Float64}}:\n [2.1104012562923166e6, -6.248944717841756e6, 2.7103754647550117e6]\n [-5.592457608056556e6, -3.7813257981715053e6, 2.1882968787571643e6]\n [-5.988375857808983e6, 3.627483705445919e6, -1.1327315536731675e6]\n [1.4405613907279489e6, 6.296033411211332e6, -3.0047273909310466e6]\n [7.026149940376372e6, 791501.9859623271, -1.061727896730936e6]\n [3.6069983933267347e6, -5.743279083559109e6, 2.21988653760847e6]\n [-4.430433261051035e6, -4.853641397034226e6, 2.6886290511943335e6]\n [-6.675541341088373e6, 2.372196988700215e6, -279066.08984961873]\n [-193293.3502548483, 6.501272877734009e6, -2.8915511460724827e6]\n\njulia> v\n9-element Vector{StaticArrays.SVector{3, Float64}}:\n [7129.19085352138, 1784.0696855845256, -1358.3238197147184]\n [4573.3147340566975, -5547.0437916909905, 2171.2458526391238]\n [-3969.352987692075, -5663.638822765204, 2940.09359907522]\n [-7305.141378585876, 1611.5624355458967, -49.362957814204904]\n [-1211.7826922676047, 6739.965820219686, -2945.926548674715]\n [6417.953384292589, 3175.7563180703937, -2122.04199768743]\n [5799.58683945934, -4551.6320882861355, 1407.446888081471]\n [-2391.636997068708, -6387.691108730701, 3161.6577154337137]\n [-7435.439550407853, 128.80933740830324, 866.5999572489661]\n\njulia> orbp = init_orbit_propagator(Val(:sgp4), tle_scd1);\n\njulia> r, v = step!(orbp, 3*60*60);\n\njulia> r, v = step!(orbp, 3*60*60);\n\njulia> r, v = step!(orbp, 3*60*60);\n\njulia> r, v = step!(orbp, 3*60*60);\n\njulia> r, v = step!(orbp, 3*60*60);\n\njulia> r, v = step!(orbp, 3*60*60);\n\njulia> r, v = step!(orbp, 3*60*60);\n\njulia> r, v = step!(orbp, 3*60*60);\n\njulia> r\n3-element StaticArrays.SVector{3, Float64} with indices SOneTo(3):\n -193293.3502548483\n       6.501272877734009e6\n      -2.8915511460724827e6\n\njulia> v\n3-element StaticArrays.SVector{3, Float64} with indices SOneTo(3):\n -7435.439550407853\n   128.80933740830324\n   866.5999572489661","category":"page"},{"location":"man/orbit/propagators/#Low-level-access","page":"Orbit propagators","title":"Low level access","text":"","category":"section"},{"location":"man/orbit/propagators/","page":"Orbit propagators","title":"Orbit propagators","text":"All propagators can be accessed by low-level functions. This allows the user to have more control about the algorithm and also to reduce the overhead related to the API functions. If such optimization is necessary, see the functions inside the directory ./src/orbit/propagators.","category":"page"},{"location":"man/orbit/propagators/#References","page":"Orbit propagators","title":"References","text":"","category":"section"},{"location":"man/orbit/propagators/","page":"Orbit propagators","title":"Orbit propagators","text":"[1] Vallado, D. A., McClain, W. D (2013). Fundamentals of astrodynamics and applications. Hawthorne, CA: Microcosm Press.","category":"page"},{"location":"man/orbit/propagators/","page":"Orbit propagators","title":"Orbit propagators","text":"[2] Hoots, F. R., Roehrich, R. L (1980). Models for Propagation of NORAD Elements Set. Spacetrack Report No. 3.","category":"page"},{"location":"man/orbit/propagators/","page":"Orbit propagators","title":"Orbit propagators","text":"[3] Vallado, D. A., Crawford, P., Hujsak, R., Kelso, T. S (2006). Revisiting Spacetrack Report #3: Rev1. AIAA.","category":"page"},{"location":"man/orbit/tle/#TLE","page":"TLE","title":"TLE","text":"","category":"section"},{"location":"man/orbit/tle/","page":"TLE","title":"TLE","text":"CurrentModule = SatelliteToolbox\nDocTestSetup = quote\n    using SatelliteToolbox\nend","category":"page"},{"location":"man/orbit/tle/","page":"TLE","title":"TLE","text":"The TLE, or Two Line Elements set, is a data format that contains information about the orbit at a specific epoch of an Earth-orbiting object. The information is split into two lines with 70 characters each. In the following, it is presented an example of a TLE describing the orbit of the Brazilian satellite SCD-1 at 25 December 2018:","category":"page"},{"location":"man/orbit/tle/","page":"TLE","title":"TLE","text":"SCD 1                   \n1 22490U 93009B   18359.76217587  .00000186  00000-0  84512-6 0  9998\n2 22490  24.9694 116.1709 0043211  90.3968  62.0083 14.44539396366163","category":"page"},{"location":"man/orbit/tle/","page":"TLE","title":"TLE","text":"For more information, see https://en.wikipedia.org/wiki/Two-line_element_set.","category":"page"},{"location":"man/orbit/tle/","page":"TLE","title":"TLE","text":"The TLE contains all the necessary information to propagate the orbit using, for example, the SGP4 orbit propagator. Hence, this package contains a set of functions that helps to load the TLE information to be used in the Orbit propagators.","category":"page"},{"location":"man/orbit/tle/","page":"TLE","title":"TLE","text":"If the TLEs are stored in one file, then they can be loaded using the function:","category":"page"},{"location":"man/orbit/tle/","page":"TLE","title":"TLE","text":"function read_tle(tle_filename::String, verify_checksum::Bool = true)","category":"page"},{"location":"man/orbit/tle/","page":"TLE","title":"TLE","text":"where the tle_filename is the file path. Each TLE line has a checksum to verify the correctness of the data. By default, if the checksum is wrong, then this function will throw an error. The checksum verification can be avoided by setting verify_checksum to false.","category":"page"},{"location":"man/orbit/tle/","page":"TLE","title":"TLE","text":"This function returns an array of TLEs. Each TLE is an instance of the structure TLE.","category":"page"},{"location":"man/orbit/tle/","page":"TLE","title":"TLE","text":"julia> tles = read_tle(\"tles\")\n2-element Vector{TLE}:\n TLE: SCD 1 (Epoch = 2018-12-25T18:17:31.995)\n TLE: SCD 2 (Epoch = 2018-12-26T05:50:03.289)\n\njulia> tles[1]\nTLE:\n                     Name : SCD 1\n         Satellite number : 22490\n International designator : 93009B\n       Epoch (Year / Day) : 18 / 359.76217587\n       Epoch (Julian Day) : 2458478.26218 (2018-12-25T18:17:31.995)\n       Element set number : 999\n             Eccentricity :   0.00432110 deg\n              Inclination :  24.96940000 deg\n                     RAAN : 116.17090000 deg\n      Argument of perigee :  90.39680000 deg\n             Mean anomaly :  62.00830000 deg\n          Mean motion (n) :  14.44539396 revs/day\n        Revolution number : 36616\n                       B* : 0.000001 1/[er]\n                    ṅ / 2 : 0.000002 rev/day²\n                    n̈ / 6 : 0.000000 rev/day³\n\njulia> tles[2]\nTLE:\n                     Name : SCD 2\n         Satellite number : 25504\n International designator : 98060A\n       Epoch (Year / Day) : 18 / 360.24309362\n       Epoch (Julian Day) : 2458478.74309 (2018-12-26T05:50:03.289)\n       Element set number : 999\n             Eccentricity :   0.00174310 deg\n              Inclination :  24.99670000 deg\n                     RAAN : 319.86640000 deg\n      Argument of perigee : 121.38100000 deg\n             Mean anomaly :   9.79390000 deg\n          Mean motion (n) :  14.44057429 revs/day\n        Revolution number : 6554\n                       B* : 0.000011 1/[er]\n                    ṅ / 2 : 0.000002 rev/day²\n                    n̈ / 6 : 0.000000 rev/day³","category":"page"},{"location":"man/orbit/tle/","page":"TLE","title":"TLE","text":"If the TLE is stored in a string, then it can be read using the following functions:","category":"page"},{"location":"man/orbit/tle/","page":"TLE","title":"TLE","text":"function read_tle_from_string(tles::String, verify_checksum::Bool = true)\nfunction read_tle_from_string(tle_l1::String, tle_l2::String, verify_checksum::Bool = false)","category":"page"},{"location":"man/orbit/tle/","page":"TLE","title":"TLE","text":"In the first case, a list of TLEs can be passed in tles. In the second case, the first line and second line of a TLE can be passed in tle_l1 and tle_l2, respectively. In both cases an array of TLEs is returned.  The argument verify_checksum has the same function as described previously.","category":"page"},{"location":"man/orbit/tle/","page":"TLE","title":"TLE","text":"julia> tles = \"\"\"\n       SCD 1\n       1 22490U 93009B   18359.76217587  .00000186  00000-0  84512-6 0  9998\n       2 22490  24.9694 116.1709 0043211  90.3968  62.0083 14.44539396366163\n       SCD 2\n       1 25504U 98060A   18360.24309362  .00000218  00000-0  10518-4 0  9996\n       2 25504  24.9967 319.8664 0017431 121.3810   9.7939 14.44057429 65541\n       \"\"\";\n\njulia> read_tle_from_string(tles)\n2-element Vector{TLE}:\n TLE: SCD 1 (Epoch = 2018-12-25T18:17:31.995)\n TLE: SCD 2 (Epoch = 2018-12-26T05:50:03.289)\n\njulia> tle_l1 = \"1 22490U 93009B   18359.76217587  .00000186  00000-0  84512-6 0  9998\"\n\"1 22490U 93009B   18359.76217587  .00000186  00000-0  84512-6 0  9998\"\n\njulia> tle_l2 = \"2 22490  24.9694 116.1709 0043211  90.3968  62.0083 14.44539396366163\"\n\"2 22490  24.9694 116.1709 0043211  90.3968  62.0083 14.44539396366163\"\n\njulia> read_tle_from_string(tle_l1, tle_l2)\n1-element Vector{TLE}:\n TLE: UNDEFINED (Epoch = 2018-12-25T18:17:31.995)","category":"page"},{"location":"man/orbit/tle/","page":"TLE","title":"TLE","text":"It is also available two special types of strings, tle\" and tlenc\", that automatically loads a set of TLEs. In the first case the checksum is verified whereas in the second case it is not.","category":"page"},{"location":"man/orbit/tle/","page":"TLE","title":"TLE","text":"julia> tles = tle\"\"\"\n       SCD 1\n       1 22490U 93009B   18359.76217587  .00000186  00000-0  84512-6 0  9998\n       2 22490  24.9694 116.1709 0043211  90.3968  62.0083 14.44539396366163\n       SCD 2\n       1 25504U 98060A   18360.24309362  .00000218  00000-0  10518-4 0  9996\n       2 25504  24.9967 319.8664 0017431 121.3810   9.7939 14.44057429 65541\n       \"\"\"\n2-element Vector{TLE}:\n TLE: SCD 1 (Epoch = 2018-12-25T18:17:31.995)\n TLE: SCD 2 (Epoch = 2018-12-26T05:50:03.289)\n\njulia> tles = tle\"\"\"\n       SCD 1\n       1 22490U 93009B   18359.76217587  .00000186  00000-0  84512-6 0  9998\n       2 22490  24.9694 116.1709 0043211  90.3968  62.0083 14.44539396366164\n       \"\"\"\nERROR: LoadError: The TLE file is not valid (error in line 3): Expected checksum: 3, line checksum: 4.\n...\n\njulia> tles = tlenc\"\"\"\n       SCD 1\n       1 22490U 93009B   18359.76217587  .00000186  00000-0  84512-6 0  9998\n       2 22490  24.9694 116.1709 0043211  90.3968  62.0083 14.44539396366164\n       \"\"\"\n1-element Array{TLE,1}:\n TLE: SCD 1 (Epoch = 2018-12-25T18:17:31.995)","category":"page"},{"location":"lib/library/#Library","page":"Library","title":"Library","text":"","category":"section"},{"location":"lib/library/","page":"Library","title":"Library","text":"Documentation for SatelliteToolbox.jl.","category":"page"},{"location":"lib/library/","page":"Library","title":"Library","text":"Modules = [SatelliteToolbox,\n           SatelliteToolbox.SGP4,\n           SatelliteToolbox.SatelliteToolboxTLE]","category":"page"},{"location":"lib/library/#SatelliteToolbox.T_ECEFs","page":"Library","title":"SatelliteToolbox.T_ECEFs","text":"T_ECEFs\n\nUnion of all Earth-Centered Earth-Fixed (ECEF) frames supported by the IAU-76/FK5 theory.\n\n\n\n\n\n","category":"type"},{"location":"lib/library/#SatelliteToolbox.T_ECEFs_IAU_2006","page":"Library","title":"SatelliteToolbox.T_ECEFs_IAU_2006","text":"T_ECEFs_IAU_2006\n\nUnion of all Earth-Centered Earth-Fixed (ECEF) frames supported by IAU-2006/2010 theory.\n\n\n\n\n\n","category":"type"},{"location":"lib/library/#SatelliteToolbox.T_ECIs","page":"Library","title":"SatelliteToolbox.T_ECIs","text":"T_ECIs\n\nUnion of all Earth-Centered Inertial (ECI) frames supported by the IAU-76/FK5 theory.\n\n\n\n\n\n","category":"type"},{"location":"lib/library/#SatelliteToolbox.T_ECIs_IAU_2006","page":"Library","title":"SatelliteToolbox.T_ECIs_IAU_2006","text":"T_ECIs_IAU_2006\n\nUnion of all Earth-Centered Inertial (ECI) frames supported by IAU-2006/2010 theory.\n\n\n\n\n\n","category":"type"},{"location":"lib/library/#SatelliteToolbox.T_ECIs_IAU_2006_CIO","page":"Library","title":"SatelliteToolbox.T_ECIs_IAU_2006_CIO","text":"T_ECIs_IAU_2006_CIO\n\nUnion of all Earth-Centered Inertial (ECI) frames supported by CIO-based IAU-2006/2010 theory.\n\n\n\n\n\n","category":"type"},{"location":"lib/library/#SatelliteToolbox.T_ECIs_IAU_2006_Equinox","page":"Library","title":"SatelliteToolbox.T_ECIs_IAU_2006_Equinox","text":"T_ECIs_IAU_2006_Equinox\n\nUnion of all Earth-Centered Inertial (ECI) frames supported by Equinox-based IAU-2006/2010 theory.\n\n\n\n\n\n","category":"type"},{"location":"lib/library/#SatelliteToolbox.T_ECIs_IAU_2006_Equinox_of_date","page":"Library","title":"SatelliteToolbox.T_ECIs_IAU_2006_Equinox_of_date","text":"T_ECIs_IAU_2006_Equinox_of_date\n\nUnion of all of date Earth-Centered Inertial (ECI) frames supported by the equinox-based IAU-2006/2010 theory.\n\n\n\n\n\n","category":"type"},{"location":"lib/library/#SatelliteToolbox.T_ECIs_of_date","page":"Library","title":"SatelliteToolbox.T_ECIs_of_date","text":"T_ECIs_of_date\n\nUnion of all of date Earth-Centered Inertial (ECI) frames supported by the IAU-76/FK5 theory.\n\n\n\n\n\n","category":"type"},{"location":"lib/library/#SatelliteToolbox.T_ROT","page":"Library","title":"SatelliteToolbox.T_ROT","text":"T_ROT\n\nUnion of all supported rotation descriptions.\n\n\n\n\n\n","category":"type"},{"location":"lib/library/#SatelliteToolbox._expatmosphere_H","page":"Library","title":"SatelliteToolbox._expatmosphere_H","text":"_expatmosphere_H\n\nScale height for the exponential atmospheric model [km].\n\n\n\n\n\n","category":"constant"},{"location":"lib/library/#SatelliteToolbox._expatmosphere_h₀","page":"Library","title":"SatelliteToolbox._expatmosphere_h₀","text":"_expatmosphere_h₀\n\nBase altitude for the exponential atmospheric model [km].\n\n\n\n\n\n","category":"constant"},{"location":"lib/library/#SatelliteToolbox._expatmosphere_ρ₀","page":"Library","title":"SatelliteToolbox._expatmosphere_ρ₀","text":"_expatmosphere_ρ₀\n\nNominal density for the exponential atmospheric model [kg/m³].\n\n\n\n\n\n","category":"constant"},{"location":"lib/library/#SatelliteToolbox._jr1971_constants","page":"Library","title":"SatelliteToolbox._jr1971_constants","text":"_jr1971_constants\n\nConstants for the Jacchia-Roberts 1971 Atmospheric Model.\n\n\n\n\n\n","category":"constant"},{"location":"lib/library/#SatelliteToolbox._jr1971_id","page":"Library","title":"SatelliteToolbox._jr1971_id","text":"_jr1971_id\n\nIndex of the species for the Jacchia-Roberts 1971 Atmospheric Model.\n\n\n\n\n\n","category":"constant"},{"location":"lib/library/#SatelliteToolbox.EOPData_IAU1980","page":"Library","title":"SatelliteToolbox.EOPData_IAU1980","text":"EOPData_IAU1980{T}\n\nEOP Data for IAU 1980.\n\nFields\n\nx, y: Polar motion with respect to the crust [arcsec].\nUT1_UTC: Irregularities of the rotation angle [s].\nLOD: Length of day offset [s].\ndPsi, dEps: Celestial pole offsets referred to the model IAU1980 [arcsec].\n*_err: Errors in the components [same unit as the component].\n\nRemarks\n\nEach field will be an AbstractInterpolation indexed by the Julian Day. Hence, if one want to obtain, for example, the X component of the polar motion with respect to the crust at 19 June 2018, the following can be used:\n\nx[DatestoJD(2018,19,06,0,0,0)]\n\n\n\n\n\n","category":"type"},{"location":"lib/library/#SatelliteToolbox.EOPData_IAU2000A","page":"Library","title":"SatelliteToolbox.EOPData_IAU2000A","text":"EOPData_IAU2000A{T}\n\nEOP Data for IAU 2000A.\n\nFields\n\nx, y: Polar motion with respect to the crust [arcsec].\nUT1_UTC: Irregularities of the rotation angle [s].\nLOD: Length of day offset [s].\ndX, dY: Celestial pole offsets referred to the model IAU2000A [arcsec].\n*_err: Errors in the components [same unit as the component].\n\nRemarks\n\nEach field will be an AbstractInterpolation indexed by the Julian Day. Hence, if one want to obtain, for example, the X component of the polar motion with respect to the crust at 19 June 2018, the following can be used:\n\nx[DatestoJD(2018,19,06,0,0,0)]\n\n\n\n\n\n","category":"type"},{"location":"lib/library/#SatelliteToolbox.GravityModel_Coefs","page":"Library","title":"SatelliteToolbox.GravityModel_Coefs","text":"GravityModel_Coefs{T}\n\nStructure to store the information about a gravity model.\n\n\n\n\n\n","category":"type"},{"location":"lib/library/#SatelliteToolbox.ICGEM","page":"Library","title":"SatelliteToolbox.ICGEM","text":"ICGEM\n\nStructure to store the information contained in ICGEM files.\n\n\n\n\n\n","category":"type"},{"location":"lib/library/#SatelliteToolbox.J2_GravCte","page":"Library","title":"SatelliteToolbox.J2_GravCte","text":"J2_GravCte{T}\n\nGravitational constants for J2 orbit propagator.\n\nFields\n\nR0: Earth equatorial radius [m].\nμm: √GM [er/s]^(3/2).\nJ2: The second gravitational zonal harmonic of the Earth.\n\n\n\n\n\n","category":"type"},{"location":"lib/library/#SatelliteToolbox.J2_Structure","page":"Library","title":"SatelliteToolbox.J2_Structure","text":"J2_Structure{T}\n\nLow level J2 orbit propagator structure.\n\n\n\n\n\n","category":"type"},{"location":"lib/library/#SatelliteToolbox.J2osc_Structure","page":"Library","title":"SatelliteToolbox.J2osc_Structure","text":"J2osc_Structure{T}\n\nLow level J2 osculating orbit propagator structure.\n\n\n\n\n\n","category":"type"},{"location":"lib/library/#SatelliteToolbox.J4_GravCte","page":"Library","title":"SatelliteToolbox.J4_GravCte","text":"J4_GravCte{T}\n\nGravitational constants for J4 orbit propagator.\n\nFields\n\nR0: Earth equatorial radius [m].\nμm: √GM [er/s]^(3/2).\nJ2: The second gravitational zonal harmonic of the Earth.\nJ4: The fourth gravitational zonal harmonic of the Earth.\n\n\n\n\n\n","category":"type"},{"location":"lib/library/#SatelliteToolbox.J4_Structure","page":"Library","title":"SatelliteToolbox.J4_Structure","text":"J4_Structure{T}\n\nLow level J4 orbit propagator structure.\n\n\n\n\n\n","category":"type"},{"location":"lib/library/#SatelliteToolbox.JB2008_Output","page":"Library","title":"SatelliteToolbox.JB2008_Output","text":"JB2008_Output\n\nOutput structure of the Jacchia-Bowman 2008.\n\nFields\n\nnN2: Number density of N₂ [1/m³].\nnO2: Number density of O₂ [1/m³].\nnO: Number density of O [1/m³].\nnAr: Number density of Ar [1/m³].\nnHe: Number density of He [1/m³].\nnH: Number density of H [1/m³].\nrho: Total density [kg/m³].\nT_exo: Exospheric temperature [K].\nTz: Temperature at the selected altitude [K].\n\n\n\n\n\n","category":"type"},{"location":"lib/library/#SatelliteToolbox.JR1971_CONSTANTS","page":"Library","title":"SatelliteToolbox.JR1971_CONSTANTS","text":"JR1971_CONSTANTS{T}\n\nStructure with the constants for the Jacchia-Roberts 1971 Atmospheric Model.\n\n\n\n\n\n","category":"type"},{"location":"lib/library/#SatelliteToolbox.JR1971_Output","page":"Library","title":"SatelliteToolbox.JR1971_Output","text":"JR1971_Output\n\nOutput structure of the Jacchia-Roberts 1971 model.\n\nFields\n\nnN2: Number density of N₂ [1/m³].\nnO2: Number density of O₂ [1/m³].\nnO: Number density of O [1/m³].\nnAr: Number density of Ar [1/m³].\nnHe: Number density of He [1/m³].\nnH: Number density of H [1/m³].\nrho: Total density [kg/m³].\nT_exo: Exospheric temperature [K].\nTz: Temperature at the selected altitude [K].\n\n\n\n\n\n","category":"type"},{"location":"lib/library/#SatelliteToolbox.KeplerianElements","page":"Library","title":"SatelliteToolbox.KeplerianElements","text":"KeplerianElements{T1,T2}\n\nThis structure defines the orbit in terms of the Keplerian elements.\n\nFields\n\nt: Epoch.\na: Semi-major axis [m].\ne: Eccentricity [ ].\ni: Inclination [rad].\nΩ: Right ascension of the ascending node [rad].\nω: Argument of perigee [rad].\nf: True anomaly [rad].\n\n\n\n\n\n","category":"type"},{"location":"lib/library/#SatelliteToolbox.NRLMSISE00_Flags","page":"Library","title":"SatelliteToolbox.NRLMSISE00_Flags","text":"NRLMSISE00_Flags\n\nFlags to configure NRLMSISE-00.\n\nFields\n\noutput_m_kg\nF107_Mean\ntime_independent\nsym_annual\nsym_semiannual\nasym_annual\nasyn_semiannual\ndiurnal\nsemidiurnal\ndaily_ap\nall_ut_long_effects\nlongitudinal\nut_mixed_ut_long\nmixed_ap_ut_long\nterdiurnal\ndepartures_from_eq\nall_tinf_var\nall_tlb_var\nall_tn1_var\nall_s_var\nall_tn2_var\nall_nlb_var\nall_tn3_var\nturbo_scale_height\nuse_ap_array\n\n\n\n\n\n","category":"type"},{"location":"lib/library/#SatelliteToolbox.NRLMSISE00_Output","page":"Library","title":"SatelliteToolbox.NRLMSISE00_Output","text":"NRLMSISE00_Output\n\nOutput structure for NRLMSISE00 model.\n\nFields\n\nden_N: Nitrogen number density [U].\nden_N2: N₂ number density [U].\nden_O: Oxygen number density [U].\nden_aO: Anomalous Oxygen number density [U].\nden_O2: O₂ number density [U].\nden_H: Hydrogen number density [U].\nden_He: Helium number density [U].\nden_Ar: Argon number density [U].\nden_Total: Total mass density [T/U] (this value has different meanings for              routines gtd7 and gtd7d).\nT_exo: Exospheric temperature [K].\nT_alt: Temperature at the selected altitude [K].\nflags: Flags used to compute NRLMSISE-00 model.\n\nNotice that:\n\nIf flags.output_m_kg is false, then [U] is [cm⁻³] and [T] is [g/cm⁻³].\nIf flags.output_m_kg is true, then [U] is [m⁻³] and [T] is [kg/m⁻³].\n\nRemarks\n\nAnomalous oxygen is defined as hot atomic oxygen or ionized oxygen that can become appreciable at high altitudes (> 500 km) for some ranges of inputs, thereby affection drag on satellites and debris. We group these species under the term Anomalous Oxygen, since their individual variations are not presently separable with the drag data used to define this model component.\n\n\n\n\n\n","category":"type"},{"location":"lib/library/#SatelliteToolbox.NRLMSISE00_Structure","page":"Library","title":"SatelliteToolbox.NRLMSISE00_Structure","text":"NRLMSISE00_Structure{T}\n\nStructure with the configuration parameters for NRLMSISE-00 model. It can be created using the function conf_nrlmsise00.\n\n\n\n\n\n","category":"type"},{"location":"lib/library/#SatelliteToolbox.Orbit","page":"Library","title":"SatelliteToolbox.Orbit","text":"Orbit\n\nAbstract type of an orbit representation.\n\n\n\n\n\n","category":"type"},{"location":"lib/library/#SatelliteToolbox.OrbitPropagator","page":"Library","title":"SatelliteToolbox.OrbitPropagator","text":"OrbitPropagator{T}\n\nAbstract type of the orbit propagator. Every propagator structure must be a subtype of this type and must implement the following API functions:\n\npropagate!(orbp, t::Number)\npropagate!(orbp, t::AbstractVector)\npropagate_to_epoch!(orbp, JD::Number)\npropagate_to_epoch!(orbp, JD::AbstractVector)\nstep!(orbp, Δt::Number)\n\n\n\n\n\n","category":"type"},{"location":"lib/library/#SatelliteToolbox.OrbitPropagatorJ2","page":"Library","title":"SatelliteToolbox.OrbitPropagatorJ2","text":"OrbitPropagatorJ2{T} <: OrbitPropagator{T}\n\nStructure that holds the information related to the J2 orbit propagator.\n\nFields\n\nj2d: Structure that stores the J2 orbit propagator data (see        J2_Structure).\n\n\n\n\n\n","category":"type"},{"location":"lib/library/#SatelliteToolbox.OrbitPropagatorJ2osc","page":"Library","title":"SatelliteToolbox.OrbitPropagatorJ2osc","text":"OrbitPropagatorJ2osc{T} <: OrbitPropagator{T}\n\nStructure that holds the information related to the J2 osculating orbit propagator.\n\nFields\n\nj2oscd: Structure that stores the J2 osculating orbit propagator data (see           J2osc_Structure).\n\n\n\n\n\n","category":"type"},{"location":"lib/library/#SatelliteToolbox.OrbitPropagatorJ4","page":"Library","title":"SatelliteToolbox.OrbitPropagatorJ4","text":"OrbitPropagatorJ4{T} <: OrbitPropagator{T}\n\nStructure that holds the information related to the J4 orbit propagator.\n\nFields\n\nj4d: Structure that stores the J4 orbit propagator data (see        J4_Structure).\n\n\n\n\n\n","category":"type"},{"location":"lib/library/#SatelliteToolbox.OrbitPropagatorSGP4","page":"Library","title":"SatelliteToolbox.OrbitPropagatorSGP4","text":"OrbitPropagatorSGP4{T} <: OrbitPropagator{T}\n\nStructure that holds the information related to the SGP4 propagator.\n\nFields\n\nsgp4d: Structure that stores the SGP4 data (see SGP4_Structure).\n\n\n\n\n\n","category":"type"},{"location":"lib/library/#SatelliteToolbox.OrbitPropagatorTwoBody","page":"Library","title":"SatelliteToolbox.OrbitPropagatorTwoBody","text":"OrbitPropagatorTwoBody{T} <: OrbitPropagator{T}\n\nStructure that holds the information related to the Two Body orbit propagator.\n\nFields\n\norb: Mean orbital elements (see Orbit).\ntbd: Structure that stores the Two Body orbit propagator data (see       TwoBody_Structure).\n\n\n\n\n\n","category":"type"},{"location":"lib/library/#SatelliteToolbox.OrbitStateVector","page":"Library","title":"SatelliteToolbox.OrbitStateVector","text":"OrbitStateVector{T}\n\nStore the state vector representation of an orbit.\n\nFields\n\nt: Epoch [Julian Day].\nr: Position vector [m].\nv: Velocity vector [m/s].\na: Acceleration vector [m/s²].\n\n\n\n\n\n","category":"type"},{"location":"lib/library/#SatelliteToolbox.TwoBody_Structure","page":"Library","title":"SatelliteToolbox.TwoBody_Structure","text":"TwoBody_Structure{T}\n\nLow level Two Body orbit propagator structure.\n\n\n\n\n\n","category":"type"},{"location":"lib/library/#SatelliteToolbox._DTCFILE_Structure","page":"Library","title":"SatelliteToolbox._DTCFILE_Structure","text":"_DTCFILE_Structure\n\nStructure to store the interpolations of the data in DTCFILE.TXT file.\n\nFields\n\nDstΔTc: Temperature variation due to Dst [K].\n\n\n\n\n\n","category":"type"},{"location":"lib/library/#SatelliteToolbox._SOLFSMY_Structure","page":"Library","title":"SatelliteToolbox._SOLFSMY_Structure","text":"_SOLFSMY_Structure\n\nStructure to store the interpolations of the data in SOLFSMY.TXT file.\n\nFields\n\nF10: 10.7-cm solar flux [10⁻²² W/(m² Hz)].\nF81a: 10.7-cm averaged solar flux, 81-day centered on input time.\nS10: EUV index.\nS81a: EUV 81-day averaged centered index.\nM10: MG2 index scaled to F10.\nM81a: MG2 81-day averaged centered index.\nY81a: Solar X-ray & Lya 81-day averaged centered index.\nY81a: Solar X-ray & Lya 81-day averaged centered index.\n\n\n\n\n\n","category":"type"},{"location":"lib/library/#SatelliteToolbox._WDC_Structure","page":"Library","title":"SatelliteToolbox._WDC_Structure","text":"_WDC_Structure\n\nStructure to store the interpolations of the data in WDC files.\n\nFields\n\nKp: Kp index.\nAp: Ap index.\n\n\n\n\n\n","category":"type"},{"location":"lib/library/#SatelliteToolbox.E_to_M-Tuple{Number, Number}","page":"Library","title":"SatelliteToolbox.E_to_M","text":"E_to_M(e::Number, E::Number)\n\nCompute the mean anomaly (0,2π) [rad] given the eccentricity e and the eccentric anomaly E [rad].\n\n\n\n\n\n","category":"method"},{"location":"lib/library/#SatelliteToolbox.E_to_f-Tuple{Number, Number}","page":"Library","title":"SatelliteToolbox.E_to_f","text":"E_to_f(e::Number, E::Number)\n\nCompute the true anomaly (0,2π) [rad] given the eccentricity e and the eccentric anomaly E [rad].\n\n\n\n\n\n","category":"method"},{"location":"lib/library/#SatelliteToolbox.M_to_E","page":"Library","title":"SatelliteToolbox.M_to_E","text":"M_to_E(e::Number, M::Number, tol::Number = 1e-10)\n\nCompute the eccentric anomaly (0,2π) [rad] given the eccentricity e and the mean anomaly M [rad]. This function uses the Newton-Raphson algorithm and the tolerance to accept the solution is tol.\n\n\n\n\n\n","category":"function"},{"location":"lib/library/#SatelliteToolbox.M_to_f","page":"Library","title":"SatelliteToolbox.M_to_f","text":"M_to_f(e::Number, M::Number, tol::Number = 1e-10)\n\nCompute the true anomaly (0,2π) [rad] given the eccentricity e and the mean anomaly M [rad]. This function uses the Newton-Raphson algorithm and the tolerance to accept the solution is tol.\n\n\n\n\n\n","category":"function"},{"location":"lib/library/#SatelliteToolbox._ccor-Union{Tuple{T}, NTuple{4, T}} where T<:Number","page":"Library","title":"SatelliteToolbox._ccor","text":"_ccor(alt::T, r::T, h1::T, zh::T) where T<:Number\n\nChemistry / Dissociation correction for MSIS models.\n\nArgs\n\nalt: Altitude.\nr: Target ratio.\nh1: Transition scale length.\nzh: Altitude of 1/2 r.\n\nReturns\n\nThe chemistry / dissociation correction.\n\n\n\n\n\n","category":"method"},{"location":"lib/library/#SatelliteToolbox._ccor2-Union{Tuple{T}, NTuple{5, T}} where T<:Number","page":"Library","title":"SatelliteToolbox._ccor2","text":"_ccor2(alt::T, r::T, h1::T, zh::T, h2::T) where T<:Number\n\nChemistry / Dissociation correction for MSIS models.\n\nArgs\n\nalt: Altitude.\nr: Target ration.\nh1: Transition scale length.\nzh: Altitude of 1/2 r.\nh2: Transition scale length 2.\n\nReturns\n\nThe chemistry / dissociation correction.\n\n\n\n\n\n","category":"method"},{"location":"lib/library/#SatelliteToolbox._densm-Union{Tuple{N3}, Tuple{N2}, Tuple{T}, Tuple{T, T, T, T, T, T, StaticArrays.StaticVector{N3, T}, AbstractVector{T}, AbstractVector{T}, StaticArrays.StaticVector{N2, T}, AbstractVector{T}, AbstractVector{T}}} where {T<:Number, N2, N3}","page":"Library","title":"SatelliteToolbox._densm","text":"_densm(re::T, gsurf::T, alt::T, d0::T, xm::T, tz::T, zn3::StaticVector{N3,T}, tn3::AbstractVector{T}, tgn3::AbstractVector{T}, zn2::StaticVector{N2,T}, tn2::AbstractVector{T}, tgn2::AbstractVector{T}) where {T<:Number,N2,N3}\n\nCompute the temperature and density profiles for lower atmosphere.\n\nReturns\n\nThe density.\nThe temperature.\n\n\n\n\n\n","category":"method"},{"location":"lib/library/#SatelliteToolbox._densu-Union{Tuple{N}, Tuple{T}, Tuple{T, T, T, T, T, T, T, T, T, T, StaticArrays.StaticVector{N, T}, AbstractVector{T}, AbstractVector{T}}} where {T<:Number, N}","page":"Library","title":"SatelliteToolbox._densu","text":"_densu(re::T, gsurf::T, alt::T, dlb::T, tinf::T, tlb::T, xm::T, alpha::T, zlb::T, s2::T, zn1::StaticVector{N,T}, tn1::AbstractVector{T}, tgn1::AbstractVector{T}) where {T<:Number,N}\n\nCompute the temperature and density profiles for MSIS models.\n\nThis algorithm uses new lower thermo polynomial.\n\nReturns\n\nThe density.\nThe temperature.\n\n\n\n\n\n","category":"method"},{"location":"lib/library/#SatelliteToolbox._dnet-Union{Tuple{T}, NTuple{5, T}} where T<:Number","page":"Library","title":"SatelliteToolbox._dnet","text":"_dnet(dd::T, dm::T, zhm::T, xmm::T, xm::T) where T<:Number\n\nTurbopause correction for MSIS models.\n\nArgs\n\ndd: Diffusive density.\ndm: Full mixed density.\nzhm: Transition scale length.\nxmm: Full mixed molecular weight.\nxm: Species molecular weight.\n\nReturns\n\nThe combined density.\n\n\n\n\n\n","category":"method"},{"location":"lib/library/#SatelliteToolbox._get_degree_and_order-NTuple{4, Any}","page":"Library","title":"SatelliteToolbox._get_degree_and_order","text":"_get_degree_and_order(dP, P, n_max, m_max)\n\nReturn the maximum degree and order to compute the Legendre associated functions given the matrices dP, P, and the configuration values n_max and m_max.\n\n\n\n\n\n","category":"method"},{"location":"lib/library/#SatelliteToolbox._get_degree_and_order-Tuple{Any, Any, Any}","page":"Library","title":"SatelliteToolbox._get_degree_and_order","text":"_get_degree_and_order(P, n_max, m_max)\n\nReturn the maximum degree and order to compute the Legendre associated functions given the matrix P and the configuration values n_max and m_max.\n\n\n\n\n\n","category":"method"},{"location":"lib/library/#SatelliteToolbox._glob7s-Union{Tuple{T}, Tuple{AbstractVector{T}, NRLMSISE00_Structure{T}}} where T<:Number","page":"Library","title":"SatelliteToolbox._glob7s","text":"_glob7s(p::AbstractVector{T}, nrlmsise00d::NRLMSISE00_Structure{T}) where T<:Number\n\nVersion of Globe for lower atmosphere (1999-10-26).\n\nArgs\n\np: Vector with the coefficients.\nnrlmsise00d: NRLMSISE-00 structure (see NRLMSISE00_Structure).\n\nReturns\n\nThe temperature (?).\n\n\n\n\n\n","category":"method"},{"location":"lib/library/#SatelliteToolbox._globe7!-Union{Tuple{T}, Tuple{AbstractVector{T}, NRLMSISE00_Structure{T}}} where T<:Number","page":"Library","title":"SatelliteToolbox._globe7!","text":"_globe7!(p::AbstractVector{T}, nrlmsise00d::NRLMSISE00_Structure{T}) where T<:Number\n\nCompute G(L) function.\n\nNotice that the parameters apt and apdf of structure nrlmsise00d are modified.\n\nArgs\n\np: Vector with the coefficients.\nnrlmsise00d: NRLMSISE-00 structure (see NRLMSISE00_Structure).\n\nReturns\n\nThe temperature (?).\n\n\n\n\n\n","category":"method"},{"location":"lib/library/#SatelliteToolbox._init_dtcfile-Tuple{}","page":"Library","title":"SatelliteToolbox._init_dtcfile","text":"_init_dctfile(;force_download = false, local_path = nothing)\n\nInitialize the data in the file DTCFILE.TXT by creating _dtcfile_data. The initialization process is composed of:\n\nDownload the file, if it is necessary;\nParse the file;\nCreate the interpolations and the structures.\n\nIf the keyword force_download is true, then the file will always be downloaded.\n\nThe user can also specify a location for the file using the keyword local_path. If it is nothing, which is the default, then the file will be downloaded.\n\n\n\n\n\n","category":"method"},{"location":"lib/library/#SatelliteToolbox._init_fluxtable-Tuple{}","page":"Library","title":"SatelliteToolbox._init_fluxtable","text":"_init_fluxtable(;force_download = false, local_path = nothing)\n\nInitialize the data in the file fluxtable.txt by creating _fluxtable_data. The initialization process is composed of:\n\nDownload the file, if it is necessary;\nParse the file;\nCreate the interpolations and the structures.\n\nIf the keyword force_download is true, then the file will always be downloaded.\n\nThe user can also specify a location for the file using the keyword local_path. If it is nothing, which is the default, then the file will be downloaded.\n\n\n\n\n\n","category":"method"},{"location":"lib/library/#SatelliteToolbox._init_solfsmy-Tuple{}","page":"Library","title":"SatelliteToolbox._init_solfsmy","text":"_init_solfsmy(;force_download = false, local_path = nothing)\n\nInitialize the data in the file SOLFSMY.TXT by creating _solfsmy_data. The initialization process is composed of:\n\nDownload the file, if it is necessary;\nParse the file;\nCreate the interpolations and the structures.\n\nIf the keyword force_download is true, then the file will always be downloaded.\n\nThe user can also specify a location for the file using the keyword local_path. If it is nothing, which is the default, then the file will be downloaded.\n\n\n\n\n\n","category":"method"},{"location":"lib/library/#SatelliteToolbox._init_wdcfiles-Tuple{}","page":"Library","title":"SatelliteToolbox._init_wdcfiles","text":"_init_wdcfiles(;force_download = false, local_dir = nothing, wdcfiles_oldest_year = year(now())-3)\n\nInitialize the data in the WDC files by creating _wdcfiles_data. The initialization process is composed of:\n\nDownload the files, if it is necessary;\nParse the files;\nCreate the interpolations and the structures.\n\nIf the keyword force_download is true, then the files will always be downloaded.\n\nThe user can also specify a location for the directory with the WDC files using the keyword local_dir. If it is nothing, which is the default, then the file will be downloaded.\n\nThe user can select what is the oldest year in which the data will be downloaded by the keyword wdcfiles_oldest_year. By default, it will download the data from 3 previous years.\n\nThe user can select what is the newest year in which the data will be downloaded by the keyword wdcfiles_newest_year. It it is nothing, which is the default, then it is set to the current year.\n\n\n\n\n\n","category":"method"},{"location":"lib/library/#SatelliteToolbox._jb2008_M-Tuple{R} where R","page":"Library","title":"SatelliteToolbox._jb2008_M","text":"_jb2008_M(z::R) where R\n\nCompute the mean molecular mass at altitude z [km] using the empirical profile in eq. 1 [3].\n\n\n\n\n\n","category":"method"},{"location":"lib/library/#SatelliteToolbox._jb2008_T-Union{Tuple{R}, Tuple{R, R, R}} where R<:Number","page":"Library","title":"SatelliteToolbox._jb2008_T","text":"_jb2008_T(z::R, Tx::R, T∞::R) where R<:Number\n\nCompute the temperature [K] at height z [km] given the temperature Tx [K] at the inflection point, and the exospheric temperature T∞ [K] according to the theory of the model Jacchia 1971 [3].\n\nThe inflection point is considered to by z = 125 km.\n\n\n\n\n\n","category":"method"},{"location":"lib/library/#SatelliteToolbox._jb2008_grav-Tuple{R} where R","page":"Library","title":"SatelliteToolbox._jb2008_grav","text":"_jb2008_grav(z::R) where R\n\nCompute the gravity [m/s] at altitude z [km] according to the model Jacchia 1971 [3].\n\n\n\n\n\n","category":"method"},{"location":"lib/library/#SatelliteToolbox._jb2008_highaltitude-Tuple{Number, Number}","page":"Library","title":"SatelliteToolbox._jb2008_highaltitude","text":"_jb2008_highaltitude(h::Number, F10ₐ::Number)\n\nCompute the high altitude exospheric density correction factor in altitude h [km] and the averaged 10.7-cm solar flux (81-day centered on input time) [10⁻²² W/(M² Hz)].\n\nThis function uses the model in Section 6.2 of [2].\n\n\n\n\n\n","category":"method"},{"location":"lib/library/#SatelliteToolbox._jb2008_int-Tuple{Number, Number, Number, Number, Number, Function}","page":"Library","title":"SatelliteToolbox._jb2008_int","text":"_jb2008_int(z₀::Number, z₁::Number, R::Number, Tx::Number, T∞::Number, δf::Function)\n\nCompute the integral of the function δf between z₀ and z₁ using the Newton-Cotes 4th degree method. R is a number that defines the step size, Tx is the temperature at the inflection point, and T∞ is the exospheric temperature.\n\nThe signature of the function δf is:\n\nδf(z, Tx, T∞)\n\nand it must be _jb2008_δf1 or _jb2008_δf2.\n\nThis function returns a tuple containing the integral and last value of z used in the numerical algorithm.\n\n\n\n\n\n","category":"method"},{"location":"lib/library/#SatelliteToolbox._jb2008_semiannual-NTuple{5, Number}","page":"Library","title":"SatelliteToolbox._jb2008_semiannual","text":"_jb2008_semiannual(doy::Number, h::Number, F10ₐ::Number, S10ₐ::Number, M10ₐ::Number)\n\nCompute the semiannual variation of the density considering the JB2008 model [1].\n\nArgs\n\ndoy: Day of the year + fraction of the day.\nh: Height [km].\nF10ₐ: Averaged 10.7-cm flux (81-day centered on input-time)         [10⁻²² W/(M² Hz)].\nS10ₐ: EUV 81-day averaged centered index.\nM10ₐ: MG2 81-day averaged centered index.\n\nReturns\n\nSemiannual F(z) heigh function.\nSemiannual G(t) yearly periodic function.\nSemiannual variation of the density Δsalog₁₀ρ.\n\n\n\n\n\n","category":"method"},{"location":"lib/library/#SatelliteToolbox._jb2008_ΔTc-NTuple{4, Number}","page":"Library","title":"SatelliteToolbox._jb2008_ΔTc","text":"_jb2008_ΔTc(F10::Number, lst::Number, glat::Number, h::Number)\n\nCompute the correction in the Tc for Jacchia-Bowman model.\n\nThis correction is mention in [2]. However, the equations do not seem to match those in the source-code. The ones implemented here are exactly the same as in the source-code.\n\nArgs\n\nF10: F10.7 flux.\nlst: Local solar time (0 - 24) [hr].\nglat: Geocentric latitude [rad].\nh: Altitude [km].\n\nReturns\n\nThe correction ΔTc [K].\n\n\n\n\n\n","category":"method"},{"location":"lib/library/#SatelliteToolbox._jb2008_δf1-Tuple{Any, Any, Any}","page":"Library","title":"SatelliteToolbox._jb2008_δf1","text":"_jb2008_δf1(z, Tx, T∞)\n\nAuxiliary function to compute the integrand in _jb2008_int.\n\n\n\n\n\n","category":"method"},{"location":"lib/library/#SatelliteToolbox._jb2008_δf2-Tuple{Any, Any, Any}","page":"Library","title":"SatelliteToolbox._jb2008_δf2","text":"_jb2008_δf2(z, Tx, T∞)\n\nAuxiliary function to compute the integrand in _jb2008_int.\n\n\n\n\n\n","category":"method"},{"location":"lib/library/#SatelliteToolbox._jr1971_M-Tuple{R} where R","page":"Library","title":"SatelliteToolbox._jr1971_M","text":"_jr1971_M(z::R) where R\n\nCompute the mean molecular mass at altitude z [km] using the empirical profile in eq. 1 [3,4].\n\n\n\n\n\n","category":"method"},{"location":"lib/library/#SatelliteToolbox._jr1971_T-Union{Tuple{R}, Tuple{R, R, R}} where R<:Number","page":"Library","title":"SatelliteToolbox._jr1971_T","text":"_jr1971_T(z::R, Tx::R, T∞::R) where R<:Number\n\nCompute the temperature [K] at height z [km] given the temperature Tx [K] at the inflection point, and the exospheric temperature T∞ [K] according to the theory of the model Jacchia-Roberts 1971 [1,3,4].\n\nThe inflection point is considered to by z = 125 km.\n\n\n\n\n\n","category":"method"},{"location":"lib/library/#SatelliteToolbox._jr1971_roots-Union{Tuple{Vector{R}}, Tuple{R}} where R","page":"Library","title":"SatelliteToolbox._jr1971_roots","text":"_jr1971_roots(p::Polynomial{R}) where R\n\nCompute the roots of the polynomial p necessary to compute the density below 125 km. It returns the value r₁, r₂, x, and y.\n\n\n\n\n\n","category":"method"},{"location":"lib/library/#SatelliteToolbox._parse_dtcfile-Tuple{AbstractString}","page":"Library","title":"SatelliteToolbox._parse_dtcfile","text":"_parse_dtcfile(path::AbstractString)\n\nParse the DTCFILE.TXT file in path and return an instance of the structure _DTCFILE_Structure with the initialized interpolations.\n\nThe format of the file DTCFILE.TXT must be:\n\nDTC YYYY DOY DTC_0h DTC_1h DTC_2h ... DTC_22h DTC_23h\n\nin which DOY is the day of the year and DTC_Xh is the ΔTc at hour X.\n\n\n\n\n\n","category":"method"},{"location":"lib/library/#SatelliteToolbox._parse_fluxtable-Tuple{AbstractString}","page":"Library","title":"SatelliteToolbox._parse_fluxtable","text":"_parse_fluxtable(path::AbstractString)\n\nParse the fluxtable.txt file in path and return an instance of the structure _fluxtable_Structure with the initialize interpolations.\n\n\n\n\n\n","category":"method"},{"location":"lib/library/#SatelliteToolbox._parse_solfsmy-Tuple{AbstractString}","page":"Library","title":"SatelliteToolbox._parse_solfsmy","text":"_parse_solfsmy(path::AbstractString)\n\nParse the SOLFSMY.TXT file in path and retur an instance of the structure _SOLFSMY_Structure with the initialized interpolations.\n\nThe format of the file SOLFSMY.TXT must be:\n\nYYYY DDD   JulianDay  F10   F81c  S10   S81c  M10   M81c  Y10   Y81c  Ssrc\n\n\n\n\n\n","category":"method"},{"location":"lib/library/#SatelliteToolbox._parse_wdcfiles-Tuple{Vector{String}, Vector{Int64}}","page":"Library","title":"SatelliteToolbox._parse_wdcfiles","text":"_parse_wdcfiles(filepaths::Vector{String}, years::Vector{Int})\n\nParse the WDC files with paths in filepaths related to the years in years.\n\nNotice that the files must be sorted by the year!\n\n\n\n\n\n","category":"method"},{"location":"lib/library/#SatelliteToolbox._prepare_wdc_remote_files-Tuple{Number, Number}","page":"Library","title":"SatelliteToolbox._prepare_wdc_remote_files","text":"_prepare_wdc_remote_files(oldest_year::Number, newest_year::Number)\n\nConfigure all the WDC remote files between newest_year and oldest_year. Notice that previous years will never be updated whereas the current year will be updated daily.\n\nIf oldest_year is greater than current year, then only the files from the current year will be downloaded.\n\nIf newest_year is smaller than oldest_year, then only the files from the oldest_year will be downloaded.\n\nThis function modifies the global variable _wdcfiles.\n\n\n\n\n\n","category":"method"},{"location":"lib/library/#SatelliteToolbox._spline-Union{Tuple{N}, Tuple{T}, Tuple{StaticArrays.StaticVector{N, T}, StaticArrays.StaticVector{N, T}, T, T}} where {T<:Number, N}","page":"Library","title":"SatelliteToolbox._spline","text":"_spline(x::StaticVector{N,T}, y::StaticVector{N,T}, yp1::T, ypn::T) where {T<:Number,N}\n\nCompute the 2nd derivatives of cubic spline interpolation function tabulated by x and y given the 2nd derivatives values at x[1] (yp1) and at x[N] (ypn).\n\nThis function was adapted from Numerical Recipes.\n\nArgs\n\nx: X components of the tabulated function in ascending order.\ny: Y components of the tabulated function evaluated at x.\nyp1: 2nd derivative value at x[1].\nypn: 2nd derivative value at x[N].\n\nReturns\n\nThe 2nd derivative of cubic spline interpolation function evaluated at x.\n\nRemarks\n\nValues higher than 1e30 in the 2nd derivatives at the borders (yp1 and ypn) are interpreted as 0.\n\n\n\n\n\n","category":"method"},{"location":"lib/library/#SatelliteToolbox._splini-Union{Tuple{N}, Tuple{T}, Tuple{StaticArrays.StaticVector{N, T}, StaticArrays.StaticVector{N, T}, StaticArrays.StaticVector{N, T}, T}} where {T<:Number, N}","page":"Library","title":"SatelliteToolbox._splini","text":"_splini(xa::StaticVector{N,T}, ya::StaticVector{N,T}, y2a::StaticVector{N,T}, x::T) where {T<:Number,N}\n\nCompute the integral of the cubic spline function from xa[1] to x.\n\nArgs\n\nxa: X components of the tabulated function in ascending order.\nya: Y components of the tabulated function evaluated at xa.\ny2a: Second derivatives.\nx: Abscissa endpoint for integration.\n\nReturns\n\nThe integral of cubic spline function from xa[1] to x.\n\n\n\n\n\n","category":"method"},{"location":"lib/library/#SatelliteToolbox._splint-Union{Tuple{N}, Tuple{T}, Tuple{StaticArrays.StaticVector{N, T}, StaticArrays.StaticVector{N, T}, StaticArrays.StaticVector{N, T}, T}} where {T<:Number, N}","page":"Library","title":"SatelliteToolbox._splint","text":"_splint(xa::StaticVector{N,T}, ya::StaticVector{N,T}, y2a::StaticVector{N,T}, x::T) where {T<:Number,N}\n\nCompute the cubic spline interpolation value at x.\n\nThis function was adapted from Numerical Recipes.\n\nArgs\n\nxa: X components of the tabulated function in ascending order.\nya: Y components of the tabulated function evaluated at xa.\ny2a: Second derivatives.\nx: Abscissa endpoint for interpolation.\n\nReturns\n\nThe cubic spline interpolation value at x.\n\n\n\n\n\n","category":"method"},{"location":"lib/library/#SatelliteToolbox.adjacent_track_angle_grss-Tuple{Number, Number, Number, Int64, Number}","page":"Library","title":"SatelliteToolbox.adjacent_track_angle_grss","text":"adjacent_track_angle_grss(h::Number, T::Number, i::Number, To::Int, lat::Number)\n\nCompute the angle between two adjacent ground tracks [rad] in a given latitude lat [rad] measured from the satellite position for a ground repeating, Sun-synchronous orbit with altitude in the Equator h [m], period T [s], inclination i [rad], and orbit cycle To [days].\n\nRemarks\n\nThe functions does not check if the orbit is a GRSS orbit.\n\n\n\n\n\n","category":"method"},{"location":"lib/library/#SatelliteToolbox.adjacent_track_angle_grss-Tuple{Number, Number, Number, Number, Int64, Number}","page":"Library","title":"SatelliteToolbox.adjacent_track_angle_grss","text":"adjacent_track_angle_grss(h::Number, a::Number, e::Number, i::Number, To::Int, lat::Number)\n\nCompute the angle between two adjacent ground tracks [rad] in a given latitude lat [rad] measured from the satellite position for a ground repeating, Sun-synchronous orbit with altitude in the Equator h [m], semi-major axis a [m], eccentricity e, inclination i [rad], and orbit cycle To [days].\n\nRemarks\n\nThe functions does not check if the orbit is a GRSS orbit.\n\n\n\n\n\n","category":"method"},{"location":"lib/library/#SatelliteToolbox.adjacent_track_distance_grss-Tuple{Number, Number, Int64, Number}","page":"Library","title":"SatelliteToolbox.adjacent_track_distance_grss","text":"adjacent_track_distance_grss(T::Number, i::Number, To::Int, lat::Number)\n\nCompute the distance between adjacent ground tracks [m] at a given latitude lat [rad] for a ground repeating, Sun-synchronous orbit with period T [s], inclination i [rad], and orbit cycle To [days].\n\nRemarks\n\nThe functions does not check if the orbit is a GRSS orbit.\n\n\n\n\n\n","category":"method"},{"location":"lib/library/#SatelliteToolbox.adjacent_track_distance_grss-Tuple{Number, Number, Number, Int64, Number}","page":"Library","title":"SatelliteToolbox.adjacent_track_distance_grss","text":"adjacent_track_distance_grss(a::Number, e::Number, i::Number, To::Int, lat::Number)\n\nCompute the distance between adjacent ground tracks [m] at a given latitude lat [rad] for a ground repeating, Sun-synchronous orbit with semi-major axis a [m], eccentricity e, inclination i [rad], and orbit cycle To [days].\n\nRemarks\n\nThe functions does not check if the orbit is a GRSS orbit.\n\n\n\n\n\n","category":"method"},{"location":"lib/library/#SatelliteToolbox.angvel","page":"Library","title":"SatelliteToolbox.angvel","text":"angvel(a::Number, e::Number, i::Number, pert::Symbol = :J2)\nangvel(orb::Orbit, pert::Symbol = :J2)\n\nCompute the angular velocity [rad/s] of an object in an orbit with semi-major axis a [m], eccentricity e, and inclination i [rad], using the perturbation terms specified by the symbol pert. The orbit can also be specified by orb (see Orbit).\n\npert can be:\n\n:J0: Consider a Keplerian orbit.\n:J2: Consider the perturbation terms up to J2.\n:J4: Consider the perturbation terms J2, J4, and J2².\n\nIf pert is omitted, then it defaults to :J2.\n\n\n\n\n\n","category":"function"},{"location":"lib/library/#SatelliteToolbox.angvel_to_a","page":"Library","title":"SatelliteToolbox.angvel_to_a","text":"angvel_to_a(n::Number, e::Number, i::Number, pert::Symbol = :J2; μ::Number = m0, max_iter::Int = 20, tol::Number = 1e-10)\n\nCompute the semi-major axis that will provide an angular velocity n [rad/s] in an orbit with eccentricity e and inclination i [rad], using the perturbation terms specified by the symbol pert.\n\nNotice that the angular velocity n is related to the nodal period, i.e. the time between two consecutive passages by the ascending node.\n\npert can be:\n\n:J0: Consider a Keplerian orbit.\n:J2: Consider the perturbation terms up to J2.\n:J4: Consider the perturbation terms J2, J4, and J2².\n\nIf pert is omitted, then it defaults to :J2.\n\nKeyword\n\nμ: Standard gravitational parameter for Earth [m^3/s^2].      (Default = m0)\nmax_iter: Maximum number of iterations allowed in the Newton-Raphson             algorithm. (Default = 20)\ntol: Tolerance to stop the Newton-Raphson algorithm. (Default = 1e-10)\n\n\n\n\n\n","category":"function"},{"location":"lib/library/#SatelliteToolbox.beta_angle","page":"Library","title":"SatelliteToolbox.beta_angle","text":"beta_angle(JD₀::Number, a::Number, e::Number, i::Number, RAAN::Number, Δt::Integer, pert::Symbol = :J2)\n\nCompute the beta angle of an orbit with semi-major axis a [m], eccentricity e, inclination i [rad], and initial right ascension of the ascending node RAAN [rad]. The orbit epoch, which is also the day in which the analysis will begin, is JD₀ [Julian Day]. The analysis will be performed for each day during Δt days.\n\nThe argument pert can be used to select the perturbation terms that must be used when propagating the right ascencion of the ascending node. The possible values are:\n\n:J0: Consider a Keplerian orbit.\n:J2: Consider the perturbation terms up to J2.\n:J4: Consider the perturbation terms J2, J4, and J2².\n\nIf pert is omitted, then it defaults to :J2.\n\nReturns\n\nAn array with two columns. The first one contains the days of the analysis and the second one contains the beta angle [rad] for each day.\n\n\n\n\n\n","category":"function"},{"location":"lib/library/#SatelliteToolbox.change_oe_frame-Tuple{Number, Number, Number, Number, Number, Number, Vararg{Any, N} where N}","page":"Library","title":"SatelliteToolbox.change_oe_frame","text":"change_oe_frame(a::Number, e::Number, i::Number, Ω::Number, ω::Number, f::Number, conv_args...)\nchange_oe_frame(oe::Orbit, conv_args...)\n\nChange the reference frame of orbit elements. The orbit elements can be specified by a, e, i, Ω, ω, and f, or the structure oe (see Orbit). In the latter, the return value type will match the type of oe.\n\nThe conversion arguments conv_args are the same arguments that one should pass to the function r_eci_to_eci to convert between the desired frames. For more information, see the documentation of the function r_eci_to_eci.\n\nArgs\n\na: Semi-major axis [m].\ne: Excentricity.\ni: Inclination [rad].\nΩ: Right-ascension of the ascending node [rad].\nω: Argument of perigee [rad].\nf: True anomaly [rad].\nconv_args...: Conversion arguments, which are the same arguments that one                 would pass to the function r_eci_to_eci to convert between the                 desired frames.\noe: An instance of the structure Orbit with the orbit elements       that will be converted [SI units].\n\nReturns\n\nUsing the first signature, this function returns an instance of KeplerianElements. If the second signature is used, then the function return an element with the same type of the input.\n\nExamples\n\njulia> eop = get_iers_eop(:IAU1980);\n\njulia> teme_epoch = date_to_jd(2016,6,1,11,0,0);\n\njulia> tod_epoch  = date_to_jd(2016,1,1,0,0,0);\n\njulia> k_teme     = KeplerianElements(teme_epoch,\n                                      7130.982e3,\n                                      0.001111,\n                                      98.405*pi/180,\n                                      227.336*pi/180,\n                                      90*pi/180,\n                                      320*pi/180)\nKeplerianElements{Float64}:\n           Epoch :    2.45754e6 (2016-06-01T11:00:00)\n Semi-major axis : 7130.98     km\n    Eccentricity :    0.001111\n     Inclination :   98.405    °\n            RAAN :  227.336    °\n Arg. of Perigee :   90.0      °\n    True Anomaly :  320.0      °\n\njulia> k_j2000 = change_oe_frame(k_teme, TEME(), J2000(), teme_epoch, eop)\nKeplerianElements{Float64}:\n           Epoch :    2.45754e6 (2016-06-01T11:00:00)\n Semi-major axis : 7130.98     km\n    Eccentricity :    0.001111\n     Inclination :   98.3365   °\n            RAAN :  227.134    °\n Arg. of Perigee :   90.0604   °\n    True Anomaly :  320.0      °\n\njulia> k_tod = change_oe_frame(k_teme, TEME(), teme_epoch, TOD(), tod_epoch, eop)\nKeplerianElements{Float64}:\n           Epoch :    2.45754e6 (2016-06-01T11:00:00)\n Semi-major axis : 7130.98     km\n    Eccentricity :    0.001111\n     Inclination :   98.4037   °\n            RAAN :  227.331    °\n Arg. of Perigee :   90.0014   °\n    True Anomaly :  320.0      °\n\n\n\n\n\n","category":"method"},{"location":"lib/library/#SatelliteToolbox.cio_iau2006-Tuple{Number}","page":"Library","title":"SatelliteToolbox.cio_iau2006","text":"cio_iau2006(JD_TT::Number)\n\nCompute the coordinates X and Y of the Celestial Intermediate Pole (CIP) with respect to the Geocentric Celestial Reference Frame (GCRF), and the CIO locator s. The algorithm is based on the IAU-2006 theory.\n\nThe CIO locator s provides the position of the CIO on the Equator of the CIP corresponding to the kinematical definition of the non-rotation origin in the GCRS when the CIP is moving with respect to the GCRS between the reference epoch and the epoch due to precession and nutation [1, p. 214].\n\nReturns\n\nThe coordinate X of the CIP w.r.t. the GCRF.\nThe coordinate Y of the CIP w.r.t. the GCRF.\nThe CIO locator s.\n\n\n\n\n\n","category":"method"},{"location":"lib/library/#SatelliteToolbox.compute_RAAN_lt-Tuple{Number, Number}","page":"Library","title":"SatelliteToolbox.compute_RAAN_lt","text":"compute_RAAN_lt(JD::Number, asc_node_lt::Number)\n\nCompute the RAAN (0,2π) [rad] so that the orbit plane local time is asc_node_lt [hour] at the Julian day JD.\n\n\n\n\n\n","category":"method"},{"location":"lib/library/#SatelliteToolbox.compute_U-Union{Tuple{T}, Tuple{GravityModel_Coefs{T}, AbstractVector{T} where T}, Tuple{GravityModel_Coefs{T}, AbstractVector{T} where T, Number}, Tuple{GravityModel_Coefs{T}, AbstractVector{T} where T, Number, Number}} where T<:Number","page":"Library","title":"SatelliteToolbox.compute_U","text":"compute_U(gm_coefs::GravityModel_Coefs{T}, r::AbstractVector, n_max::Number = -1, m_max::Number = -1) where T<:Number\n\nCompute the gravitational potential [J/kg] at r (ITRF) [m] using the coefficients gm_coefs (see GravityModel_Coefs). The maximum degree that will be used while computing the spherical harmonics will be n_max and the maximum order is m_max.\n\nIf n_max is negative, then the maximum available degree will be used. If n_max is omitted, then it defaults to 0.\n\nIf m_max is negative or if it is greater than n_max, then it will be set to n_max. If m_max is omitted, then it defaults to 0.\n\ninfo: Info\nBy convention, the result with n_max 0 and 1 will be the same.\n\n\n\n\n\n","category":"method"},{"location":"lib/library/#SatelliteToolbox.compute_dU-Union{Tuple{T}, Tuple{GravityModel_Coefs{T}, AbstractVector{T} where T}, Tuple{GravityModel_Coefs{T}, AbstractVector{T} where T, Number}, Tuple{GravityModel_Coefs{T}, AbstractVector{T} where T, Number, Number}} where T<:Number","page":"Library","title":"SatelliteToolbox.compute_dU","text":"compute_dU(gm_coefs::GravityModel_Coefs{T}, r::AbstractVector, n_max::Number = -1, m_max::Number = -1) where T<:Number\n\nCompute the derivatives w.r.t. the spherical coordinates of the gravitational field (∂U/∂r, ∂U/∂ϕ, ∂U/∂λ) defined by the coefficients gm_coefs (see GravityModel_Coefs) at the position r [m] in ITRF. The maximum degree that will be used while computing the spherical harmonics will be n_max and the maximum order is m_max.\n\nIf n_max is negative, then the maximum available degree will be used. If n_max is omitted, then it defaults to 0.\n\nIf m_max is negative or if it is greater than n_max, then it will be set to n_max. If m_max is omitted, then it defaults to 0.\n\ninfo: Info\nBy convention, the result with n_max 0 and 1 will be the same.\n\nReturns\n\nThe derivative of the gravitational field w.r.t. the radius (∂U/∂r).\nThe derivative of the gravitational field w.r.t. the latitude (∂U/∂ϕ).\nThe derivative of the gravitational field w.r.t. the longitude (∂U/∂λ).\n\nRemarks\n\nIn this case, ϕ is the geocentric latitude and λ is the geocentric longitude.\n\n\n\n\n\n","category":"method"},{"location":"lib/library/#SatelliteToolbox.compute_g-Union{Tuple{T}, Tuple{GravityModel_Coefs{T}, AbstractVector{T} where T}, Tuple{GravityModel_Coefs{T}, AbstractVector{T} where T, Number}, Tuple{GravityModel_Coefs{T}, AbstractVector{T} where T, Number, Number}} where T<:Number","page":"Library","title":"SatelliteToolbox.compute_g","text":"compute_g(gm_coefs::GravityModel_Coefs{T}, r::AbstractVector, n_max::Number = -1, m_max::Number = -1) where T<:Number\n\nCompute the gravitational acceleration (ITRF) [m/s²] at position r [m] (ITRF) using the coefficients gm_coefs (see GravityModel_Coefs). The maximum degree that will be used while computing the spherical harmonics will be n_max and the maximum order it m_max.\n\nIf n_max is negative, then the maximum available degree will be used. If n_max is omitted, then it defaults to 0.\n\nIf m_max is negative or if it is greater than n_max, then it will be set to n_max. If m_max is omitted, then it defaults to 0.\n\ninfo: Info\nBy convention, the result with n_max 0 and 1 will be the same.\n\nRemarks\n\nNotice that this function computes the gravitational acceleration. Hence, the acceleration due to Earth rotation rate is not included.\n\n\n\n\n\n","category":"method"},{"location":"lib/library/#SatelliteToolbox.compute_ss_orbit_by_ang_vel-Tuple{Number, Number}","page":"Library","title":"SatelliteToolbox.compute_ss_orbit_by_ang_vel","text":"compute_ss_orbit_by_ang_vel(n::Number, e::Number)\n\nCompute the Sun-synchronous orbit given the angular velocity n [rad/s] and the eccentricity e.\n\nReturns\n\nThe semi-major axis [m].\nThe inclination [rad].\nThe residues of the two functions.\nA boolean variable that indicates if the numerical algorithm converged.\n\n\n\n\n\n","category":"method"},{"location":"lib/library/#SatelliteToolbox.compute_ss_orbit_by_inclination-Tuple{Number, Number}","page":"Library","title":"SatelliteToolbox.compute_ss_orbit_by_inclination","text":"compute_ss_orbit_by_inclination(i::Number, e::Number)\n\nCompute the Sun-synchronous orbit given the inclination i [rad] and the eccentricity e.\n\nReturns\n\nThe semi-major axis of the Sun-synchronous orbit [m].\n\n\n\n\n\n","category":"method"},{"location":"lib/library/#SatelliteToolbox.compute_ss_orbit_by_num_rev_per_day-Tuple{Number, Number}","page":"Library","title":"SatelliteToolbox.compute_ss_orbit_by_num_rev_per_day","text":"compute_ss_orbit_by_num_rev_per_day(numRevPD::Number, e::Number)\n\nCompute the Sun-synchronous orbit given the number of revolutions per day numRevPD and the eccentricity e.\n\nReturns\n\nThe semi-major axis [m].\nThe inclination [rad].\nThe residues of the two functions.\nA boolean variable that indicates if the numerical algorithm converged.\n\n\n\n\n\n","category":"method"},{"location":"lib/library/#SatelliteToolbox.compute_ss_orbit_by_semi_major_axis-Tuple{Number, Number}","page":"Library","title":"SatelliteToolbox.compute_ss_orbit_by_semi_major_axis","text":"compute_ss_orbit_by_semi_major_axis(a::Number, e::Number)\n\nCompute the Sun-synchronous orbit given the semi-major axis a [m] and the eccentricity e.\n\nReturns\n\nThe inclination of the Sun-synchronous orbit [rad].\n\n\n\n\n\n","category":"method"},{"location":"lib/library/#SatelliteToolbox.conf_nrlmsise00","page":"Library","title":"SatelliteToolbox.conf_nrlmsise00","text":"conf_nrlmsise00(year::Int, doy::Int, sec::Number, alt::Number, g_lat::Number, g_long::Number, lst::Number, f107A::Number, f107::Number, ap::[Number, AbstractVector], flags::NRLMSISE00_Flags = NRLMSISE00_Flags())\n\nCreate the structure with the proper configuration to call the NRLMSISE-00 model.\n\nNotice that the input variables have the same units of the original model.\n\nArgs\n\nyear: Year (currently ignored).\ndoy: Day of year.\nsec: Seconds in day [UT].\nalt: Altitude [km].\ng_lat: Geodetic latitude [deg].\ng_long: Geodetic longitude [deg].\nlst: Local apparent solar time (hours).\nf107A: 81 day average of F10.7 flux (centered on day of year doy).\nf107: Daily F10.7 flux for previous day.\nap: Magnetic index (daily) if it is a number. If it is an array, then see       Remarks.\nflags: (OPTIONAL) An instance of the structure NRLMSISE00_Flags with the           configuration flags for NRLMSISE00. If omitted, then the default           configurations will be used.\n\nReturns\n\nAn instance of the structure NRLMSISE00_Structure.\n\nRemarks\n\nIf ap is a Vector, then it must be a vector with 7 dimensions as described below:\n\nIndex Description\n1 Daily AP.\n2 3 hour AP index for current time.\n3 3 hour AP index for 3 hours before current time.\n4 3 hour AP index for 6 hours before current time.\n5 3 hour AP index for 9 hours before current time.\n6 Average of eight 3 hour AP indices from 12 to 33 hours prior to current time.\n7 Average of eight 3 hour AP indices from 36 to 57 hours prior to current time.\n\nNotes on input variables\n\nUT, Local Time, and Longitude are used independently in the model and are not of equal importance for every situation. For the most physically realistic calculation these three variables should be consistent (lst=sec/3600 + g_long/15). The Equation of Time departures from the above formula for apparent local time can be included if available but are of minor importance.\n\nf107 and f107A values used to generate the model correspond to the 10.7 cm radio flux at the actual distance of the Earth from the Sun rather than the radio flux at 1 AU. The following site provides both classes of values:\n\nftp://ftp.ngdc.noaa.gov/STP/SOLAR_DATA/SOLAR_RADIO/FLUX/\n\nf107, f107A, and ap effects are neither large nor well established below 80 km and these parameters should be set to 150, 150, and 4 respectively.\n\n\n\n\n\n","category":"function"},{"location":"lib/library/#SatelliteToolbox.create_gravity_model_coefs-Tuple{ICGEM}","page":"Library","title":"SatelliteToolbox.create_gravity_model_coefs","text":"create_gravity_model_coefs(icgem::ICGEM)\n\nReturn an instance of the structure GravityModel_Coefs based on the information obtained from an ICGEM file in icgem (see parse_icgem).\n\n\n\n\n\n","category":"method"},{"location":"lib/library/#SatelliteToolbox.dargp","page":"Library","title":"SatelliteToolbox.dargp","text":"dargp(a::Number, e::Number, i::Number, pert::Symbol = :J2)\ndargp(orb::Orbit, pert::Symbol = :J2)\n\nCompute the time-derivative of the argument of perigee [rad/s] of an orbit with semi-major axis a [m], eccentricity e, and inclination i [rad], using the perturbation terms specified by the symbol pert. The orbit can also be specified by orb (see Orbit).\n\npert can be:\n\n:J0: Consider a Keplerian orbit.\n:J2: Consider the perturbation terms up to J2.\n:J4: Consider the perturbation terms J2, J4, and J2².\n\nIf pert is omitted, then it defaults to :J2.\n\n\n\n\n\n","category":"function"},{"location":"lib/library/#SatelliteToolbox.date_to_jd-Tuple{Dates.DateTime}","page":"Library","title":"SatelliteToolbox.date_to_jd","text":"date_to_jd(dateTime::DateTime)\n\nConvert the date and time dateTime to Julian Day.\n\n\n\n\n\n","category":"method"},{"location":"lib/library/#SatelliteToolbox.date_to_jd-Tuple{Dates.Date}","page":"Library","title":"SatelliteToolbox.date_to_jd","text":"date_to_jd(date::Date)\n\nConvert the date date to Julian Day.\n\n\n\n\n\n","category":"method"},{"location":"lib/library/#SatelliteToolbox.date_to_jd-Tuple{Integer, Integer, Integer, Integer, Integer, Number}","page":"Library","title":"SatelliteToolbox.date_to_jd","text":"date_to_jd(Y::Integer, M::Integer, D::Integer, h::Integer, m::Integer, s::Number)\n\nConvert a date represented using the Gregorian Calendar (Year = y, Month = M (1-12), Day = D, Hour = h (0-24), minute = m, and second = s) to Julian Day.\n\nRemarks\n\nThe algorithm was obtained from [2] (Accessed on 2018-04-11).\n\n\n\n\n\n","category":"method"},{"location":"lib/library/#SatelliteToolbox.deps_dpsi-Tuple{EOPData_IAU2000A, Number}","page":"Library","title":"SatelliteToolbox.deps_dpsi","text":"deps_dpsi(eop_iau2000a::EOPData_IAU2000A, JD::Number)\n\nReturns the celestial pole offsets in obliquity (δϵ2000) and longitude (δΨ2000) [arcsec]. This function obtains those values by converting the celestial pole offsets with respect to the GCRS (dX and dY). These values are necessary in the equinox-based IAU-2006 theory.\n\nThe algorithm was obtained from [2, eq. 5.25] and [3, DPSIDEPS2000_DXDY2000].\n\n\n\n\n\n","category":"method"},{"location":"lib/library/#SatelliteToolbox.dlegendre","page":"Library","title":"SatelliteToolbox.dlegendre","text":"dlegendre([N,] ϕ::Number, n_max::Integer, m_max::Integer = -1, ph_term::Bool = false)\n\nCompute the first-order derivative of the associated Legendre function P_n,m[cos(ϕ)] w.r.t. ϕ [rad]:\n\ndP_n,m[cos(ϕ)]\n--------------\n      dϕ\n\nThe maximum degree that will be computed is n_max and the maximum order is m_max. Notice that if m_max is higher than n_max or negative, than it is set to n_max.\n\nThe optional parameter N can be used to select the normalization. The following values are valid:\n\nVal(:full): Compute the fully normalized associated Legendre function (see               legendre_fully_normalized).\nVal(:schmidt): Compute the Schmidt quasi-normalized associated Legendre                  function (see legendre_schmidt_quasi_normalized).\nVal(:conv): Compute the conventional associated Legendre function (see               dlegendre_conventional!).\n\nIf N is omitted, then the full normalization will be used (Val(:full)).\n\nIf ph_term is set to true, then the Condon-Shortley phase term (-1)ᵐ will be included. If ph_term is not present, then it defaults to false.\n\nReturns\n\nA matrix with the first-order derivative of the Legendre associated functions\n\nP_n,m[cos(ϕ)].\n\nA matrix with the Legendre associated functions P_n,m[cos(ϕ)].\n\n\n\n\n\n","category":"function"},{"location":"lib/library/#SatelliteToolbox.dlegendre!","page":"Library","title":"SatelliteToolbox.dlegendre!","text":"dlegendre!([N,] dP::AbstractMatrix, ϕ::Number, P::AbstractMatrix, ph_term::Bool = false, n_max::Integer = -1, m_max::Integer = -1)\n\nCompute the first-order derivative of the associated Legendre function P_n,m[x] w.r.t. ϕ [rad]:\n\ndP_n,m[cos(ϕ)]\n--------------\n      dϕ\n\nThe derivatives will be stored in the matrix dP. The maximum degree and order that will be computed are given by the parameters n_max and m_max. If they are negative, then the dimensions of matrix dP will be used.\n\nThis algorithm needs the matrix P with the associated Legendre function. This can be computed using the function legendre. Notice that this matrix must be computed using the same normalization (see N) as the one selected here.\n\nThe optional parameter N can be used to select the normalization. The following values are valid:\n\nVal(:full): Compute the fully normalized associated Legendre function (see               dlegendre_fully_normalized!).\nVal(:schmidt): Compute the Schmidt quasi-normalized associated Legendre                  function (see dlegendre_schmidt_quasi_normalized!).\nVal(:conv): Compute the conventional associated Legendre function (see               dlegendre_conventional!).\n\nIf N is omitted, then the full normalization will be used (Val(:full)).\n\nIf ph_term is set to true, then the Condon-Shortley phase term (-1)ᵐ will be included. If ph_term is not present, then it defaults to false.\n\n\n\n\n\n","category":"function"},{"location":"lib/library/#SatelliteToolbox.dlegendre_conventional!","page":"Library","title":"SatelliteToolbox.dlegendre_conventional!","text":"dlegendre_conventional!(dP::AbstractMatrix, ϕ::Number, P::AbstractMatrix, ph_term::Bool = false, n_max::Integer = -1, m_max::Integer = -1)\n\nCompute the first-order derivative of the conventional associated Legendre function P_n,m[cos(ϕ)] w.r.t. ϕ [rad]:\n\ndP_n,m[cos(ϕ)]\n--------------\n      dϕ\n\nThe derivatives will be stored in the matrix dP. The maximum degree and order that will be computed are given by the parameters n_max and m_max. If they are negative, then the dimensions of matrix dP will be used.\n\nThis algorithm needs the matrix P with the conventional associated Legendre function. This can be computed using the function legendre_conventional.\n\nIf ph_term is set to true, then the Condon-Shortley phase term (-1)ᵐ will be included. If ph_term is not present, then it defaults to false.\n\nRemarks\n\nThe user is responsible to pass a matrix P with the correct values. For example, if ph_term is true, then P must also be computed with ph_term set to true.\n\n\n\n\n\n","category":"function"},{"location":"lib/library/#SatelliteToolbox.dlegendre_conventional-Union{Tuple{T}, Tuple{T, Integer}, Tuple{T, Integer, Integer}, Tuple{T, Integer, Integer, Bool}} where T<:AbstractFloat","page":"Library","title":"SatelliteToolbox.dlegendre_conventional","text":"dlegendre_conventional(ϕ::Number, n_max::Integer, m_max::Integer = -1, ph_term::Bool = false)\n\nCompute the first-order derivative of the conventional associated Legendre function P_n,m[cos(ϕ)] w.r.t. ϕ [rad]:\n\ndP_n,m[cos(ϕ)]\n--------------\n      dϕ\n\nThe maximum degree that will be computed is n_max and the maximum order is m_max. Notice that if m_max is higher than n_max or negative, than it is set to n_max.\n\nIf ph_term is set to true, then the Condon-Shortley phase term (-1)ᵐ will be included. If ph_term is not present, then it defaults to false.\n\nReturns\n\nA matrix with the first-order derivative of the Legendre associated functions P_n,m[cos(ϕ)].\n\n\n\n\n\n","category":"method"},{"location":"lib/library/#SatelliteToolbox.dlegendre_fully_normalized!","page":"Library","title":"SatelliteToolbox.dlegendre_fully_normalized!","text":"dlegendre_fully_normalized!(dP::AbstractMatrix, ϕ::Number, P::AbstractMatrix, ph_term::Bool = false, n_max::Integer = -1, m_max::Integer = -1)\n\nCompute the first-order derivative of the fully normalized associated Legendre function P_n,m[cos(ϕ)] w.r.t. ϕ [rad]:\n\ndP_n,m[cos(ϕ)]\n--------------\n      dϕ\n\nThe derivatives will be stored in the matrix dP. The maximum degree and order that will be computed are given by the parameters n_max and m_max. If they are negative, then the dimensions of matrix dP will be used.\n\nThis algorithm needs the matrix P with the fully normalized associated Legendre function. This can be computed using the function legendre_fully_normalized.\n\nIf ph_term is set to true, then the Condon-Shortley phase term (-1)ᵐ will be included. If ph_term is not present, then it defaults to false.\n\nRemarks\n\nThe user is responsible to pass a matrix P with the correct values. For example, if ph_term is true, then P must also be computed with ph_term set to true.\n\n\n\n\n\n","category":"function"},{"location":"lib/library/#SatelliteToolbox.dlegendre_fully_normalized-Union{Tuple{T}, Tuple{T, Integer}, Tuple{T, Integer, Integer}, Tuple{T, Integer, Integer, Bool}} where T<:AbstractFloat","page":"Library","title":"SatelliteToolbox.dlegendre_fully_normalized","text":"dlegendre_fully_normalized(ϕ::T, n_max::Integer, m_max::Integer = -1, ph_term::Bool = false) where T<:AbstractFloat\n\nCompute the first-order derivative of the Schmidt fully normalized associated Legendre function P_n,m[cos(ϕ)] w.r.t. ϕ [rad]:\n\ndP_n,m[cos(ϕ)]\n--------------\n      dϕ\n\nThe maximum degree that will be computed is n_max and the maximum order is m_max. Notice that if m_max is higher than n_max or negative, than it is set to n_max.\n\nIf ph_term is set to true, then the Condon-Shortley phase term (-1)ᵐ will be included. If ph_term is not present, then it defaults to false.\n\nReturns\n\nA matrix with the first-order derivative of the Legendre associated functions P_n,m[cos(ϕ)].\n\n\n\n\n\n","category":"method"},{"location":"lib/library/#SatelliteToolbox.dlegendre_schmidt_quasi_normalized!","page":"Library","title":"SatelliteToolbox.dlegendre_schmidt_quasi_normalized!","text":"dlegendre_schmidt_quasi_normalized!(dP::AbstractMatrix, ϕ::Number, P::AbstractMatrix, ph_term::Bool = false, n_max::Integer = -1, m_max::Integer = -1)\n\nCompute the first-order derivative of the Schmidt quasi-normalized associated Legendre function P_n,m[cos(ϕ)] w.r.t. ϕ [rad]:\n\ndP_n,m[cos(ϕ)]\n--------------\n      dϕ\n\nThe derivatives will be stored in the matrix dP. The maximum degree and order that will be computed are given by the parameters n_max and m_max. If they are negative, then the dimensions of matrix dP will be used.\n\nThis algorithm needs the matrix P with the Schmidt quasi-normalized associated Legendre function. This can be computed using the function legendre_schmidt_quasi_normalized.\n\nIf ph_term is set to true, then the Condon-Shortley phase term (-1)ᵐ will be included. If ph_term is not present, then it defaults to false.\n\nRemarks\n\nThe user is responsible to pass a matrix P with the correct values. For example, if ph_term is true, then P must also be computed with ph_term set to true.\n\n\n\n\n\n","category":"function"},{"location":"lib/library/#SatelliteToolbox.dlegendre_schmidt_quasi_normalized-Union{Tuple{T}, Tuple{T, Integer}, Tuple{T, Integer, Integer}, Tuple{T, Integer, Integer, Bool}} where T<:AbstractFloat","page":"Library","title":"SatelliteToolbox.dlegendre_schmidt_quasi_normalized","text":"dlegendre_schmidt_quasi_normalized(ϕ::T, n_max::Integer, m_max::Integer = -1, ph_term::Bool = false) where T<:AbstractFloat\n\nCompute the first-order derivative of the Schmidt quasi-normalized associated Legendre function P_n,m[cos(ϕ)] w.r.t. ϕ [rad]:\n\ndP_n,m[cos(ϕ)]\n--------------\n      dϕ\n\nThe maximum degree that will be computed is n_max and the maximum order is m_max. Notice that if m_max is higher than n_max or negative, than it is set to n_max.\n\nIf ph_term is set to true, then the Condon-Shortley phase term (-1)ᵐ will be included. If ph_term is not present, then it defaults to false.\n\nReturns\n\nA matrix with the first-order derivative of the Legendre associated functions P_n,m[cos(ϕ)].\n\n\n\n\n\n","category":"method"},{"location":"lib/library/#SatelliteToolbox.draan","page":"Library","title":"SatelliteToolbox.draan","text":"draan(a::Number, e::Number, i::Number, pert::Symbol = :J2)\ndraan(orb::Orbit, pert::Symbol = :J2)\n\nCompute the time-derivative of the right ascension of the ascending node [rad/s] of an orbit with semi-major axis a [m], eccentricity e, and inclination i [rad], using the perturbation terms specified by the symbol pert. The orbit can also be specified by orb (see Orbit).\n\npert can be:\n\n:J0: Consider a Keplerian orbit.\n:J2: Consider the perturbation terms up to J2.\n:J4: Consider the perturbation terms J2, J4, and J2².\n\nIf pert is omitted, then it defaults to :J2.\n\n\n\n\n\n","category":"function"},{"location":"lib/library/#SatelliteToolbox.ecef_to_geodetic-Tuple{AbstractVector{T} where T}","page":"Library","title":"SatelliteToolbox.ecef_to_geodetic","text":"ecef_to_geodetic(r_e::AbstractVector)\n\nConvert the vector r_e [m] represented in the Earth-Centered, Earth-Fixed (ECEF) reference frame into Geodetic coordinates (WGS-84).\n\nReturns\n\nLatitude [rad].\nLongitude [rad].\nAltitude [m].\n\nRemarks\n\nBased on algorithm in [3].\n\n\n\n\n\n","category":"method"},{"location":"lib/library/#SatelliteToolbox.ecef_to_ned-Tuple{AbstractVector{T} where T, Number, Number, Number}","page":"Library","title":"SatelliteToolbox.ecef_to_ned","text":"ecef_to_ned(r_ecef::AbstractVector, lat::Number, lon::Number, h::Number; translate::Bool = false)\n\nConvert a vector r_ecef represented in the Earth-Centered, Earth-Fixed (ECEF) frame to the local reference frame NED (North, East, Down) at the geodetic position lat [rad], lon [rad], and h [m].\n\nIf translate is false, then this function computes only the rotation between ECEF and NED. Otherwise, it will also translate the vector considering the distance between the Earth's center and NED origin.\n\nRemarks\n\nThis algorithm was based on the information in [1].\n\nReferences\n\n[1] Transformations between ECEF and ENU       coordinates\n\n\n\n\n\n","category":"method"},{"location":"lib/library/#SatelliteToolbox.eclipse_time_summary","page":"Library","title":"SatelliteToolbox.eclipse_time_summary","text":"eclipse_time_summary(JD₀::Number, a::Number, e::Number, i::Number, RAAN::Number, w::Number, Δd::Integer, relative::Bool = false, Δt₀::AbstractFloat = -1.0)\n\nCompute the eclipse time of an orbit with semi-major axis a [m], eccentricity e, inclination i [rad], initial right ascension of the ascending node RAAN [rad], and initial argument of perigee w [rad]. The orbit epoch, which is also the day in which the analysis will begin, is JD₀ [Julian Day]. The analysis will be performed for each day during Δd days.\n\nThis function will compute the eclipse time of one orbit per day.\n\nIf the argument relative is true, then the computed times will be relative to the nodal period [%]. Otherwise, they will be computed in seconds. By default, relative = false.\n\nThe argument Δt₀ can be used to select the time step in which the orbit will be propagated. Notice that this algorithm performs a numerical search to find the beginning of each section (sunlight, penumbra, and umbra) with millisecond precision. Thus, selecting a high number for Δt₀ will make the analysis faster, but the accuracy is lost if a region time span is smalled than Δt₀. If this parameter is omitted or if it is negative, then the time step will be selected automatically to match a mean anomaly step of 5°.\n\nAll the analysis is performed using a J2 orbit propagator.\n\nReturns\n\nThe following table:\n\n    day | Sunlight Time | Penumbra Time | Umbra Time\n   -----+---------------+---------------+------------\n\n\n\n\n\n","category":"function"},{"location":"lib/library/#SatelliteToolbox.equation_of_time-Tuple{Number}","page":"Library","title":"SatelliteToolbox.equation_of_time","text":"equation_of_time(JD::Number)\n\nCompute the difference between the Sun apparent local time and the Sun mean local time [rad], which is called Equation of Time, at the Julian Day JD. The algorithm was adapted from [1, p. 178, 277-279].\n\n\n\n\n\n","category":"method"},{"location":"lib/library/#SatelliteToolbox.expatmosphere-Tuple{Number}","page":"Library","title":"SatelliteToolbox.expatmosphere","text":"expatmosphere(h::Number)\n\nCompute the atmospheric density [kg/m³] at the altitude h [m] (above the ellipsoid) using the exponential atmospheric model:\n\n                ┌            ┐\n                │    h - h₀  │\nρ(h) = ρ₀ ⋅ exp │ - ──────── │ ,\n                │      H     │\n                └            ┘\n\nin which ρ₀, h₀, and H are parameters obtained from tables that depend only on h.\n\n\n\n\n\n","category":"method"},{"location":"lib/library/#SatelliteToolbox.f_to_E-Tuple{Number, Number}","page":"Library","title":"SatelliteToolbox.f_to_E","text":"f_to_E(e::Number,f::Number)\n\nCompute the eccentric anomaly (0,2π) [rad] given the eccentricity e and the true anomaly f [rad].\n\n\n\n\n\n","category":"method"},{"location":"lib/library/#SatelliteToolbox.f_to_M-Tuple{Number, Number}","page":"Library","title":"SatelliteToolbox.f_to_M","text":"f_to_M(e::Number, f::Number)\n\nCompute the mean anomaly (0,2π) [rad] given the eccentricity e and the true anomaly f [rad].\n\n\n\n\n\n","category":"method"},{"location":"lib/library/#SatelliteToolbox.find_crossing-Tuple{Function, Number, Number, Any, Any, Vararg{Any, N} where N}","page":"Library","title":"SatelliteToolbox.find_crossing","text":"find_crossing(f::Function, t₀::Number, t₁::Number, s₀, s₁; Δ = 1e-3, max = 100)\n\nReturn the crossing time tc in which the function f(t) goes from the state s₀ to the state s₁. It is assumed that f(t₀) = s₀ and f(t₁) = s₁.\n\nIf the computed interval is smalled than Δ or if the number of iterations is higher than max, then the algorithm stops.\n\n\n\n\n\n","category":"method"},{"location":"lib/library/#SatelliteToolbox.geocentric_to_geodetic-Tuple{Number, Number}","page":"Library","title":"SatelliteToolbox.geocentric_to_geodetic","text":"geocentric_to_geodetic(ϕ_gc::Number, r::Number)\n\nCompute the geodetic latitude and altitude (WGS-84) from the geocentric latitude ϕ_gc (-π/2, π/2) [rad] and radius r [m]. Notice that the longitude is the same in both geocentric and geodetic coordinates.\n\nReturns\n\nGeodetic latitude [rad].\nAltitude above the reference ellipsoid (WGS-84) [m].\n\nRemarks\n\nBased on algorithm in [5].\n\n\n\n\n\n","category":"method"},{"location":"lib/library/#SatelliteToolbox.geodetic_to_ecef-Tuple{Number, Number, Number}","page":"Library","title":"SatelliteToolbox.geodetic_to_ecef","text":"geodetic_to_ecef(lat::Number, lon::Number, h::Number)\n\nConvert the latitude lat [rad], longitude lon [rad], and altitude h [m] (WGS-84) into a vector represented on the Earth-Centered, Earth-Fixed (ECEF) reference frame.\n\nRemarks\n\nBased on algorithm in [3].\n\n\n\n\n\n","category":"method"},{"location":"lib/library/#SatelliteToolbox.geodetic_to_geocentric-Tuple{Number, Number}","page":"Library","title":"SatelliteToolbox.geodetic_to_geocentric","text":"geodetic_to_geocentric(ϕ_gd::Number, h::Number)\n\nCompute the geocentric latitude and radius from the geodetic latitude ϕ_gd (-π/2, π/2) [rad] and height above the reference ellipsoid h [m] (WGS-84). Notice that the longitude is the same in both geocentric and geodetic coordinates.\n\nReturns\n\nGeocentric latitude [rad].\nRadius from the center of the Earth [m].\n\nRemarks\n\nBased on algorithm in [4, p. 3].\n\n\n\n\n\n","category":"method"},{"location":"lib/library/#SatelliteToolbox.geomag_dipole","page":"Library","title":"SatelliteToolbox.geomag_dipole","text":"geomag_dipole(r_e::AbstractVector, pole_lat::Number, pole_lon::Number, m::Number)\n\nCompute the geomagnetic field [nT] using the simplified dipole model at position r_e (ECEF reference frame). This function considers that the latitude of the South magnetic pole (which lies in the North hemisphere) is pole_lat [rad] and the longitude is pole_lon [rad]. Furthermore, the dipole moment is considered to be m [A.m²].\n\ngeomag_dipole(r_e::AbstractVector, year::Number = 2019)\n\nCompute the geomagnetic field [nT] using the simplified dipole model at position r_e (ECEF reference frame). This function uses the year year to obtain the position of the South magnetic pole (which lies in the North hemisphere) and the dipole moment. If year is omitted, then it will be considered as 2019.\n\nRemarks\n\nIn both functions, the output vector will be represented in the ECEF reference frame.\n\n\n\n\n\n","category":"function"},{"location":"lib/library/#SatelliteToolbox.get_Ap-Tuple{Number}","page":"Library","title":"SatelliteToolbox.get_Ap","text":"get_Ap(JD::Number; mean::Tuple{Int} = (), daily = false)\n\nReturn the Ap index.\n\nIf mean is a tuple of two integers (hi, hf), then the average between hi and hf previous hours will be computed.\n\nIf mean is empty and daily is true, then the day average will be computed.\n\nIf mean keyword is empty, and daily keyword is false, then the Ap at Julian day JD will be computed.\n\nBy default, mean is empty and daily is false.\n\n\n\n\n\n","category":"method"},{"location":"lib/library/#SatelliteToolbox.get_DstΔTc-Tuple{Number}","page":"Library","title":"SatelliteToolbox.get_DstΔTc","text":"get_DstΔTc(JD::Number)\n\nGet the value of the index DstΔTc at Julian Day JD.\n\nThis function requires the initialization of the variable _dtcfile_data. Otherwise, an exception will be raised. To initialize it, run init_space_indices().\n\n\n\n\n\n","category":"method"},{"location":"lib/library/#SatelliteToolbox.get_F10-Tuple{Number}","page":"Library","title":"SatelliteToolbox.get_F10","text":"get_F10(JD::Number)\n\nGet the value of the index F10 at Julian Day JD.\n\nThis function requires the initialization of the variable _solfsmy_data. Otherwise, an exception will be raised. To initialize it, run init_space_indices().\n\n\n\n\n\n","category":"method"},{"location":"lib/library/#SatelliteToolbox.get_F81a-Tuple{Number}","page":"Library","title":"SatelliteToolbox.get_F81a","text":"get_F81a(JD::Number)\n\nGet the value of the index F81a at Julian Day JD.\n\nThis function requires the initialization of the variable _solfsmy_data. Otherwise, an exception will be raised. To initialize it, run init_space_indices().\n\n\n\n\n\n","category":"method"},{"location":"lib/library/#SatelliteToolbox.get_Kp-Tuple{Number}","page":"Library","title":"SatelliteToolbox.get_Kp","text":"get_Kp(JD::Number)\n\nReturn the Kp index at Julian Day JD.\n\n\n\n\n\n","category":"method"},{"location":"lib/library/#SatelliteToolbox.get_M","page":"Library","title":"SatelliteToolbox.get_M","text":"get_M(orb)\n\nReturn the mean anomaly of the representation orb [rad].\n\n\n\n\n\n","category":"function"},{"location":"lib/library/#SatelliteToolbox.get_M10-Tuple{Number}","page":"Library","title":"SatelliteToolbox.get_M10","text":"get_M10(JD::Number)\n\nGet the value of the index M10 at Julian Day JD.\n\nThis function requires the initialization of the variable _solfsmy_data. Otherwise, an exception will be raised. To initialize it, run init_space_indices().\n\n\n\n\n\n","category":"method"},{"location":"lib/library/#SatelliteToolbox.get_M81a-Tuple{Number}","page":"Library","title":"SatelliteToolbox.get_M81a","text":"get_M81a(JD::Number)\n\nGet the value of the index M81a at Julian Day JD.\n\nThis function requires the initialization of the variable _solfsmy_data. Otherwise, an exception will be raised. To initialize it, run init_space_indices().\n\n\n\n\n\n","category":"method"},{"location":"lib/library/#SatelliteToolbox.get_S10-Tuple{Number}","page":"Library","title":"SatelliteToolbox.get_S10","text":"get_S10(JD::Number)\n\nGet the value of the index S10 at Julian Day JD.\n\nThis function requires the initialization of the variable _solfsmy_data. Otherwise, an exception will be raised. To initialize it, run init_space_indices().\n\n\n\n\n\n","category":"method"},{"location":"lib/library/#SatelliteToolbox.get_S81a-Tuple{Number}","page":"Library","title":"SatelliteToolbox.get_S81a","text":"get_S81a(JD::Number)\n\nGet the value of the index S81a at Julian Day JD.\n\nThis function requires the initialization of the variable _solfsmy_data. Otherwise, an exception will be raised. To initialize it, run init_space_indices().\n\n\n\n\n\n","category":"method"},{"location":"lib/library/#SatelliteToolbox.get_Y10-Tuple{Number}","page":"Library","title":"SatelliteToolbox.get_Y10","text":"get_Y10(JD::Number)\n\nGet the value of the index Y10 at Julian Day JD.\n\nThis function requires the initialization of the variable _solfsmy_data. Otherwise, an exception will be raised. To initialize it, run init_space_indices().\n\n\n\n\n\n","category":"method"},{"location":"lib/library/#SatelliteToolbox.get_Y81a-Tuple{Number}","page":"Library","title":"SatelliteToolbox.get_Y81a","text":"get_Y81a(JD::Number)\n\nGet the value of the index Y81a at Julian Day JD.\n\nThis function requires the initialization of the variable _solfsmy_data. Otherwise, an exception will be raised. To initialize it, run init_space_indices().\n\n\n\n\n\n","category":"method"},{"location":"lib/library/#SatelliteToolbox.get_a","page":"Library","title":"SatelliteToolbox.get_a","text":"get_a(orb)\n\nReturn the semi-major axis of the orbit representation orb [m].\n\n\n\n\n\n","category":"function"},{"location":"lib/library/#SatelliteToolbox.get_argp-Tuple{Any}","page":"Library","title":"SatelliteToolbox.get_argp","text":"get_argp(orb)\n\nReturn the argument of periapsis of the representation orb [rad].\n\n\n\n\n\n","category":"method"},{"location":"lib/library/#SatelliteToolbox.get_e","page":"Library","title":"SatelliteToolbox.get_e","text":"get_e(orb)\n\nReturn the eccentricity of the orbit representation orb.\n\n\n\n\n\n","category":"function"},{"location":"lib/library/#SatelliteToolbox.get_epoch","page":"Library","title":"SatelliteToolbox.get_epoch","text":"get_epoch(orbp)\n\nReturn the epoch of the propagator orbp [JD].\n\n\n\n\n\n","category":"function"},{"location":"lib/library/#SatelliteToolbox.get_epoch-Tuple{Any}","page":"Library","title":"SatelliteToolbox.get_epoch","text":"get_epoch(orb)\n\nReturn the epoch of the orbit representation orb [m].\n\n\n\n\n\n","category":"method"},{"location":"lib/library/#SatelliteToolbox.get_f","page":"Library","title":"SatelliteToolbox.get_f","text":"get_f(orb)\n\nReturn the true anomaly of the representation orb [rad].\n\n\n\n\n\n","category":"function"},{"location":"lib/library/#SatelliteToolbox.get_i","page":"Library","title":"SatelliteToolbox.get_i","text":"get_i(orb)\n\nReturn the inclination of the orbit representation orb [rad].\n\n\n\n\n\n","category":"function"},{"location":"lib/library/#SatelliteToolbox.get_iers_eop","page":"Library","title":"SatelliteToolbox.get_iers_eop","text":"get_iers_eop(data_type::Symbol = :IAU1980; force_download = false)\n\nDownload and parse the IERS EOP C04 data. The data type is specified by data_type symbol. Supported values are:\n\nIAU1980: Get IERS EOP C04 IAU1980 data.\nIAU2000A: Get IERS EOP C04 IAU2000A data.\n\nIf data_type is omitted, then it defaults to IAU1980.\n\nThe files are downloaded using the RemoteFile package with daily updates. Hence, if one desires to force a download before the scheduled time, then set the keyword force_download to true.\n\nReturns\n\nA structure (EOPData_IAU1980 or EOPData_IAU2000A, depending on data_type) with the interpolations of the EOP parameters. Notice that the interpolation indexing is set to the Julian Day.\n\n\n\n\n\n","category":"function"},{"location":"lib/library/#SatelliteToolbox.get_iers_eop_iau_1980","page":"Library","title":"SatelliteToolbox.get_iers_eop_iau_1980","text":"get_iers_eop_iau_1980(url::String = \"https://datacenter.iers.org/data/latestVersion/223_EOP_C04_14.62-NOW.IAU1980223.txt\")\n\nGet the IERS EOP C04 IAU1980 data from the URL url. If url is omitted, then it defaults to https://datacenter.iers.org/data/latestVersion/223EOPC04_14.62-NOW.IAU1980223.txt\n\nThe file is downloaded using the RemoteFile package with daily updates. Hence, if one desires to force a download before the scheduled time, then set the keyword force_download to true.\n\nReturns\n\nThe structure EOPData_IAU1980 with the interpolations of the EOP parameters. Notice that the interpolation indexing is set to the Julian Day.\n\nRemarks\n\nFor every field in EOPData_IAU1980 to interpolation between two points in the grid is linear. If extrapolation is needed, then if will use the nearest value (flat extrapolation).\n\n\n\n\n\n","category":"function"},{"location":"lib/library/#SatelliteToolbox.get_iers_eop_iau_2000A","page":"Library","title":"SatelliteToolbox.get_iers_eop_iau_2000A","text":"get_iers_eop_iau_2000A(url::String = \"https://datacenter.iers.org/data/latestVersion/224_EOP_C04_14.62-NOW.IAU2000A224.txt\"; force_download = false)\n\nGet the IERS EOP C04 IAU2000A data from the URL url. If url is omitted, then it defaults to https://datacenter.iers.org/data/latestVersion/224EOPC04_14.62-NOW.IAU2000A224.txt\n\nThe file is downloaded using the RemoteFile package with daily updates. Hence, if one desires to force a download before the scheduled time, then set the keyword force_download to true.\n\nReturns\n\nThe structure EOPData_IAU2000A with the interpolations of the EOP parameters. Notice that the interpolation indexing is set to the Julian Day.\n\nRemarks\n\nFor every field in EOPData_IAU2000A to interpolation between two points in the grid is linear. If extrapolation is needed, then if will use the nearest value (flat extrapolation).\n\n\n\n\n\n","category":"function"},{"location":"lib/library/#SatelliteToolbox.get_mean_elements-Tuple{OrbitPropagator}","page":"Library","title":"SatelliteToolbox.get_mean_elements","text":"get_mean_elements(orbp)\n\nReturn the mean elements of the latest propagation performed by orbp. This is an optinal function in the API. It will return nothing if the propagator does not support it.\n\n\n\n\n\n","category":"method"},{"location":"lib/library/#SatelliteToolbox.get_r","page":"Library","title":"SatelliteToolbox.get_r","text":"get_r(orb)\n\nReturn the position vector of the representation orb [m].\n\n\n\n\n\n","category":"function"},{"location":"lib/library/#SatelliteToolbox.get_raan-Tuple{Any}","page":"Library","title":"SatelliteToolbox.get_raan","text":"get_raan(orb)\n\nReturn the right ascention of the ascending node (RAAN) of the orbit representation orb [rad].\n\n\n\n\n\n","category":"method"},{"location":"lib/library/#SatelliteToolbox.get_rv","page":"Library","title":"SatelliteToolbox.get_rv","text":"get_rv(orb)\n\nReturn the position and velocity vector of the representation orb [m].\n\n\n\n\n\n","category":"function"},{"location":"lib/library/#SatelliteToolbox.get_space_index-Tuple{Val{:F10}, Number}","page":"Library","title":"SatelliteToolbox.get_space_index","text":"get_space_index(T, JD::Number; ...)\n\nReturn the space index T at the day JD [Julian Day]. T can be:\n\nDaily 10.7-cm solar flux\n\nThe daily 10.7-cm solar flux can be obtained using:\n\nF10(): 10.7-cm adjusted solar flux [10⁻²² W/(M² Hz)].\nF10adj(): 10.7-cm adjusted solar flux [10⁻²² W/(M² Hz)].\nF10obs(): 10.7-cm observed solar flux [10⁻²² W/(M² Hz)].\n\nThese indices require fluxtable (see init_space_indices).\n\nDaily average 10.7-cm solar flux\n\nThe daily average 10.7-cm solar flux, centered at JD, can be obtained using:\n\nF10M(): 10.7-cm adjusted solar flux [10⁻²² W/(M² Hz)].\nF10Madj(): 10.7-cm adjusted solar flux [10⁻²² W/(M² Hz)].\nF10Mobs(): 10.7-cm observed solar flux [10⁻²² W/(M² Hz)].\n\nIn this case, the keyword window::Int can be passed to select the size of the window. By default, it is selected as 81.\n\nThese indices require fluxtable (see init_space_indices).\n\nDaily Kp and Ap\n\nKp(): Kp index (daily mean).\nKp_vect(): A vector containing the Kp index for the following hours of the              day: 0-3h, 3-6h, 6-9h, 9-12h, 12-15h, 15-18h, 18-20h, 20-23h.\nAp(): Ap index (daily mean).\nAp_vect(): A vector containing the Ap index for the following hours of the              day: 0-3h, 3-6h, 6-9h, 9-12h, 12-15h, 15-18h, 18-20h, 20-23h.\n\nThese indices require wdcfiles (see init_space_indices).\n\nDaily S10, M10, and Y10\n\nS10(): EUV index (26-34 nm) scaled to F10.7.\nM10(): MG2 index scaled to F10.7.\nY10(): Solar X-ray & Lya index scaled to F10.7.\n\nThese indices require solfsmy (see init_space_indices).\n\n81-day centered average of S10, M10, and Y10.\n\nS81a: EUV 81-day averaged centered index.\nM81a: MG2 81-day averaged centered index.\nY81a: Solar X-ray & Lya 81-day averaged centered index.\n\nThese indices require solfsmy (see init_space_indices).\n\nExospheric temperature variation due to Dst\n\nDstΔTc: Exospheric temperature variation due to Dst [K].\n\nThis index requires dtcfile (see init_space_indices).\n\n\n\n\n\n","category":"method"},{"location":"lib/library/#SatelliteToolbox.get_v","page":"Library","title":"SatelliteToolbox.get_v","text":"get_r(orb)\n\nReturn the velocity vector of the representation orb [m].\n\n\n\n\n\n","category":"function"},{"location":"lib/library/#SatelliteToolbox.get_Δat-Tuple{Number}","page":"Library","title":"SatelliteToolbox.get_Δat","text":"get_Δat(JD::Number)\n\nGet the accumulated leap seconds (ΔAT) [s] between UTC and International Atomic Time (TAI) in the given JD. This function search for ΔAT in the array ΔAT_Data.\n\nRemarks\n\nIf JD is before ΔAT_Data[1,1], then 10 will be returned. Notice that this can lead to errors.\n\nIf JD is after ΔAT_Data[end,1], then ΔAT_Data[end,2] will be returned, because it is not possible yet to predict when leap seconds will be added.\n\n\n\n\n\n","category":"method"},{"location":"lib/library/#SatelliteToolbox.get_Ω","page":"Library","title":"SatelliteToolbox.get_Ω","text":"get_Ω(orb)\n\nReturn the right ascention of the ascending node (RAAN) of the orbit representation orb [rad].\n\n\n\n\n\n","category":"function"},{"location":"lib/library/#SatelliteToolbox.get_ω","page":"Library","title":"SatelliteToolbox.get_ω","text":"get_ω(orb)\n\nReturn the argument of periapsis of the representation orb [rad].\n\n\n\n\n\n","category":"function"},{"location":"lib/library/#SatelliteToolbox.ground_station_accesses-Tuple{Any, Tuple, Vararg{Any, N} where N}","page":"Library","title":"SatelliteToolbox.ground_station_accesses","text":"ground_station_accesses(orbp, vrs_e,     Δt, ECI, ECEF, vargs...; kwargs...)\nground_station_accesses(orbp, [(WGS84)], Δt, ECI, ECEF, vargs...; kwargs...)\n\nCompute the accesses of a satellite with orbit propagator orbp (see init_orbit_propagator) to the ground stations defined in the vector vrs_e. The analysis interval begins in the propagator epoch and lasts Δt [s].\n\nThe ground stations can be specified by an array of 3×1 vectors describing the ground stations position in an ECEF frame vrs_e or by an array of tuples containing the WGS84 position of each ground station [(WGS84)]:\n\n(latitude [rad], longitude [rad], altitude [m])\n\nArgs\n\nECI: Earth-Centered Inertial frame in which the state vector of the        propagator is represented.\nECEF: Earth-Centered, Earth-fixed frame to be used for the analysis. It         must be the same frame used to compute the ground station position         vector.\nvargs...: list of additional arguments to be passed to the function             r_eci_to_ecef when converting the ECI frame to the ECEF.\n\nKeywords\n\nθ: Minimum elevation angle for communication between the satellite and the      ground stations [rad]. (Default = 10ᵒ)\nreduction: A function that receives a boolean vector with the visibility              between the satellite and each ground station. It must return a              boolean value indicating if the access must be computed or not.              This is useful to merge access time between two or more stations.              (Default = v->|(v...) i.e. compute the access if at least              one ground station is visible)\n\n\n\n\n\n","category":"method"},{"location":"lib/library/#SatelliteToolbox.ground_station_gaps-Tuple{Any, Vararg{Any, N} where N}","page":"Library","title":"SatelliteToolbox.ground_station_gaps","text":"ground_station_gaps(args...; kwargs...)\n\nCompute the gaps between the accesses of ground stations. The arguments and keywords are the same as the ones used in the function ground_station_accesses.\n\nNotice that the gap analysis starts in the orbit propagator epoch and ends in the instant defined by the argument Δt.\n\n\n\n\n\n","category":"method"},{"location":"lib/library/#SatelliteToolbox.ground_station_visible-Tuple{AbstractVector{T} where T, AbstractVector{T} where T, Number}","page":"Library","title":"SatelliteToolbox.ground_station_visible","text":"ground_station_visible(r_e::AbstractVector, rs_e::AbstractVector, θ::Number)\n\nCheck if the satellite with position vector r_e (ECEF) is inside the visibility circle of a ground station with position vector rs_e (ECEF) and a minimum elevation angle of θ [rad].\n\nNotice that r_e and rs_e must be represented in the same ECEF frame, and must have the same unit.\n\nReturns true if the satellite is inside the visibility circle, or false otherwise.\n\n\n\n\n\n","category":"method"},{"location":"lib/library/#SatelliteToolbox.ground_station_visible-Tuple{AbstractVector{T} where T, Number, Number, Number, Number}","page":"Library","title":"SatelliteToolbox.ground_station_visible","text":"ground_station_visible(r_e::AbstractVector, lat_s::Number, lon_s::Number, h_s::Number, θ::Number)\n\nCheck if the satellite with position vector r_e (ECEF) is inside the visibility circle of a ground station with latitude lat_s [rad], longitude lon_s [rad], altitude h_s (WGS-84), and a minimum elevation angle of θ [rad].\n\nNotice that the units of r_e and h_s must be the same.\n\nReturns true if the satellite is inside the visibility circle, or false otherwise.\n\n\n\n\n\n","category":"method"},{"location":"lib/library/#SatelliteToolbox.ground_trace-Tuple{OrbitPropagator, Number}","page":"Library","title":"SatelliteToolbox.ground_trace","text":"ground_trace(orbp::OrbitPropagator, Δt::Number; kwargs...)\n\nCompute the ground trace of the object with orbit defined by orbp by propagating the orbit by Δt [s] from the orbit epoch.\n\nBy default, it considers that the orbit elements on the propagator are represented in the True Equator, Mean Equinox (TEME) reference frame and the ground trace will be computed in the Pseudo-Earth Fixed (PEF) reference frame. Hence, no EOP data is needed. However, this can be changed by the keywords presented as follows.\n\nKeywords\n\neop_data: EOP data that will be used to convert the ECI reference frame to             the ECEF reference frame. If nothing, then it will not be used             (see r_eci_to_ecef). (Default = nothing)\nECI: ECI frame in which the orbit elements in orbp are represented.        (Default = TEME())\nECEF: ECEF frame that will be used to compute the ground trace.         (Default = PEF())\ndt: Time interval between two samples [s]. (Default = 10.0)\n\nReturns\n\nA vector of tuples with the pairs (latitude,longitude) of the ground trace.\n\n\n\n\n\n","category":"method"},{"location":"lib/library/#SatelliteToolbox.gtd7-Union{Tuple{NRLMSISE00_Structure{T}}, Tuple{T}} where T<:Number","page":"Library","title":"SatelliteToolbox.gtd7","text":"gtd7(nrlmsise00d::NRLMSISE00_Structure{T}) where T<:Number\n\nNRLMSISE-00\n\nNeutral Atmosphere Empirical Model from the surface to lower exosphere.\n\nThis routine computes the NRLMSISE-00 outputs (see NRLMSISE00_Output) using the configurations in the structure nrlmsise00 (see NRLMSISE00_Structure).\n\nArgs\n\nnrlmsise00d: An instance of NRLMSISE00_Structure.\n\nReturns\n\nAn instance of structure NRLMSISE00_Output with the outputs.\n\nIn this case, the total mass den_Total (see NRLMSISE00_Output) is the sum of the mass densities of the species He, O, N₂, O₂, Ar, H, and N, but does not include anomalous oxygen.\n\nRemarks\n\nThe densities of O, H, and N are set to 0 below 72.5 km.\nThe exospheric temperature T_exo is set to global average for altitudes below 120 km. The 120 km gradient is left at global average value for altitudes below 72.5 km.\nAnomalous oxygen is defined as hot atomic oxygen or ionized oxygen that can become appreciable at high altitudes (> 500 km) for some ranges of inputs, thereby affection drag on satellites and debris. We group these species under the term Anomalous Oxygen, since their individual variations are not presently separable with the drag data used to define this model component.\n\n\n\n\n\n","category":"method"},{"location":"lib/library/#SatelliteToolbox.gtd7d-Union{Tuple{NRLMSISE00_Structure{T}}, Tuple{T}} where T<:Number","page":"Library","title":"SatelliteToolbox.gtd7d","text":"gtd7d(nrlmsise00d::NRLMSISE00_Structure{T}) where T<:Number\n\nNRLMSISE-00\n\nNeutral Atmosphere Empirical Model from the surface to lower exosphere.\n\nThis routine computes the NRLMSISE-00 outputs (see NRLMSISE00_Output) using the configurations in the structure nrlmsise00 (see NRLMSISE00_Structure).\n\nArgs\n\nnrlmsise00d: An instance of NRLMSISE00_Structure.\n\nReturns\n\nAn instance of structure NRLMSISE00_Output with the outputs.\n\nIn this case, the total mass den_Total (see NRLMSISE00_Output) is the effective total mass density for drag and is the sum of the mass densities of all species in this model including the anomalous oxygen.\n\nRemarks\n\nThe densities of O, H, and N are set to 0 below 72.5 km.\nThe exospheric temperature T_exo is set to global average for altitudes below 120 km. The 120 km gradient is left at global average value for altitudes below 72.5 km.\nAnomalous oxygen is defined as hot atomic oxygen or ionized oxygen that can become appreciable at high altitudes (> 500 km) for some ranges of inputs, thereby affection drag on satellites and debris. We group these species under the term Anomalous Oxygen, since their individual variations are not presently separable with the drag data used to define this model component.\n\n\n\n\n\n","category":"method"},{"location":"lib/library/#SatelliteToolbox.gts7-Union{Tuple{NRLMSISE00_Structure{T}}, Tuple{T}} where T<:Number","page":"Library","title":"SatelliteToolbox.gts7","text":"gts7(nrlmsise00d::NRLMSISE00_Structure{T}) where T<:Number\n\nThermospheric portion of NRLMSISE-00. This function should not be called to compute NRLMSISE-00. Use gtd7 or gtd7d instead.\n\nArgs\n\nnrlmsise00d: An instance of NRLMSISE00_Structure.\n\nReturns\n\nAn instance of structure NRLMSISE00_Structure with the outputs.\n\n\n\n\n\n","category":"method"},{"location":"lib/library/#SatelliteToolbox.igrf-NTuple{4, Number}","page":"Library","title":"SatelliteToolbox.igrf","text":"igrf(date::Number, [r,h]::Number, λ::Number, Ω::Number, T[, P, dP]; show_warns = true)\n\nIGRF Model\n\nCurrent version: v13\n\nCompute the geomagnetic field vector [nT] at the date date [Year A.D.] and position (r, λ, Ω).\n\nThe position representation is defined by T. If T is Val(:geocentric), then the input must be geocentric coordinates:\n\nDistance from the Earth center r [m];\nGeocentric latitude λ (-π/2, +π/2) [rad]; and\nGeocentric longitude Ω (-π, +π) [rad].\n\nIf T is Val(:geodetic), then the input must be geodetic coordinates:\n\n1 Altitude above the reference ellipsoid h (WGS-84) [m];\n\nGeodetic latitude λ (-π/2, +π/2) [rad]; and\nGeodetic longitude Ω (-π, +π) [rad].\n\nIf T is omitted, then it defaults to Val(:geocentric).\n\nNotice that the output vector will be represented in the same reference system selected by the parameter T (geocentric or geodetic). The Y-axis of the output reference system always points East. In case of geocentric coordinates, the Z-axis points toward the center of Earth and the X-axis completes a right-handed coordinate system. In case of geodetic coordinates, the X-axis is tangent to the ellipsoid at the selected location and points toward North, whereas the Z-axis completes a right-hand coordinate system.\n\nThe optional arguments P and dP must be two matrices with at least 14x14 real numbers. If they are present, then they will be used to store the Legendre coefficients and their derivatives. In this case, no allocation will be performed when computing the magnetic field. If they are not present, then 2 allocations will happen to create them.\n\nKeywords\n\nshow_warns: Show warnings about the data (Default = true).\n\nRemarks\n\nThe date must be greater or equal to 1900 and less than or equal 2030. Notice that a warning message is printed for dates greater than 2025.\n\nDisclaimer\n\nThis function is an independent implementation of the IGRF model. It contains a more readable code than the original one in FORTRAN, because it uses features available in Julia language.\n\n\n\n\n\n","category":"method"},{"location":"lib/library/#SatelliteToolbox.igrf12syn-Tuple{Int64, Number, Int64, Number, Number, Number}","page":"Library","title":"SatelliteToolbox.igrf12syn","text":"igrf12syn(isv::Int, date::Number, itype::Int, alt::Number, colat::Number, elong::Number; show_warns = true)\n\nThis is a Julia implementation of the official IGRF source code, which was written in Fortran [2]. The input and output variables are exactly the same as the ones described in the function igrf12syn in [2].\n\nArgs\n\nisv: 0 if main-field values are required, 1 if secular variation values        are required.\ndate: Year A.D.\nitype: 1 if geodetic (spheroid), 2 if geocentric (sphere).\nalt: Height above sea level [km] if itype = 1, or distance from the center of        Earth [km] if itype = 2 (must be > 3485 km).\ncolat: Colatitude (0 - 180) [˚].\nelong: East-Longitude (0 - 360) [˚].\n\nKeywords\n\nshow_warns: Show warnings about the data (Default = true).\n\nReturns\n\nThe north component [nT] if isv = 0, or [nT/year] if isv = 1.\nThe east component [nT] if isv = 0, or [nT/year] if isv = 1.\nThe vertical component [nT] if isv = 0, or [nT/year] if isv = 1.\nThe total intensity if isv = 0, or rubbish if isv = 1.\n\nRemarks\n\nThe date must be greater or equal to 1900 and less than or equal 2025. Notice that a warning message is printed for dates grated than 2020.\n\n\n\n\n\n","category":"method"},{"location":"lib/library/#SatelliteToolbox.igrf13syn-Tuple{Int64, Number, Int64, Number, Number, Number}","page":"Library","title":"SatelliteToolbox.igrf13syn","text":"igrf13syn(isv::Int, date::Number, itype::Int, alt::Number, colat::Number, elong::Number; show_warns = true)\n\nThis is a Julia implementation of the official IGRF source code, which was written in Fortran [2]. The input and output variables are exactly the same as the ones described in the function igrf13syn in [2].\n\nArgs\n\nisv: 0 if main-field values are required, 1 if secular variation values        are required.\ndate: Year A.D.\nitype: 1 if geodetic (spheroid), 2 if geocentric (sphere).\nalt: Height above sea level [km] if itype = 1, or distance from the center of        Earth [km] if itype = 2 (must be > 3485 km).\ncolat: Colatitude (0 - 180) [˚].\nelong: East-Longitude (0 - 360) [˚].\n\nKeywords\n\nshow_warns: Show warnings about the data (Default = true).\n\nReturns\n\nThe north component [nT] if isv = 0, or [nT/year] if isv = 1.\nThe east component [nT] if isv = 0, or [nT/year] if isv = 1.\nThe vertical component [nT] if isv = 0, or [nT/year] if isv = 1.\nThe total intensity if isv = 0, or rubbish if isv = 1.\n\nRemarks\n\nThe date must be greater or equal to 1900 and less than or equal 2030. Notice that a warning message is printed for dates grated than 2025.\n\n\n\n\n\n","category":"method"},{"location":"lib/library/#SatelliteToolbox.igrfd-NTuple{4, Number}","page":"Library","title":"SatelliteToolbox.igrfd","text":"igrfd(date::Number, [r,h]::Number, λ::Number, Ω::Number, T[, P, dP]; show_warns = true)\n\nIGRF Model\n\nCurrent version: v13\n\nCompute the geomagnetic field vector [nT] at the date date [Year A.D.] and position (r, λ, Ω).\n\nThe position representation is defined by T. If T is Val(:geocentric), then the input must be geocentric coordinates:\n\nDistance from the Earth center r [m];\nGeocentric latitude λ (-90°, +90°); and\nGeocentric longitude Ω (-180°, +180°).\n\nIf T is Val(:geodetic), then the input must be geodetic coordinates:\n\n1 Altitude above the reference ellipsoid h (WGS-84) [m];\n\nGeodetic latitude λ (-90°, +90°); and\nGeodetic longitude Ω (-180°, +180°).\n\nIf T is omitted, then it defaults to Val(:geocentric).\n\nNotice that the output vector will be represented in the same reference system selected by the parameter T (geocentric or geodetic). The Y-axis of the output reference system always points East. In case of geocentric coordinates, the Z-axis points toward the center of Earth and the X-axis completes a right-handed coordinate system. In case of geodetic coordinates, the X-axis is tangent to the ellipsoid at the selected location and points toward North, whereas the Z-axis completes a right-hand coordinate system.\n\nThe optional arguments P and dP must be two matrices with at least 14x14 real numbers. If they are present, then they will be used to store the Legendre coefficients and their derivatives. In this case, no allocation will be performed when computing the magnetic field. If they are not present, then 2 allocations will happen to create them.\n\nKeywords\n\nshow_warns: Show warnings about the data (Default = true).\n\nRemarks\n\nThe date must be greater or equal to 1900 and less than or equal 2030. Notice that a warning message is printed for dates greater than 2025.\n\nDisclaimer\n\nThis function is an independent implementation of the IGRF model. It contains a more readable code than the original one in FORTRAN, because it uses features available in Julia language.\n\n\n\n\n\n","category":"method"},{"location":"lib/library/#SatelliteToolbox.init_orbit_propagator","page":"Library","title":"SatelliteToolbox.init_orbit_propagator","text":"init_orbit_propagator(T, args...; kwargs...)\n\nInitialize the orbit propagator of type T. The arguments args and keywords kwargs depends of the propagator type.\n\n\n\n\n\n","category":"function"},{"location":"lib/library/#SatelliteToolbox.init_orbit_propagator-Union{Tuple{T}, Tuple{Val{:J2osc}, Number, Number, Number, Number, Number, Number, Number}, Tuple{Val{:J2osc}, Number, Number, Number, Number, Number, Number, Number, Number}, Tuple{Val{:J2osc}, Number, Number, Number, Number, Number, Number, Number, Number, Number}} where T","page":"Library","title":"SatelliteToolbox.init_orbit_propagator","text":"init_orbit_propagator(Val(:J2osc), epoch::Number, a_0::Number, e_0::Number, i_0::Number, Ω_0::Number, ω_0::Number, f_0::Number, dn_o2::Number = 0, ddn_o6::Number = 0; j2_gc::J2_GravCte{T} = j2_gc_egm08) where T\ninit_orbit_propagator(Val(:J2osc), orb_0::Orbit, dn_o2::Number = 0, ddn_o6::Number = 0; j2_gc::J2_GravCte = j2_gc_egm08)\n\nInitialize the J2 osculating orbit propagator.\n\nArgs\n\nepoch: Initial orbit epoch [Julian Day].\na_0: Initial mean semi-major axis [m].\ne_0: Initial mean eccentricity.\ni_0: Initial mean inclination [rad].\nΩ_0: Initial mean right ascension of the ascending node [rad].\nω_0: Initial mean argument of perigee [rad].\nf_0: Initial mean true anomaly [rad].\ndn_o2: (OPTIONAL) First time derivative of mean motion divided by 2          [rad/s²] (Default = 0).\nddn_o6: (OPTIONAL) Second time derivative of mean motion divided by 6           [rad/s³] (Default = 0).\norb_0: Instance of the structure KeplerianElements with the initial mean          orbital elements [SI].\n\nKeywords\n\nj2_gc: (OPTIONAL) J2 orbit propagator gravitational constants          (Default = j2_gc_egm08).\n\n\n\n\n\n","category":"method"},{"location":"lib/library/#SatelliteToolbox.init_orbit_propagator-Union{Tuple{T}, Tuple{Val{:J2}, Number, Number, Number, Number, Number, Number, Number}, Tuple{Val{:J2}, Number, Number, Number, Number, Number, Number, Number, Number}, Tuple{Val{:J2}, Number, Number, Number, Number, Number, Number, Number, Number, Number}} where T","page":"Library","title":"SatelliteToolbox.init_orbit_propagator","text":"init_orbit_propagator(Val(:J2), epoch::Number, a_0::Number, e_0::Number, i_0::Number, Ω_0::Number, ω_0::Number, f_0::Number, dn_o2::Number = 0, ddn_o6::Number = 0; j2_gc::J2_GravCte{T} = j2_gc_egm08) where T\ninit_orbit_propagator(Val(:J2), orb_0::Orbit, dn_o2::Number = 0, ddn_o6::Number = 0; j2_gc::J2_GravCte = j2_gc_egm08)\n\nInitialize the J2 orbit propagator.\n\nArgs\n\nepoch: Initial orbit epoch [Julian Day].\na_0: Initial mean semi-major axis [m].\ne_0: Initial mean eccentricity.\ni_0: Initial mean inclination [rad].\nΩ_0: Initial mean right ascension of the ascending node [rad].\nω_0: Initial mean argument of perigee [rad].\nf_0: Initial mean true anomaly [rad].\ndn_o2: (OPTIONAL) First time derivative of mean motion divided by 2          [rad/s²] (Default = 0).\nddn_o6: (OPTIONAL) Second time derivative of mean motion divided by 6           [rad/s³] (Default = 0).\norb_0: Instance of the structure KeplerianElements with the initial mean          orbital elements [SI].\n\nKeywords\n\nj2_gc: (OPTIONAL) J2 orbit propagator gravitational constants          (Default = j2_gc_egm08).\n\n\n\n\n\n","category":"method"},{"location":"lib/library/#SatelliteToolbox.init_orbit_propagator-Union{Tuple{T}, Tuple{Val{:J4}, Number, Number, Number, Number, Number, Number, Number}, Tuple{Val{:J4}, Number, Number, Number, Number, Number, Number, Number, Number}, Tuple{Val{:J4}, Number, Number, Number, Number, Number, Number, Number, Number, Number}} where T","page":"Library","title":"SatelliteToolbox.init_orbit_propagator","text":"init_orbit_propagator(Val(:J4), epoch::Number, a_0::Number, e_0::Number, i_0::Number, Ω_0::Number, ω_0::Number, f_0::Number, dn_o2::Number = 0, ddn_o6::Number = 0; j4_gc::J4_GravCte{T} = j4_gc_egm08) where T\ninit_orbit_propagator(Val(:J4), orb_0::Orbit, dn_o2::Number = 0, ddn_o6::Number = 0; j4_gc::J4_GravCte = j4_gc_egm08)\n\nInitialize the J4 orbit propagator.\n\nArgs\n\nepoch: Initial orbit epoch [Julian Day].\na_0: Initial mean semi-major axis [m].\ne_0: Initial mean eccentricity.\ni_0: Initial mean inclination [rad].\nΩ_0: Initial mean right ascension of the ascending node [rad].\nω_0: Initial mean argument of perigee [rad].\nf_0: Initial mean true anomaly [rad].\ndn_o2: (OPTIONAL) First time derivative of mean motion divided by 2          [rad/s²] (Default = 0).\nddn_o6: (OPTIONAL) Second time derivative of mean motion divided by 6           [rad/s³] (Default = 0).\norb_0: Instance of the structure KeplerianElements with the initial mean          orbital elements [SI].\n\nKeywords\n\nj4_gc: (OPTIONAL) J4 orbit propagator gravitational constants          (Default = j4_gc_egm08).\n\n\n\n\n\n","category":"method"},{"location":"lib/library/#SatelliteToolbox.init_orbit_propagator-Union{Tuple{T}, Tuple{Val{:sgp4}, TLE}} where T","page":"Library","title":"SatelliteToolbox.init_orbit_propagator","text":"init_orbit_propagator(Val(:sgp4), tle::TLE, sgp4_gc::SGP4_GravCte{T} = sgp4_gc_wgs84) where T\n\nInitialize the SGP4 orbit propagator using the TLE tle.\n\nKeywords\n\nsgp4_gc: (OPTIONAL) Gravitational constants. (Default = sgp4_gc_wgs84)\n\n\n\n\n\n","category":"method"},{"location":"lib/library/#SatelliteToolbox.init_orbit_propagator-Union{Tuple{T}, Tuple{Val{:twobody}, Number, Number, Number, Number, Number, Number, Number}} where T","page":"Library","title":"SatelliteToolbox.init_orbit_propagator","text":"init_orbit_propagator(::Val{:twobody}, epoch::Number, a_0::Number, e_0::Number, i_0::Number, Ω_0::Number, ω_0::Number, f_0::Number; μ::T = m0) where T\n\nInitialize the two body orbit propagator.\n\nArgs\n\nepoch: Initial orbit epoch [Julian Day].\na_0: Initial mean semi-major axis [m].\ne_0: Initial mean eccentricity.\ni_0: Initial mean inclination [rad].\nΩ_0: Initial mean right ascension of the ascending node [rad].\nω_0: Initial mean argument of perigee [rad].\nf_0: Initial mean true anomaly [rad].\norb_0: Instance of the structure KeplerianElements with the initial mean          orbital elements [SI].\n\nKeywords\n\nμ: (OPTIONAL) Standard gravitational parameter of the central body      [m^3/s^2] (Default = m0).\n\n\n\n\n\n","category":"method"},{"location":"lib/library/#SatelliteToolbox.init_space_indices-Tuple{}","page":"Library","title":"SatelliteToolbox.init_space_indices","text":"init_space_indices(...)\n\nInitialize all space indices. The files that will be initialized must be indicated by the array of symbols passed to the keyword argument enabled_files. If this is nothing, which is the default, then all files will be initialized. The symbol related to each file is described next.\n\nNotice that the initialization process can be changed by a set of keywords as described next.\n\nDTCFILE\n\nSymbol: :dtcfile\n\nThis file contains the exospheric temperature variation caused by the Dst index. This is used for the JB2008 atmospheric model.\n\nKeywords\n\ndtcfile_path: Path for the file DTCFILE.TXT. If nothing, then it will be                 downloaded. (Default = nothing)\ndtcfile_force_download: If true, then the file will always be downloaded                           if the path is not specified. (Default =                           false).\n\nfluxtable\n\nSymbol: :fluxtable\n\nThis file contains the F10.7 flux data in different formats.\n\nKeywords\n\nfluxtable_path: Path for the file fluxtable.txt. If nothing, then it                   will be downloaded. (Default = nothing)\nfluxtable_force_download: If true, then the file will always be downloaded                             if the path is not specified.                             (Default = false).\n\nSOLFSMY\n\nSymbol: :solfsmy\n\nThis files contains the indices necessary for the JB2008 atmospheric model.\n\nKeywords\n\nsolfsmy_path: Path for the file SOLFSMY.TXT. If nothing, then it will be                 downloaded. (Default = nothing)\nsolfsmy_force_download: If true, then the file will always be downloaded                           if the path is not specified. (Default =                           false).\n\nWDC Files\n\nSymbol: :wdcfiles\n\nThis set of files contain the Kp and Ap indices.\n\nKeywords\n\nwdcfiles_path: Path for the directory with the WDC files. If nothing, then                  they will be downloaded. (Default = nothing)\nwdcfiles_force_download: If true, then the files will always be downloaded                           if the path is not specified. (Default =                           false).\nwdcfiles_oldest_year: Oldest year in which the WDC file will be obtained.                         (Default = past 3 years).\nwdcfiles_newest_year: Newest year in which the WDC file will be obtained. If                         it is nothing, then it defaults to the current year.                         (Default = nothing).\n\n\n\n\n\n","category":"method"},{"location":"lib/library/#SatelliteToolbox.is_leap_year-Tuple{Integer}","page":"Library","title":"SatelliteToolbox.is_leap_year","text":"is_leap_year(year::Integer)\n\nCheck if the year year is a leap year. It returns true if year is a leap year, or false otherwise.\n\nRemarks\n\nThis algorithm was based on [3].\n\n\n\n\n\n","category":"method"},{"location":"lib/library/#SatelliteToolbox.j2!-Union{Tuple{T}, Tuple{J2_Structure{T}, Number}} where T","page":"Library","title":"SatelliteToolbox.j2!","text":"j2!(j2d::J2_Structure{T}, t::Number) where T\n\nPropagate the orbit defined in j2d (see J2_Structure) until the time t [s]. Notice that the values in j2d will be modified.\n\nReturns\n\nThe position vector represented in the inertial frame at time t [m].\nThe velocity vector represented in the inertial frame at time t [m/s]\n\nRemarks\n\nThe inertial frame in which the output is represented depends on which frame it was used to generate the orbit parameters. Notice that the perturbation theory requires an inertial frame with true equator.\n\n\n\n\n\n","category":"method"},{"location":"lib/library/#SatelliteToolbox.j2000_to_gmst-Tuple{Number}","page":"Library","title":"SatelliteToolbox.j2000_to_gmst","text":"j2000_to_gmst(J2000_UT1::Number)\n\nCompute the Greenwich Mean Sideral Time (GMST) [rad] given the instant J2000_UT1 in J2000.0 reference [UT1].\n\nRemarks\n\nBased on algorithm in 2, accessed at 2015-12-01.\n\n\n\n\n\n","category":"method"},{"location":"lib/library/#SatelliteToolbox.j2_init-Union{Tuple{T}, NTuple{7, Number}, NTuple{8, Number}, NTuple{9, Number}} where T","page":"Library","title":"SatelliteToolbox.j2_init","text":"j2_init(epoch::Number, a_0::Number, e_0::Number, i_0::Number, Ω_0::Number, ω_0::Number, f_0::Number, dn_o2::Number = 0, ddn_o6::Number = 0; j2_gc::J2_GravCte{T} = j2_gc_egm08 ) where T\n\nInitialize the data structure of J2 orbit propagator algorithm.\n\nArgs\n\nepoch: Epoch of the initial mean orbital elements [Julian Day].\na_0: Initial mean semi-major axis [m].\ne_0: Initial mean eccentricity.\ni_0: Initial mean inclination [rad].\nΩ_0: Initial mean right ascension of the ascending node [rad].\nω_0: Initial mean argument of perigee [rad].\nf_0: Initial mean true anomaly [rad].\ndn_o2: First time derivative of the mean motion divided by two [rad/s^2].\nddn_o6: Second time derivative of the mean motion divided by six [rad/s^3].\n\nKeywords\n\nj2_gc: J2 orbit propagator gravitational constants (see J2_GravCte).          (Default = j2_gc_egm08)\n\nReturns\n\nThe structure J2_Structure with the initialized parameters.\n\n\n\n\n\n","category":"method"},{"location":"lib/library/#SatelliteToolbox.j2osc!-Union{Tuple{T}, Tuple{SatelliteToolbox.J2osc_Structure{T}, Number}} where T","page":"Library","title":"SatelliteToolbox.j2osc!","text":"j2osc!(j2d::J2osc_Structure{T}, t::Number) where T\n\nPropagate the orbit defined in j2oscd (see J2osc_Structure) until the time t [s]. Notice that the values in j2oscd will be modified.\n\nReturns\n\nThe position vector represented in the inertial frame at time t [m].\nThe velocity vector represented in the inertial frame at time t [m/s]\n\nRemarks\n\nThe inertial frame in which the output is represented depends on which frame it was used to generate the orbit parameters. Notice, however, that the perturbation theory requires an inertial frame with true equator.\n\n\n\n\n\n","category":"method"},{"location":"lib/library/#SatelliteToolbox.j2osc_init-Union{Tuple{T}, NTuple{9, Number}} where T","page":"Library","title":"SatelliteToolbox.j2osc_init","text":"j2osc_init(epoch::Number, a_0::Number, e_0::Number, i_0::Number, Ω_0::Number, ω_0::Number, f_0::Number, dn_o2::Number, ddn_o6::Number; j2_gc::J2_GravCte{T} = j2_gc_egm08) where T\n\nInitialize the data structure of J2 osculating orbit propagator algorithm.\n\nArgs\n\nepoch: Epoch of the orbital elements [Julian Day].\na_0: Initial semi-major axis [m].\ne_0: Initial eccentricity.\ni_0: Initial inclination [rad].\nΩ_0: Initial right ascension of the ascending node [rad].\nω_0: Initial argument of perigee [rad].\nf_0: Initial true anomaly [rad].\ndn_o2: First time derivative of the mean motion divided by two [rad/s^2].\nddn_o6: Second time derivative of the mean motion divided by six [rad/s^3].\n\nKeywords\n\nj2_gc: J2 orbit propagator gravitational constants (see J2_GravCte).          (Default = j2_gc_egm08)\n\nReturns\n\nThe structure J2osc_Structure with the initialized parameters.\n\nRemarks\n\nThe inputs are the mean orbital elements.\n\n\n\n\n\n","category":"method"},{"location":"lib/library/#SatelliteToolbox.j4!-Union{Tuple{T}, Tuple{J4_Structure{T}, Number}} where T","page":"Library","title":"SatelliteToolbox.j4!","text":"j4!(j4d::J4_Structure{T}, t::Number) where T\n\nPropagate the orbit defined in j4d (see J4_Structure) until the time t [s]. Notice that the values in j4d will be modified.\n\nReturns\n\nThe position vector represented in the inertial frame at time t [m].\nThe velocity vector represented in the inertial frame at time t [m/s]\n\nRemarks\n\nThe inertial frame in which the output is represented depends on which frame it was used to generate the orbit parameters. Notice that the perturbation theory requires an inertial frame with true equator.\n\n\n\n\n\n","category":"method"},{"location":"lib/library/#SatelliteToolbox.j4_init-Union{Tuple{T}, NTuple{7, Number}, NTuple{8, Number}, NTuple{9, Number}} where T","page":"Library","title":"SatelliteToolbox.j4_init","text":"j4_init(epoch::Number, a_0::Number, e_0::Number, i_0::Number, Ω_0::Number, ω_0::Number, f_0::Number, dn_o2::Number = 0, ddn_o6::Number = 0; j4_gc::J4_GravCte{T} = j4_gc_egm08) where T\n\nInitialize the data structure of J4 orbit propagator algorithm.\n\nArgs\n\nepoch: Epoch of the initial mean orbital elements [Julian Day].\na_0: Initial mean semi-major axis [m].\ne_0: Initial mean eccentricity.\ni_0: Initial mean inclination [rad].\nΩ_0: Initial mean right ascension of the ascending node [rad].\nω_0: Initial mean argument of perigee [rad].\nf_0: Initial mean true anomaly [rad].\ndn_o2: First time derivative of the mean motion divided by two [rad/s^2].\nddn_o6: Second time derivative of the mean motion divided by six [rad/s^3].\n\nKeywords\n\nj4_gc: J4 orbit propagator gravitational constants (see J4_GravCte).          (Default = j4_gc_egm08)\n\nReturns\n\nThe structure J4_Structure with the initialized parameters.\n\n\n\n\n\n","category":"method"},{"location":"lib/library/#SatelliteToolbox.jb2008-NTuple{4, Number}","page":"Library","title":"SatelliteToolbox.jb2008","text":"jb2008(JD::Number, glat::Number, glon::Number, h::Number)\njb2008(JD::Number, glat::Number, glon::Number, h::Number, F10::Number, F10ₐ::Number, S10::Number, S10ₐ::Number, M10::Number, M10ₐ::Number, Y10::Number, Y10ₐ::Number, DstΔTc::Number)\n\nCompute the atmospheric density using the Jacchia-Bowman 2008 (JB2008) model.\n\nIf the space indices are not provided (first call), then they will be obtained from the online database. In this case, the function init_space_indices() must be called first and the function will throw an exception if the selected JD is outside of the available data.\n\nThis model is a product of the Space Environment Technologies, more information can be seen in the websites:\n\nhttp://sol.spacenvironment.net/jb2006/\n\nhttp://sol.spacenvironment.net/jb2008/\n\nArgs\n\nJD: Julian day.\nglat: Geocentric latitude [rad].\nglon: Geocentric longitude [rad].\nh: Altitude [m].\nF10: 10.7-cm solar flux [10⁻²² W/(M² Hz)] (Tabular time 1 day earlier).\nF10ₐ: 10.7-cm averaged solar flux, 81-day centered on input time (Tabular         time 1 day earlier).\nS10: EUV index (26-34 nm) scaled to F10.7 (Tabular time 1 day earlier).\nS10ₐ: EUV 81-day averaged centered index (Tabular time 1 day earlier).\nM10: MG2 index scaled to F10.7 (Tabular time 2 days earlier).\nM10ₐ: MG2 81-day averaged centered index (Tabular time 2 days earlier).\nY10: Solar X-ray & Lya index scaled to F10.7 (Tabular time 5 days earlier).\nY10ₐ: Solar X-ray & Lya 81-day averaged centered index (Tabular time 5 days         earlier).\nDstΔTc: Temperature variation related to the Dst.\n\nReturns\n\nAn instance of the structure JB2008_Output with the computed values.\n\n\n\n\n\n","category":"method"},{"location":"lib/library/#SatelliteToolbox.jd_to_date-Tuple{Number}","page":"Library","title":"SatelliteToolbox.jd_to_date","text":"jd_to_date([T,] JD::Number)\n\nConvert a date represented in Julian Day JD to Gregorian Calendar. The optional parameter T defines the return type. If T is omitted, then it defaults to Int.\n\nReturns\n\nIf T is omitted or Int, then a tuple with the following data will be returned:\n\nYear.\nMonth (1 => January, 2 => February, ...).\nDay.\nHour (0 - 24).\nMinute (0 - 59).\nSecond (0 - 59).\n\nNotice that if T is Int, then the seconds field will be Integer. Otherwise, it will be floating point.\n\nIf T is Date, then it will return the Julia structure Date. Notice that the hours, minutes, and seconds will be neglected because the structure Date does not handle them.\n\nIf T is DateTime, then it will return the Julia structure DateTime.\n\nRemarks\n\nThe algorithm was obtained from [2] (Accessed on 2018-04-11). In [2], there is the following warning:\n\nNote: This method will not give dates accurately on the Gregorian Proleptic Calendar, i.e., the calendar you get by extending the Gregorian calendar backwards to years earlier than 1582. using the Gregorian leap year rules. In particular, the method fails if Y<400.\n\n\n\n\n\n","category":"method"},{"location":"lib/library/#SatelliteToolbox.jd_to_gmst-Tuple{Number}","page":"Library","title":"SatelliteToolbox.jd_to_gmst","text":"jd_to_gmst(JD_UT1::Number)\n\nCompute the Greenwich Mean Sideral Time (GMST) [rad] for the Julian Day JD_UT1 [UT1].\n\nRemarks\n\nBased on algorithm in [1, pp. 188].\n\n\n\n\n\n","category":"method"},{"location":"lib/library/#SatelliteToolbox.jd_tt_to_utc-Tuple{Number, Number}","page":"Library","title":"SatelliteToolbox.jd_tt_to_utc","text":"jd_tt_to_utc(JD_TT::Number, ΔAT::Number = 37)\n\nConvert the Julian Day in TT JD_TT (Terrestrial Time) to the Julian Day in UTC (Terrestrial Time) using the accumulated difference ΔAT between UTC and the International Atomic Time (TAI). If no value is provided, then the leap seconds will be obtained from the table ΔAT_Data. Notice that, in this case, if a date previous to 1973 is provided, then a fixed value of 10 will be used, leading to wrong computations.\n\n\n\n\n\n","category":"method"},{"location":"lib/library/#SatelliteToolbox.jd_ut1_to_utc-Tuple{Number, Number}","page":"Library","title":"SatelliteToolbox.jd_ut1_to_utc","text":"jd_ut1_to_utc(JD_UT1::Number, ΔUT1::Number)\n\nConvert the Julian Day in UT1 JD_UT1 to the Julian Day in UTC using the accumulated difference ΔUT1, which is provided by IERS EOP Data.\n\n\n\n\n\n","category":"method"},{"location":"lib/library/#SatelliteToolbox.jd_ut1_to_utc-Tuple{Number, Union{EOPData_IAU1980, EOPData_IAU2000A}}","page":"Library","title":"SatelliteToolbox.jd_ut1_to_utc","text":"jd_utc_to_ut1(JD_UTC::Number, eop::Union{EOPData_IAU1980,EOPData_IAU2000A})\n\nConvert the Julian Day in UT1 JD_UT1 to the Julian Day in UTC using the accumulated difference given by the EOP Data eop (see get_iers_eop). Notice that the accumulated difference will be interpolated.\n\n\n\n\n\n","category":"method"},{"location":"lib/library/#SatelliteToolbox.jd_utc_to_tt-Tuple{Number, Number}","page":"Library","title":"SatelliteToolbox.jd_utc_to_tt","text":"jd_utc_to_tt(JD_UTC::Number [, ΔAT::Number])\n\nConvert the Julian Day in UTC JD_UTC to the Julian Day in TT (Terrestrial Time) using the accumulated difference ΔAT between UTC and the International Atomic Time (TAI). If no value is provided, then the leap seconds will be obtained from the table ΔAT_Data. Notice that, in this case, if a date previous to 1973 is provided, then a fixed value of 10 will be used, leading to wrong computations.\n\n\n\n\n\n","category":"method"},{"location":"lib/library/#SatelliteToolbox.jd_utc_to_ut1-Tuple{Number, Number}","page":"Library","title":"SatelliteToolbox.jd_utc_to_ut1","text":"jd_utc_to_ut1(JD_UTC::Number, ΔUT1::Number)\n\nConvert the Julian Day in UTC JD_UTC to the Julian Day in UT1 using the accumulated difference ΔUT1, which is provided by IERS EOP Data.\n\n\n\n\n\n","category":"method"},{"location":"lib/library/#SatelliteToolbox.jd_utc_to_ut1-Tuple{Number, Union{EOPData_IAU1980, EOPData_IAU2000A}}","page":"Library","title":"SatelliteToolbox.jd_utc_to_ut1","text":"jd_utc_to_ut1(JD_UTC::Number, eop::Union{EOPData_IAU1980,EOPData_IAU2000A})\n\nConvert the Julian Day in UTC JD_UTC to the Julian Day in UT1 using the accumulated difference given by the EOP Data eop (see get_iers_eop). Notice that the accumulated difference will be interpolated.\n\n\n\n\n\n","category":"method"},{"location":"lib/library/#SatelliteToolbox.jr1971-NTuple{7, Number}","page":"Library","title":"SatelliteToolbox.jr1971","text":"jr1971(JD::Number, glat::Number, glon::Number, h::Number, F10::Number, F10ₐ::Number, Kp::Number)\n\nCompute the atmospheric density using the Jacchia-Roberts 1971 model.\n\nArgs\n\nJD: Julian day.\nglat: Geodetic latitude [rad].\nglon: Geodetic longitude [rad].\nh: Altitude [m].\nF10: 10.7-cm solar flux [10⁻²² W/(M² Hz)].\nF10ₐ: 10.7-cm averaged solar flux, 81-day centered on input time.\nKp: Kp geomagnetic index (with a delay of 3 hours).\n\nReturns\n\nAn instance of the structure JR1971_Output with the computed values.\n\n\n\n\n\n","category":"method"},{"location":"lib/library/#SatelliteToolbox.kepler_to_rv-NTuple{6, Number}","page":"Library","title":"SatelliteToolbox.kepler_to_rv","text":"kepler_to_rv(a::Number, e::Number, i::Number, Ω::Number, ω::Number, f::Number)\nkepler_to_rv(k::KeplerianElements)\n\nConvert the Keplerian elements (a, e, i, Ω, ω, and f) to a Cartesian representation (position vector r and velocity vector v). The Keplerian elements can also be passed inside an instance of the KeplerianElements structure.\n\nArgs\n\na: Semi-major axis [m].\ne: Eccentricity.\ni: Inclination [rad].\nΩ: Right ascension of the ascending node [rad].\nω: Argument of perigee [rad].\nf: True anomaly [rad].\n\nReturns\n\nThe position vector represented in the inertial reference frame [m].\nThe velocity vector represented in the inertial reference frame [m].\n\nReferences\n\nThis algorithm was adapted from [1] and [3, p. 37-38].\n\n\n\n\n\n","category":"method"},{"location":"lib/library/#SatelliteToolbox.kepler_to_sv-Union{Tuple{KeplerianElements{T}}, Tuple{T}} where T","page":"Library","title":"SatelliteToolbox.kepler_to_sv","text":"kepler_to_sv(k::KeplerianElements)\n\nConvert the Keplerian elements k to a state vector.\n\n\n\n\n\n","category":"method"},{"location":"lib/library/#SatelliteToolbox.legendre","page":"Library","title":"SatelliteToolbox.legendre","text":"legendre([N,] ϕ::Number, n_max::Integer, m_max::Integer = -1, ph_term::Bool = false)\n\nCompute the associated Legendre function P_n,m[cos(ϕ)]. The maximum degree that will be computed is n_max and the maximum order is m_max. Notice that if m_max is higher than n_max or negative, than it is set to n_max.\n\nThe optional parameter N can be used to select the normalization. The following values are valid:\n\nVal(:full): Compute the fully normalized associated Legendre function (see legendre_fully_normalized).\nVal(:schmidt): Compute the Schmidt quasi-normalized associated Legendre function (see legendre_schmidt_quasi_normalized).\nVal(:conv): Compute the conventional associated Legendre function (see legendre_conventional).\n\nIf N is omitted, then the full normalization will be used (Val(:full)).\n\nIf ph_term is set to true, then the Condon-Shortley phase term (-1)ᵐ will be included. If ph_term is not present, then it defaults to false.\n\nReturns\n\nA matrix with the Legendre associated functions P_n,m[cos(ϕ)].\n\n\n\n\n\n","category":"function"},{"location":"lib/library/#SatelliteToolbox.legendre!","page":"Library","title":"SatelliteToolbox.legendre!","text":"legendre!([N,] P::AbstractMatrix, ϕ::Number, ph_term::Bool = false, n_max::Integer = -1, m_max::Integer = -1)\n\nCompute the associated Legendre function P_n,m[cos(ϕ)]. The maximum degree and order that will be computed are given by the parameters n_max and m_max. If they are negative, then the dimensions of matrix P will be used.\n\nThe result will be stored at matrix P.\n\nThe optional parameter N can be used to select the normalization. The following values are valid:\n\nVal(:full): Compute the fully normalized associated Legendre function (see legendre_fully_normalized!).\nVal(:schmidt): Compute the Schmidt quasi-normalized associated Legendre function (see legendre_schmidt_quasi_normalized!).\nVal(:conv): Compute the conventional associated Legendre function (see legendre_conventional!).\n\nIf N is omitted, then the full normalization will be used.\n\nIf ph_term is set to true, then the Condon-Shortley phase term (-1)ᵐ will be included. If ph_term is not present, then it defaults to false.\n\n\n\n\n\n","category":"function"},{"location":"lib/library/#SatelliteToolbox.legendre_conventional!","page":"Library","title":"SatelliteToolbox.legendre_conventional!","text":"legendre_conventional!(P::AbstractMatrix, ϕ::Number, ph_term::Bool = false, n_max::Integer = -1, m_max::Integer = -1)\n\nCompute the conventional associated Legendre function P_n,m[cos(ϕ)]. The maximum degree and order that will be computed are given by the parameters n_max and m_max. If they are negative, then the dimensions of matrix P will be used:\n\nmaximum degree -> number of rows\nmaximum order  -> number of columns\n\nThe result will be stored at matrix P.\n\nIf ph_term is set to true, then the Condon-Shortley phase term (-1)ᵐ will be included. If ph_term is not present, then it defaults to false.\n\n\n\n\n\n","category":"function"},{"location":"lib/library/#SatelliteToolbox.legendre_conventional-Union{Tuple{T}, Tuple{T, Integer}, Tuple{T, Integer, Integer}, Tuple{T, Integer, Integer, Bool}} where T<:AbstractFloat","page":"Library","title":"SatelliteToolbox.legendre_conventional","text":"legendre_conventional(ϕ::T, n_max::Integer, m_max::Integer = -1, ph_term::Bool = false) where T<:AbstractFloat\n\nCompute the conventional associated Legendre function P_n,m[cos(ϕ)]. The maximum degree that will be computed is n_max and the maximum order is m_max. Notice that if m_max is higher than n_max or negative, than it is set to n_max.\n\nIf ph_term is set to true, then the Condon-Shortley phase term (-1)ᵐ will be included. If ph_term is not present, then it defaults to false.\n\nReturns\n\nA matrix with the Legendre associated functions P_n,m[cos(ϕ)].\n\n\n\n\n\n","category":"method"},{"location":"lib/library/#SatelliteToolbox.legendre_fully_normalized!","page":"Library","title":"SatelliteToolbox.legendre_fully_normalized!","text":"legendre_fully_normalized!(P::AbstractMatrix, ϕ::Number, ph_term::Bool = false, n_max::Integer = -1, m_max::Integer = -1)\n\nCompute the fully normalized associated Legendre function P_n,m[cos(ϕ)]. The maximum degree and order that will be computed are given by the parameters n_max and m_max. If they are negative, then the dimensions of matrix P will be used:\n\nmaximum degree -> number of rows\nmaximum order  -> number of columns\n\nThe result will be stored at matrix P.\n\nIf ph_term is set to true, then the Condon-Shortley phase term (-1)ᵐ will be included. If ph_term is not present, then it defaults to false.\n\nRemarks\n\nThis algorithm was based on [1]. Our definition of fully normalized associated Legendre function can be seen in [2, p. 546]. The conversion is obtained by:\n\n             _                     -\n            |  (n-m)! . k . (2n+1)  |      k = 1 if m  = 0\nK_n,m = sqrt| --------------------- |,     k = 2 if m != 0\n            |         (n+m)!        |\n             -                     -\n_\nP_n,m = P_n,m * K_n,m,\n\n      _\nwhere P_n,m is the fully normalized Legendre associated function.\n\n\n\n\n\n","category":"function"},{"location":"lib/library/#SatelliteToolbox.legendre_fully_normalized-Union{Tuple{T}, Tuple{T, Integer}, Tuple{T, Integer, Integer}, Tuple{T, Integer, Integer, Bool}} where T<:AbstractFloat","page":"Library","title":"SatelliteToolbox.legendre_fully_normalized","text":"legendre_fully_normalized(ϕ::T, n_max::Integer, m_max::Integer = -1, ph_term::Bool = false) where T<:AbstractFloat\n\nCompute the fully normalized associated Legendre function P_n,m[cos(ϕ)]. The maximum degree that will be computed is n_max and the maximum order is m_max. Notice that if m_max is higher than n_max or negative, than it is set to n_max.\n\nIf ph_term is set to true, then the Condon-Shortley phase term (-1)ᵐ will be included. If ph_term is not present, then it defaults to false.\n\nReturns\n\nA matrix with the Legendre associated functions P_n,m[cos(ϕ)].\n\nRemarks\n\nThis algorithm was based on [1]. Our definition of fully normalized associated Legendre function can be seen in [2, p. 546]. The conversion is obtained by:\n\n             _                     -\n            |  (n-m)! . k . (2n+1)  |      k = 1 if m  = 0\nK_n,m = sqrt| --------------------- |,     k = 2 if m != 0\n            |         (n+m)!        |\n             -                     -\n_\nP_n,m = P_n,m * K_n,m,\n\n      _\nwhere P_n,m is the fully normalized Legendre associated function.\n\n\n\n\n\n","category":"method"},{"location":"lib/library/#SatelliteToolbox.legendre_schmidt_quasi_normalized!","page":"Library","title":"SatelliteToolbox.legendre_schmidt_quasi_normalized!","text":"legendre_schmidt_quasi_normalized!(P::AbstractMatrix, ϕ::Number, ph_term::Bool = false, n_max::Integer = -1, m_max::Integer = -1)\n\nCompute the Schmidt quasi-normalized associated Legendre function P_n,m[cos(ϕ)] [3,4]. The maximum degree and order that will be computed are given by the parameters n_max and m_max. If they are negative, then the dimensions of matrix P will be used:\n\nmaximum degree -> number of rows\nmaximum order  -> number of columns\n\nThe result will be stored at matrix P.\n\nIf ph_term is set to true, then the Condon-Shortley phase term (-1)ᵐ will be included. If ph_term is not present, then it defaults to false.\n\nRemarks\n\nThis algorithm was based on [3,4]. The conversion is obtained by:\n\n             _           -\n            |     (n-m)!  |    k = 1 if m  = 0\nK_n,m = sqrt| k. -------- |,   k = 2 if m != 0\n            |     (n+m)!  |\n             -           -\n\n=\nP_n,m = P_n,m * K_n,m,\n\n      =\nwhere P_n,m is the quasi-normalized normalized Legendre associated function.\n\n\n\n\n\n","category":"function"},{"location":"lib/library/#SatelliteToolbox.legendre_schmidt_quasi_normalized-Union{Tuple{T}, Tuple{T, Integer}, Tuple{T, Integer, Integer}, Tuple{T, Integer, Integer, Bool}} where T<:AbstractFloat","page":"Library","title":"SatelliteToolbox.legendre_schmidt_quasi_normalized","text":"legendre_schmidt_quasi_normalized(ϕ::T, n_max::Integer, m_max::Integer = -1, ph_term::Bool = false) where T<:AbstractFloat\n\nCompute the Schmidt quasi-normalized associated Legendre function P_n,m[cos(ϕ)]. The maximum degree that will be computed is n_max and the maximum order is m_max. Notice that if m_max is higher than n_max or negative, than it is set to n_max.\n\nIf ph_term is set to true, then the Condon-Shortley phase term (-1)ᵐ will be included. If ph_term is not present, then it defaults to false.\n\nReturns\n\nA matrix with the Legendre associated functions P_n,m[cos(ϕ)].\n\nRemarks\n\nThis algorithm was based on [3,4]. The conversion is obtained by:\n\n             _           -\n            |     (n-m)!  |    k = 1 if m  = 0\nK_n,m = sqrt| k. -------- |,   k = 2 if m != 0\n            |     (n+m)!  |\n             -           -\n\n=\nP_n,m = P_n,m * K_n,m,\n\n      =\nwhere P_n,m is the quasi-normalized normalized Legendre associated function.\n\n\n\n\n\n","category":"method"},{"location":"lib/library/#SatelliteToolbox.list_ground_station_accesses-Tuple","page":"Library","title":"SatelliteToolbox.list_ground_station_accesses","text":"list_ground_station_accesses(io, vargs...; kwargs...)\n\nPrint the ground station accesses to the io io. The arguments vargs... and keywords kwargs... are those of the function ground_station_accesses.\n\nAdditionally, the following keywords can be used to modify the behavior of this function:\n\nformat: If :pretty, then a formatted table will be printed. If :csv,           then the access data will be printed using the CSV format.           (Default = :pretty)\ntime_scale: Select the time scale of the access duration (:s for seconds,               :m for minutes, and :h for hours). (Default = :m)\n\n\n\n\n\n","category":"method"},{"location":"lib/library/#SatelliteToolbox.list_ground_station_gaps-Tuple","page":"Library","title":"SatelliteToolbox.list_ground_station_gaps","text":"list_ground_station_gaps(io, vargs...; kwargs...)\n\nPrint the ground station gaps to the io io. The arguments vargs... and keywords kwargs... are those of the function ground_station_gaps.\n\nAdditionally, the following keywords can be used to modify the behavior of this function:\n\nformat: If :pretty, then a formatted table will be printed. If :csv,           then the access data will be printed using the CSV format.           (Default = :pretty)\ntime_scale: Select the time scale of the access duration (:s for seconds,               :m for minutes, and :h for hours). (Default = :m)\n\n\n\n\n\n","category":"method"},{"location":"lib/library/#SatelliteToolbox.list_ss_orbits_by_rep_period","page":"Library","title":"SatelliteToolbox.list_ss_orbits_by_rep_period","text":"list_ss_orbits_by_rep_period(minRep::Int, maxRep::Int, minAlt::Number=-1.0, maxAlt::Number=-1.0, e::Number=0.0)\n\nCompute a list of repeating Sun-synchronous orbits.\n\nArgs\n\nminRep: Minimum repetition time of the orbit [days].\nmaxRep: Maximum repetition time of the orbit [days].\nminAlt: Minimum altitude of the orbits on the list [m].\nmaxAlt: Minimum altitude of the orbits on the list [m].\ne: Eccentricity.\n\nReturns\n\nA matrix containing the orbits found with the following format:\n\nSemi-major axis [m] | Altitude [m] | Inclination [rad] | Period [s] | Int | Num | Den\n--------------------|--------------|-------------------|------------|-----|-----|-----\n\nin which the period is Int + Num/Den.\n\nRemarks\n\nIf minAlt or maxAlt is < 0.0, then the altitude will not be checked when a orbit is added to the list.\n\n\n\n\n\n","category":"function"},{"location":"lib/library/#SatelliteToolbox.load_gravity_model-Tuple{Val{:egm96}}","page":"Library","title":"SatelliteToolbox.load_gravity_model","text":"load_gravity_model(T)\n\nLoad an embedded gravity model coefficients T and return an instance of the structure GravityModel_Coefs with the parsed values.\n\nThe current supported values for T are:\n\nT Model Name Maximum Degree\nEGM96() Earth Gravitational Model 1996 360\nJGM2() Joint Earth Gravity Model 2 70\nJGM3() Joint Earth Gravity Model 3 70\n–––––- –––––––––––––––– ––––––––\n\nFor other models, you can downlad the gfc file at\n\nhttp://icgem.gfz-potsdam.de/home\n\nand load it using the functions parse_icgem and create_gravity_model_coefs.\n\n\n\n\n\n","category":"method"},{"location":"lib/library/#SatelliteToolbox.luni_solar_args_iau2006-Tuple{Number}","page":"Library","title":"SatelliteToolbox.luni_solar_args_iau2006","text":"luni_solar_args_iau2006(JD_TT::Number)\n\nCompute the fundamental arguments related to the luni-solar effect for the IAU-2006 theory [1, p. 211].\n\nThe returned values are in [rad].\n\n\n\n\n\n","category":"method"},{"location":"lib/library/#SatelliteToolbox.mean_obliquity_iau2006-Tuple{Number}","page":"Library","title":"SatelliteToolbox.mean_obliquity_iau2006","text":"mean_obliquity_iau2006(JD_TT::Number)\n\nCompute the mean obliquity of the ecliptic [rad] using the equinox-based IAU-2006 theory in the Julian day JD_TT [Terrestiral Time].\n\nThe algorithm was obtained in [3].\n\n\n\n\n\n","category":"method"},{"location":"lib/library/#SatelliteToolbox.minimum_half_FOV_grss-Tuple{Real, Real, Real, Integer}","page":"Library","title":"SatelliteToolbox.minimum_half_FOV_grss","text":"minimum_half_FOV_grss(h::Real, T::Real, i::Real, To::Integer)\n\nCompute the minimum half FOV of a ground repeating Sun-synchronous (GRSS) orbit to cover the entire Equator within the revisit interval.\n\nArgs\n\nh: Orbit altitude in the Equator [m].\nT: Orbit period [s].\ni: Inclination [rad].\nTo: Orbit cycle [days].\n\nReturns\n\nThe minimum half FOV [rad].\n\n\n\n\n\n","category":"method"},{"location":"lib/library/#SatelliteToolbox.minimum_half_FOV_grss-Tuple{Real, Real, Real, Real, Integer}","page":"Library","title":"SatelliteToolbox.minimum_half_FOV_grss","text":"minimum_half_FOV_grss(h::Real, a::Real, e::Real, i::Real, To::Integer)\n\nCompute the minimum half FOV of a ground repeating Sun-synchronous (GRSS) orbit to cover the entire Equator within the revisit interval.\n\nArgs\n\nh: Orbit altitude in the Equator [m].\na: Semi-major axis [m].\ne: Eccentricity.\ni: Inclination [rad].\nTo: Orbit cycle [days].\n\nReturns\n\nThe minimum half FOV [rad].\n\n\n\n\n\n","category":"method"},{"location":"lib/library/#SatelliteToolbox.minimum_swath_grss-Tuple{Real, Real, Integer}","page":"Library","title":"SatelliteToolbox.minimum_swath_grss","text":"minimum_swath_grss(T::Real, i::Real, To::Integer)\n\nCompute the minimum swath of a ground repeating Sun-synchronous (GRSS) orbit to cover the entire Equator within the revisit interval.\n\nArgs\n\nT: Orbit period [s].\ni: Inclination [rad].\nTo: Orbit cycle [days].\n\nReturns\n\nThe minimum swath [m].\n\n\n\n\n\n","category":"method"},{"location":"lib/library/#SatelliteToolbox.minimum_swath_grss-Tuple{Real, Real, Real, Integer}","page":"Library","title":"SatelliteToolbox.minimum_swath_grss","text":"minimum_swath_grss(a::Real, e::Real, i::Real, To::Integer)\n\nCompute the minimum swath of a ground repeating Sun-synchronous (GRSS) orbit to cover the entire Equator within the revisit interval.\n\nArgs\n\na: Semi-major axis [m].\ne: Eccentricity.\ni: Inclination [rad].\nTo: Orbit cycle [days].\n\nReturns\n\nThe minimum swath [m].\n\n\n\n\n\n","category":"method"},{"location":"lib/library/#SatelliteToolbox.moon_position_i-Tuple{Number}","page":"Library","title":"SatelliteToolbox.moon_position_i","text":"moon_position_i(JD_TDB::Number[, model])\n\nCompute the Moon position represented in the IAU-76/FK5 MOD (mean-equator, mean-equinox of date) at the Julian Day JD_TDB (Barycentric Dynamical Time).\n\nThe model must be Val(:Meeus) or Val(:Vallado). Val(:Meeus) uses the algorithm in [2, p. 337] that provides an accuracy of 10\" in the longitude and 4\" in the latitude (the reference does not mention the timespan). Val(:fast) uses the algorithm in [1, p. 288] that is 10x faster than Val(:Meeus) but can lead to errors of 0.3° in longitude and 0.2° in latitude.\n\n\n\n\n\n","category":"method"},{"location":"lib/library/#SatelliteToolbox.ned_to_ecef-Tuple{AbstractVector{T} where T, Number, Number, Number}","page":"Library","title":"SatelliteToolbox.ned_to_ecef","text":"ned_to_ecef(r_ned::AbstractVector, lat::Number, lon::Number, h::Number; translate::Bool = false)\n\nConvert a vector r_ned represented in the local reference frame NED (North, East, Down) at the geodetic position lat [rad], lon [rad], and h [m] to the Earth-Centered, Earth-Fixed (ECEF) frame.\n\nIf translate is false, then this function computes only the rotation between NED and ECEF. Otherwise, it will also translate the vector considering the distance between the Earth's center and NED origin.\n\nRemarks\n\nThis algorithm was based on the information in [1].\n\nReferences\n\n[1] Transformations between ECEF and ENU       coordinates\n\n\n\n\n\n","category":"method"},{"location":"lib/library/#SatelliteToolbox.nrlmsise00-NTuple{4, Number}","page":"Library","title":"SatelliteToolbox.nrlmsise00","text":"nrlmsise00(JD::Number, alt::Number, g_lat::Number, g_long::Number [, f107A::Number, f107::Number, ap::Union{Number,AbstractVector}]; output_si::Bool = true, dversion::Bool = true)\n\nNRLMSISE-00\n\nNeutral Atmosphere Empirical Model from the surface to lower exosphere.\n\nThis routine computes the NRLMSISE-00 outputs (see NRLMSISE00_Output) using the configurations in the structure nrlmsise00 (see NRLMSISE00_Structure).\n\nNotice that the NRLMSISE-00 will be run using the default flags (see NRLMSISE00_DEFAULT_FLAGS). The user can only change the value of flags[:output_m_kg] using the keyword output_si to select whether the output must be converted to SI units. If more control is needed, then the user must manually call the function conf_nrlmsise00 and then call gtd7 or gtd7d with the desired flags.\n\nIf the space indices f107A, f107, and ap are missing, then they will be obtained from the online databases (see init_space_indices()).\n\nArgs\n\nJD: Julian Day [UTC].\nalt: Altitude [m].\ng_lat: Geodetic latitude [rad].\ng_long: Geodetic longitude [rad].\nf107A: 81 day average of F10.7 flux (centered on day of year JD).\nf107: Daily F10.7 flux for previous day.\nap: Magnetic index (daily) if it is a number. If it is an array, then see       Remarks.\n\nKeywords\n\noutput_si: (OPTIONAL) If true, then the output units will be [m⁻³] for              species number density and [kg/m⁻³] for the total density.              Otherwise, the units will be [cm⁻³] and [g/cm⁻³], respectively.\ndversion: (OPTIONAL) If true, run gtd7d. Otherwise, run gtd7 (see             Remarks).\n\nReturns\n\nAn instance of the structure NRLMSISE00_Output. The result in variable den_Total depends on the value of dversion (see Remarks, Notes on input variables).\n\nRemarks\n\nThe densities of O, H, and N are set to 0 below 72.5 km.\nThe exospheric temperature T_exo is set to global average for altitudes below 120 km. The 120 km gradient is left at global average value for altitudes below 72.5 km.\nAnomalous oxygen is defined as hot atomic oxygen or ionized oxygen that can become appreciable at high altitudes (> 500 km) for some ranges of inputs, thereby affection drag on satellites and debris. We group these species under the term Anomalous Oxygen, since their individual variations are not presently separable with the drag data used to define this model component.\n\nAP\n\nIf ap is a Vector, then it must be a vector with 7 dimensions as described below:\n\nIndex Description\n1 Daily AP.\n2 3 hour AP index for current time.\n3 3 hour AP index for 3 hours before current time.\n4 3 hour AP index for 6 hours before current time.\n5 3 hour AP index for 9 hours before current time.\n6 Average of eight 3 hour AP indices from 12 to 33 hours prior to current time.\n7 Average of eight 3 hour AP indices from 36 to 57 hours prior to current time.\n\nNotes on input variables\n\nf107 and f107A values used to generate the model correspond to the 10.7 cm radio flux at the actual distance of the Earth from the Sun rather than the radio flux at 1 AU. The following site provides both classes of values:\n\nftp://ftp.ngdc.noaa.gov/STP/SOLAR_DATA/SOLAR_RADIO/FLUX/\n\nf107, f107A, and ap effects are neither large nor well established below 80 km and these parameters should be set to 150, 150, and 4 respectively.\n\nIf dversion is true, then the total mass den_Total (see NRLMSISE00_Output) is the sum of the mass densities of the species He, O, N₂, O₂, Ar, H, and N, but does not include anomalous oxygen.\n\nIf dversion is false, then total mass den_Total (see NRLMSISE00_Output) is the effective total mass density for drag and is the sum of the mass densities of all species in this model including the anomalous oxygen.\n\n\n\n\n\n","category":"method"},{"location":"lib/library/#SatelliteToolbox.nutation_eo_iau2006","page":"Library","title":"SatelliteToolbox.nutation_eo_iau2006","text":"nutation_eo_iau2006(JD_TT::Number)\n\nCompute the nutation parameters and the Equation of Origins (EO) at the Julian Day JD_TT [TT] using the equinox-based 2006 IAU Theory of Nutation. Notice that one can provide corrections for the nutation in obliquity (δΔϵ_2000) [rad] and in longitude (δΔψ_2000) [rad] that are usually obtained from IERS EOP Data (see get_iers_eop).\n\nReturns\n\nThe mean obliquity of the ecliptic [rad].\nThe nutation in obliquity of the ecliptic [rad].\nThe nutation in longitude [rad].\nThe Equation of Origins (EO) [rad].\n\n\n\n\n\n","category":"function"},{"location":"lib/library/#SatelliteToolbox.nutation_fk5","page":"Library","title":"SatelliteToolbox.nutation_fk5","text":"nutation_fk5(JD_TT::Number, n_max::Number = 106, nut_coefs_1980::Matrix = nut_coefs_1980)\n\nCompute the nutation parameters at the Julian Day JD_TT [Terrestrial Time] using the 1980 IAU Theory of Nutation. The coefficients are nut_coefs_1980 that must be a matrix in which each line has the following syntax [1, p. 1043]:\n\nan1  an2  an3  an4  an5  Ai  Bi  Ci  Di\n\nwhere the units of Ai and Ci are [0.0001\"] and the units of Bi and Di are [0.0001\"/JC]. The user can also specify the number of coefficients n_max that will be used when computing the nutation. If n_max is omitted, the it defaults to 106.\n\nReturns\n\nThe mean obliquity of the ecliptic [rad].\nThe nutation in obliquity of the ecliptic [rad].\nThe nutation in longitude [rad].\n\n\n\n\n\n","category":"function"},{"location":"lib/library/#SatelliteToolbox.orbsv-Union{Tuple{T4}, Tuple{T3}, Tuple{T2}, Tuple{T1}, Tuple{T1, AbstractVector{T2}, AbstractVector{T3}}, Tuple{T1, AbstractVector{T2}, AbstractVector{T3}, AbstractVector{T4}}} where {T1<:Number, T2<:Number, T3<:Number, T4<:Number}","page":"Library","title":"SatelliteToolbox.orbsv","text":"orbsv(t::T1, r::AbstractVector{T2}, v::AbstractVector{T3} = [0,0,0], a::AbstractVector{T4} = [0,0,0]) where {T1<:Number, T2<:Number, T3<:Number, T4<:Number}\norbsv(t::T1, vec::AbstractVector{T2}) where {T1<:Number, T2<:Number}\n\nCreate a new satellite state vector (see OrbitStateVector) using the position r, velocity v, and acceleration a. It is also possible to pass a vector vec with the information concatenated.\n\ninfo: Info\nThe vectors r, v, and a must have at least 3 elements. In the case more elements are available, they will be neglected. On the other hand, the vector v must have 6 or 9 dimensions, indicating [r;v], or [r;v;a].\n\n\n\n\n\n","category":"method"},{"location":"lib/library/#SatelliteToolbox.parse_icgem-Tuple{AbstractString}","page":"Library","title":"SatelliteToolbox.parse_icgem","text":"parse_icgem(filename::AbstractString)\n\nParse the ICGEM file filename and return an instance of the structure ICGEM with the parsed data.\n\n\n\n\n\n","category":"method"},{"location":"lib/library/#SatelliteToolbox.period","page":"Library","title":"SatelliteToolbox.period","text":"period(a::Number, e::Number, i::Number, pert::Symbol = :J2)\n\nCompute the period [s] of an object in an orbit with semi-major axis a [m], eccentricity e, and inclination i [rad], using the perturbation terms specified by the symbol pert. The orbit can also be specified by orb (see Orbit).\n\npert` can be:\n\n:J0: Consider a Keplerian orbit.\n:J2: Consider the perturbation terms up to J2.\n:J4: Consider the perturbation terms J2, J4, and J2².\n\nIf pert is omitted, then it defaults to :J2.\n\n\n\n\n\n","category":"function"},{"location":"lib/library/#SatelliteToolbox.planetary_args_iau2006-Tuple{Number}","page":"Library","title":"SatelliteToolbox.planetary_args_iau2006","text":"planetary_args_iau2006(JD_TT::Number)\n\nCompute the fundamental arguments related to the planetary effects for the IAU-2006 theory [1, p. 211].\n\nThe returned values are in [rad].\n\n\n\n\n\n","category":"method"},{"location":"lib/library/#SatelliteToolbox.precession_fk5-Tuple{Number}","page":"Library","title":"SatelliteToolbox.precession_fk5","text":"precession_fk5(JD_TT::Number)\n\nCompute the angles related to the precession movement in the Julian Day JD_TT [Terrestrial Time] using the theory IAU-76/FK5.\n\nReturns\n\nThe angles (ζ, Θ, z) as described in [1, p. 226-228].\n\n\n\n\n\n","category":"method"},{"location":"lib/library/#SatelliteToolbox.precession_iau2006-Tuple{Number}","page":"Library","title":"SatelliteToolbox.precession_iau2006","text":"precession_iau2006(JD_TT::Number)\n\nCompute the precession angles [rad] according to equinox-based IAU-2006 theory in the Julia day JD_TT [Terrestrial Time].\n\nThis algorithm was obtained from [3, p. 49].\n\n\n\n\n\n","category":"method"},{"location":"lib/library/#SatelliteToolbox.propagate!","page":"Library","title":"SatelliteToolbox.propagate!","text":"propagate!(orbp::OrbitPropagator{T}, t::Number) where T\npropagate!(orbp::OrbitPropagator{T}, t::AbstractVector) where T\n\nIf t is a number, then propagate orbp by t [s] from the orbit epoch. Otherwise, if t is an array, then propagate the orbit in orbp using the time instants defined in the vector t [s].\n\nIn both cases, the orbit propagator algorithm is the one related to the structure orbp.\n\nReturns\n\nThe position vector represented in inertial frame in each time instant [m].\nThe velocity vector represented in inertial frame in each time instant [m].\n\nIf t is an array, then those values will be an array containing the information related to each epoch in t.\n\n\n\n\n\n","category":"function"},{"location":"lib/library/#SatelliteToolbox.propagate_to_epoch!-Union{Tuple{T}, Tuple{OrbitPropagator, Union{Number, AbstractVector{T} where T}}} where T","page":"Library","title":"SatelliteToolbox.propagate_to_epoch!","text":"propagate_to_epoch!(orbp::OrbitPropagator{T}, JD::Number) where T\npropagate_to_epoch!(orbp::OrbitPropagator{T}, JD::AbstractVector) where T\n\nIf t is a number, then propagate orbp until the epoch JD [Julian Day]. Otherwise, if JD is an array, then propagate the orbit in orbp using the epochs defined in the vector t [Julian Day].\n\nIn both cases, the orbit propagator algorithm is the one related to the structure orbp.\n\nReturns\n\nThe position vector represented in inertial frame in each time instant [m].\nThe velocity vector represented in inertial frame in each time instant [m].\n\nIf JD is an array, then those values will be an array containing the information related to each epoch in JD.\n\n\n\n\n\n","category":"method"},{"location":"lib/library/#SatelliteToolbox.r_cirs_to_gcrf_iau2006","page":"Library","title":"SatelliteToolbox.r_cirs_to_gcrf_iau2006","text":"r_cirs_to_gcrf_iau2006([T::Type,] JD_TT::Number, dX::Number = 0, dY::Number = 0)\n\nCompute the rotation that aligns the Celestial Intermediate Reference System (CIRS) with the Geocentric Celestial Reference Frame (GCRF) at the Julian Day JD_TT [TT] and considering the IERS EOP Data dX [rad] and dY [rad] (see get_iers_eop). This algorithm uses the IAU-2006 theory.\n\nThe IERS EOP Data dX and dY accounts for the free-core nutation and time dependent effects of the Celestial Intermediate Pole (CIP) position with respect to the GCRF.\n\nThe rotation type is described by the optional variable T. If it is DCM, then a DCM will be returned. Otherwise, if it is Quaternion, then a Quaternion will be returned. In case this parameter is omitted, then it falls back to DCM.\n\nReturns\n\nThe rotation that aligns the CIRS frame with the GCRF frame. The rotation representation is selected by the optional parameter T.\n\n\n\n\n\n","category":"function"},{"location":"lib/library/#SatelliteToolbox.r_cirs_to_tirs_iau2006-Tuple{Number}","page":"Library","title":"SatelliteToolbox.r_cirs_to_tirs_iau2006","text":"r_cirs_to_tirs_iau2006([T::Type,] JD_UT1::Number)\n\nCompute the rotation that aligns the Celestial Intermediate Reference System (CIRS) with the Terrestrial Intermediate Reference System (TIRS) at the Julian Day JD_UT1 [UT1]. This algorithm uses the IAU-2006 theory.\n\nThe rotation type is described by the optional variable T. If it is DCM, then a DCM will be returned. Otherwise, if it is Quaternion, then a Quaternion will be returned. In case this parameter is omitted, then it falls back to DCM.\n\nReturns\n\nThe rotation that aligns the CIRS frame with the TIRS frame. The rotation representation is selected by the optional parameter T.\n\nRemarks\n\nThe reference frames TIRS and CIRS are separated by a rotation about the Z-axis of the Earth Rotation Angle, which is the angle between the Conventional International Origin (CIO) and the Terrestrial Intermediate Origin (TIO) [1]. The latter is a reference meridian on Earth that is located about 100m away from Greenwich meridian along the equator of the Celestial Intermediate Pole (CIP) [1].\n\n\n\n\n\n","category":"method"},{"location":"lib/library/#SatelliteToolbox.r_ecef_to_ecef-Tuple{Union{Val{:ITRF}, Val{:PEF}}, Union{Val{:ITRF}, Val{:PEF}}, Number, EOPData_IAU1980}","page":"Library","title":"SatelliteToolbox.r_ecef_to_ecef","text":"r_ecef_to_ecef([T,] ECEFo, ECEFf, JD_UTC::Number, eop_data)\n\nCompute the rotation from an Earth-Centered, Earth-Fixed (ECEF) reference frame to another ECEF reference frame at the Julian Day [UTC] JD_UTC. The rotation description that will be used is given by T, which can be DCM or Quaternion. The origin ECEF frame is selected by the input ECEFo and the destination ECEF frame is selected by the input ECEFf. The model used to compute the rotation is specified by the selection of the origin and destination frames. Currently, there are two models supported: IAU-76/FK5 and IAU-2006 with 2010 conventions (CIO approach only).\n\nRotation description\n\nThe rotations that aligns the origin ECEF frame with the destination ECEF frame can be described by Direction Cosine Matrices or Quaternions. This is selected by the parameter T.\n\nThe possible values are:\n\nDCM: The rotation will be described by a Direction Cosine Matrix.\nQuaternion: The rotation will be described by a Quaternion.\n\nIf no value is specified, then it falls back to DCM.\n\nConversion model\n\nThe model that will be used to compute the rotation is automatically inferred given the selection of the origin and destination frames. Notice that mixing IAU-76/FK5 and IAU-2006/2010 frames is not supported yet.\n\nECEF Frame\n\nThe supported ECEF frames for both origin ECEFo and destination ECEFf are:\n\nITRF(): ECEF will be selected as the International Terrestrial Reference           Frame (ITRF).\nPEF(): ECEF will be selected as the Pseudo-Earth Fixed (PEF) reference          frame.\nTIRS(): ECEF will be selected as the Terrestrial Intermediate Reference           System (TIRS).\n\nEOP Data\n\nThe conversion between the supported ECEF frames always depends on EOP Data (see get_iers_eop and read_iers_eop). If IAU-76/FK5 model is used, then the type of eop_data must be EOPData_IAU1980. Otherwise, if IAU-2006/2010 model is used, then the type of eop_data must be EOPData_IAU2000A.\n\nReturns\n\nThe rotation description represented by T that rotates the ECEF reference frame into alignment with the ECI reference frame.\n\nExamples\n\njulia> eop_IAU1980 = get_iers_eop(:IAU1980);\n\njulia> r_ecef_to_ecef(PEF(), ITRF(), date_to_jd(1986,6,19,21,35,0), eop_IAU1980)\n3×3 StaticArrays.SArray{Tuple{3,3},Float64,2,9}:\n  1.0          0.0         4.35684e-7\n  0.0          1.0         1.44762e-6\n -4.35684e-7  -1.44762e-6  1.0\n\njulia> r_ecef_to_ecef(Quaternion, PEF(), ITRF(), date_to_jd(1986,6,19,21,35,0), eop_IAU1980)\nQuaternion{Float64}:\n  + 0.9999999999997147 - 7.236343481310813e-7.i + 2.1765518308012794e-7.j + 0.0.k\n\njulia> eop_IAU2000A = get_iers_eop(:IAU2000A);\n\njulia> r_ecef_to_ecef(TIRS(), ITRF(), date_to_jd(1986,6,19,21,35,0), eop_IAU2000A)\n3×3 StaticArrays.SArray{Tuple{3,3},Float64,2,9}:\n  1.0          3.08408e-11  -4.3531e-7\n -3.14708e-11  1.0          -1.44727e-6\n  4.3531e-7    1.44727e-6    1.0\n\njulia> r_ecef_to_ecef(Quaternion, TIRS(), ITRF(), date_to_jd(1986,6,19,21,35,0), eop_IAU2000A)\nQuaternion{Float64}:\n  + 0.9999999999997146 - 7.236343481345639e-7.i + 2.176551830689726e-7.j + 1.5577911634233308e-11.k\n\n\n\n\n\n","category":"method"},{"location":"lib/library/#SatelliteToolbox.r_ecef_to_eci-Tuple{Union{Val{:ITRF}, Val{:PEF}}, Union{Val{:GCRF}, Val{:J2000}, Val{:TOD}, Val{:MOD}, Val{:TEME}}, Number, EOPData_IAU1980}","page":"Library","title":"SatelliteToolbox.r_ecef_to_eci","text":"r_ecef_to_eci([T,] ECEF, ECI, JD_UTC::Number [, eop_data])\n\nCompute the rotation from an Earth-Centered, Earth-Fixed (ECEF) reference frame to an Earth-Centered Inertial (ECI) reference frame at the Julian Day [UTC] JD_UTC. The rotation description that will be used is given by T, which can be DCM or Quaternion. The ECEF frame is selected by the input ECEF and the ECI frame is selected by the input ECI. The possible values are listed below. The model used to compute the rotation is specified by the selection of the origin and destination frames. Currently, there are two models supported: IAU-76/FK5 and IAU-2006 with 2010 conventions (CIO and equinox approaches).\n\nRotation description\n\nThe rotations that aligns the ECEF with ECI can be described by Direction Cosine Matrices or Quaternions. This is selected by the parameter T. The possible values are:\n\nDCM: The rotation will be described by a Direction Cosine Matrix.\nQuaternion: The rotation will be described by a Quaternion.\n\nIf no value is specified, then it falls back to DCM.\n\nConversion model\n\nThe model that will be used to compute the rotation is automatically inferred given the selection of the origin and destination frames. Notice that mixing IAU-76/FK5 and IAU-2006/2010 frames is not supported yet.\n\nECEF Frame\n\nThe ECEF frame is selected by the parameter ECEF. The possible values are:\n\nITRF(): ECEF will be selected as the International Terrestrial Reference           Frame (ITRF).\nPEF(): ECEF will be selected as the Pseudo-Earth Fixed (PEF) reference          frame.\nTIRS(): ECEF will be selected as the Terrestrial Intermediate Reference           System (TIRS).\n\nECI Frame\n\nThe ECI frame is selected by the parameter ECI. The possible values are:\n\nTEME(): ECI will be selected as the True Equator Mean Equinox (TEME)           reference frame.\nTOD(): ECI will be selected as the True of Date (TOD).\nMOD(): ECI will be selected as the Mean of Date (MOD).\nJ2000(): ECI will be selected as the J2000 reference frame.\nGCRF(): ECI will be selected as the Geocentric Celestial Reference Frame           (GCRF).\nCIRS(): ECI will be selected as the Celestial Intermediate Reference System           (CIRS).\nERS(): ECI will be selected as the Earth Reference System (ERS).\nMOD06(): ECI will be selected as the Mean of Date (MOD) according to the            definition in IAU-2006/2010 theory.\nMJ2000(): ECI will be selected as the J2000 mean equatorial frame (MJ2000).\n\nnote: Note\nThe frames MOD() and MOD06() are virtually the same. However, we selected different names to make clear which theory are being used since mixing transformation between frames from IAU-76/FK5 and IAU-2006/2010 must be performed with caution.\n\nEOP Data\n\nThe conversion between the frames depends on EOP Data (see get_iers_eop and read_iers_eop). If IAU-76/FK5 model is used, then the type of eop_data must be EOPData_IAU1980. Otherwise, if IAU-2006/2010 model is used, then the type of eop_data must be EOPData_IAU2000A. The following table shows the requirements for EOP data given the selected frames.\n\nModel ECEF ECI EOP Data\nIAU-76/FK5 ITRF GCRF EOP IAU1980\nIAU-76/FK5 ITRF J2000 EOP IAU1980\nIAU-76/FK5 ITRF MOD EOP IAU1980\nIAU-76/FK5 ITRF TOD EOP IAU1980\nIAU-76/FK5 ITRF TEME EOP IAU1980\nIAU-76/FK5 PEF GCRF EOP IAU1980\nIAU-76/FK5 PEF J2000 Not required¹\nIAU-76/FK5 PEF MOD Not required¹\nIAU-76/FK5 PEF TOD Not required¹\nIAU-76/FK5 PEF TEME Not required¹\nIAU-2006/2010 CIO-based ITRF CIRS EOP IAU2000A\nIAU-2006/2010 CIO-based ITRF GCRF EOP IAU2000A\nIAU-2006/2010 CIO-based TIRS CIRS Not required¹\nIAU-2006/2010 CIO-based TIRS GCRF Not required¹ ²\nIAU-2006/2010 Equinox-based ITRF ERS EOP IAU2000A\nIAU-2006/2010 Equinox-based ITRF MOD06 EOP IAU2000A\nIAU-2006/2010 Equinox-based ITRF MJ2000 EOP IAU2000A\nIAU-2006/2010 Equinox-based TIRS ERS Not required¹ ³\nIAU-2006/2010 Equinox-based TIRS MOD06 Not required¹ ³\nIAU-2006/2010 Equinox-based TIRS MJ2000 Not required¹ ³\n\n¹: In this case, the Julian Time UTC will be assumed equal to Julian Time UT1 to compute the Greenwich Mean Sidereal Time. This is an approximation, but should be sufficiently accurate for some applications. Notice that, if EOP Data is provided, the Julian Day UT1 will be accurately computed.\n\n²: In this case, the terms that account for the free core nutation and time dependent effects of the Celestial Intermediate Pole (CIP) position with respect to the GCRF will not be available, reducing the precision.\n\n³: In this case, the terms that corrects the nutation in obliquity and in longitude due to the free core nutation will not be available, reducing the precision.\n\nMOD and TOD\n\nIn this function, if EOP corrections are not provided, then MOD and TOD frames will be computed considering the original IAU-76/FK5 theory. Otherwise, the corrected frame will be used.\n\nReturns\n\nThe rotation description represented by T that rotates the ECEF reference frame into alignment with the ECI reference frame.\n\nExamples\n\njulia> eop_IAU1980 = get_iers_eop(:IAU1980);\n\njulia> r_ecef_to_eci(DCM, ITRF(), GCRF(), date_to_jd(1986, 06, 19, 21, 35, 0), eop_IAU1980)\n3×3 StaticArrays.SArray{Tuple{3,3},Float64,2,9}:\n -0.619267      0.78518     -0.00132979\n -0.78518      -0.619267     3.33492e-5\n -0.000797313   0.00106478   0.999999\n\njulia> r_ecef_to_eci(ITRF(), GCRF(), date_to_jd(1986, 06, 19, 21, 35, 0), eop_IAU1980)\n3×3 StaticArrays.SArray{Tuple{3,3},Float64,2,9}:\n -0.619267      0.78518     -0.00132979\n -0.78518      -0.619267     3.33492e-5\n -0.000797313   0.00106478   0.999999\n\njulia> r_ecef_to_eci(PEF(), J2000(), date_to_jd(1986, 06, 19, 21, 35, 0))\n3×3 StaticArrays.SArray{Tuple{3,3},Float64,2,9}:\n -0.619271      0.785176    -0.00133066\n -0.785177     -0.619272     3.45854e-5\n -0.000796885   0.00106622   0.999999\n\njulia> r_ecef_to_eci(PEF(), J2000(), date_to_jd(1986, 06, 19, 21, 35, 0), eop_IAU1980)\n3×3 StaticArrays.SArray{Tuple{3,3},Float64,2,9}:\n -0.619267      0.78518     -0.00133066\n -0.78518      -0.619267     3.45854e-5\n -0.000796879   0.00106623   0.999999\n\njulia> r_ecef_to_eci(Quaternion, ITRF(), GCRF(), date_to_jd(1986, 06, 19, 21, 35, 0), eop_IAU1980)\nQuaternion{Float64}:\n  + 0.4363098936462618 - 0.0005909969666939257.i + 0.00030510511316206974.j + 0.8997962182293519.k\n\njulia> eop_IAU2000A = get_iers_eop(:IAU2000A);\n\njulia> r_ecef_to_eci(ITRF(), GCRF(), date_to_jd(1986, 06, 19, 21, 35, 0), eop_IAU2000A)\n3×3 StaticArrays.SArray{Tuple{3,3},Float64,2,9}:\n -0.619267      0.78518     -0.00132979\n -0.78518      -0.619267     3.33502e-5\n -0.000797312   0.00106478   0.999999\n\njulia> r_ecef_to_eci(TIRS(), GCRF(), date_to_jd(1986, 06, 19, 21, 35, 0))\n3×3 StaticArrays.SArray{Tuple{3,3},Float64,2,9}:\n -0.619271      0.785176    -0.00133066\n -0.785177     -0.619272     3.45884e-5\n -0.000796885   0.00106623   0.999999\n\njulia> r_ecef_to_eci(Quaternion, ITRF(), GCRF(), date_to_jd(1986, 06, 19, 21, 35, 0), eop_IAU2000A)\nQuaternion{Float64}:\n  + 0.4363098936309669 - 0.000590996988144556.i + 0.0003051056555230158.j + 0.8997962182365703.k\n\n\n\n\n\n","category":"method"},{"location":"lib/library/#SatelliteToolbox.r_eci_to_ecef-Tuple{Union{Val{:GCRF}, Val{:J2000}, Val{:TOD}, Val{:MOD}, Val{:TEME}}, Union{Val{:ITRF}, Val{:PEF}}, Number, EOPData_IAU1980}","page":"Library","title":"SatelliteToolbox.r_eci_to_ecef","text":"r_eci_to_ecef([T,] ECI, ECEF, JD_UTC::Number [, eop_data])\n\nCompute the rotation from an Earth-Centered Inertial (ECI) reference frame to an Earth-Centered, Earth-Fixed (ECEF) reference frame at the Julian Day [UTC] JD_UTC. The rotation description that will be used is given by T, which can be DCM or Quaternion. The ECI frame is selected by the input ECI and the ECEF frame is selected by the input ECEF. The possible values are listed below. The model used to compute the rotation is specified by the selection of the origin and destination frames. Currently, there are two models supported: IAU-76/FK5 and IAU-2006 with 2010 conventions (CIO and equinox approaches).\n\nRotation description\n\nThe rotations that aligns the ECI with ECEF can be described by Direction Cosine Matrices or Quaternions. This is selected by the parameter T. The possible values are:\n\nDCM: The rotation will be described by a Direction Cosine Matrix.\nQuaternion: The rotation will be described by a Quaternion.\n\nIf no value is specified, then it falls back to DCM.\n\nConversion model\n\nThe model that will be used to compute the rotation is automatically inferred given the selection of the origin and destination frames. Notice that mixing IAU-76/FK5 and IAU-2006/2010 frames is not supported yet.\n\nECI Frame\n\nThe ECI frame is selected by the parameter ECI. The possible values are:\n\nTEME(): ECI will be selected as the True Equator Mean Equinox (TEME)           reference frame.\nTOD(): ECI will be selected as the True of Date (TOD).\nMOD(): ECI will be selected as the Mean of Date (MOD).\nJ2000(): ECI will be selected as the J2000 reference frame.\nGCRF(): ECI will be selected as the Geocentric Celestial Reference Frame           (GCRF).\nCIRS(): ECEF will be selected as the Celestial Intermediate Reference System           (CIRS).\nERS(): ECI will be selected as the Earth Reference System (ERS).\nMOD06(): ECI will be selected as the Mean of Date (MOD) according to the            definition in IAU-2006/2010 theory.\nMJ2000(): ECI will be selected as the J2000 mean equatorial frame (MJ2000).\n\nnote: Note\nThe frames MOD() and MOD06() are virtually the same. However, we selected different names to make clear which theory are being used since mixing transformation between frames from IAU-76/FK5 and IAU-2006/2010 must be performed with caution.\n\nECEF Frame\n\nThe ECEF frame is selected by the parameter ECEF. The possible values are:\n\nITRF(): ECEF will be selected as the International Terrestrial Reference           Frame (ITRF).\nPEF(): ECEF will be selected as the Pseudo-Earth Fixed (PEF) reference          frame.\nTIRS(): ECEF will be selected as the Terrestrial Intermediate Reference           System (TIRS).\n\nEOP Data\n\nThe conversion between the frames depends on EOP Data (see get_iers_eop and read_iers_eop). If IAU-76/FK5 model is used, then the type of eop_data must be EOPData_IAU1980. Otherwise, if IAU-2006/2010 model is used, then the type of eop_data must be EOPData_IAU2000A. The following table shows the requirements for EOP data given the selected frames.\n\nModel ECI ECEF EOP Data\nIAU-76/FK5 GCRF ITRF EOP IAU1980\nIAU-76/FK5 J2000 ITRF EOP IAU1980\nIAU-76/FK5 MOD ITRF EOP IAU1980\nIAU-76/FK5 TOD ITRF EOP IAU1980\nIAU-76/FK5 TEME ITRF EOP IAU1980\nIAU-76/FK5 GCRF PEF EOP IAU1980\nIAU-76/FK5 J2000 PEF Not required¹\nIAU-76/FK5 MOD PEF Not required¹\nIAU-76/FK5 TOD PEF Not required¹\nIAU-76/FK5 TEME PEF Not required¹\nIAU-2006/2010 CIO-based CIRS ITRF EOP IAU2000A\nIAU-2006/2010 CIO-based GCRF ITRF EOP IAU2000A\nIAU-2006/2010 CIO-based CIRS TIRS Not required¹\nIAU-2006/2010 CIO-based GCRF TIRS Not required¹ ²\nIAU-2006/2010 Equinox-based ERS TIRS EOP IAU2000A\nIAU-2006/2010 Equinox-based MOD06 ITRF EOP IAU2000A\nIAU-2006/2010 Equinox-based MJ2000 ITRF EOP IAU2000A\nIAU-2006/2010 Equinox-based ERS TIRS Not required¹ ³\nIAU-2006/2010 Equinox-based MOD06 TIRS Not required¹ ³\nIAU-2006/2010 Equinox-based MJ2000 TIRS Not required¹ ³\n\n¹: In this case, the Julian Time UTC will be assumed equal to Julian Time UT1 to compute the Greenwich Mean Sidereal Time. This is an approximation, but should be sufficiently accurate for some applications. Notice that, if EOP Data is provided, the Julian Day UT1 will be accurately computed.\n\n²: In this case, the terms that account for the free-core nutation and time dependent effects of the Celestial Intermediate Pole (CIP) position with respect to the GCRF will not be available, reducing the precision.\n\nMOD and TOD\n\nIn this function, if EOP corrections are not provided, then MOD and TOD frames will be computed considering the original IAU-76/FK5 theory. Otherwise, the corrected frame will be used.\n\nReturns\n\nThe rotation description represented by T that rotates the ECI reference frame into alignment with the ECEF reference frame.\n\nExamples\n\njulia> eop_IAU1980 = get_iers_eop(:IAU1980);\n\njulia> r_eci_to_ecef(DCM, GCRF(), ITRF(), date_to_jd(1986, 06, 19, 21, 35, 0), eop_IAU1980)\n3×3 StaticArrays.SArray{Tuple{3,3},Float64,2,9}:\n -0.619267    -0.78518     -0.000797313\n  0.78518     -0.619267     0.00106478\n -0.00132979   3.33492e-5   0.999999\n\njulia> r_eci_to_ecef(GCRF(), ITRF(), date_to_jd(1986, 06, 19, 21, 35, 0), eop_IAU1980)\n3×3 StaticArrays.SArray{Tuple{3,3},Float64,2,9}:\n -0.619267    -0.78518     -0.000797313\n  0.78518     -0.619267     0.00106478\n -0.00132979   3.33492e-5   0.999999\n\njulia> r_eci_to_ecef(J2000(), PEF(), date_to_jd(1986, 06, 19, 21, 35, 0))\n3×3 StaticArrays.SArray{Tuple{3,3},Float64,2,9}:\n -0.619271    -0.785177    -0.000796885\n  0.785176    -0.619272     0.00106622\n -0.00133066   3.45854e-5   0.999999\n\njulia> r_eci_to_ecef(J2000(), PEF(), date_to_jd(1986, 06, 19, 21, 35, 0), eop_IAU1980)\n3×3 StaticArrays.SArray{Tuple{3,3},Float64,2,9}:\n -0.619267    -0.78518     -0.000796879\n  0.78518     -0.619267     0.00106623\n -0.00133066   3.45854e-5   0.999999\n\njulia> r_eci_to_ecef(Quaternion, GCRF(), ITRF(), date_to_jd(1986, 06, 19, 21, 35, 0), eop_IAU1980)\nQuaternion{Float64}:\n  + 0.4363098936462618 + 0.0005909969666939257.i - 0.00030510511316206974.j - 0.8997962182293519.k\n\njulia> eop_IAU2000A = get_iers_eop(:IAU2000A);\n\njulia> r_eci_to_ecef(GCRF(), ITRF(), date_to_jd(1986, 06, 19, 21, 35, 0), eop_IAU2000A)\n3×3 StaticArrays.SArray{Tuple{3,3},Float64,2,9}:\n -0.619267    -0.78518     -0.000797312\n  0.78518     -0.619267     0.00106478\n -0.00132979   3.33502e-5   0.999999\n\njulia> r_eci_to_ecef(GCRF(), TIRS(), date_to_jd(1986, 06, 19, 21, 35, 0))\n3×3 StaticArrays.SArray{Tuple{3,3},Float64,2,9}:\n -0.619271    -0.785177    -0.000796885\n  0.785176    -0.619272     0.00106623\n -0.00133066   3.45884e-5   0.999999\n\njulia> r_eci_to_ecef(Quaternion, GCRF(), ITRF(), date_to_jd(1986, 06, 19, 21, 35, 0), eop_IAU2000A)\nQuaternion{Float64}:\n  + 0.4363098936309669 + 0.000590996988144556.i - 0.0003051056555230158.j - 0.8997962182365703.k\n\n\n\n\n\n","category":"method"},{"location":"lib/library/#SatelliteToolbox.r_eci_to_eci-Tuple{Union{Val{:GCRF}, Val{:J2000}, Val{:TOD}, Val{:MOD}, Val{:TEME}}, Union{Val{:GCRF}, Val{:J2000}, Val{:TOD}, Val{:MOD}, Val{:TEME}}, Number, EOPData_IAU1980}","page":"Library","title":"SatelliteToolbox.r_eci_to_eci","text":"r_ecef_to_eci([T,] ECIo, ECIf, JD_UTC::Number [, eop_data])\nr_ecef_to_eci([T,] ECIo, JD_UTCo::Number, ECIf, JD_UTCf::Number [, eop_data])\n\nCompute the rotation from an Earth-Centered Inertial (ECI) reference frame to another ECI reference frame. If the origin and destination frame contain only one of date frame, then the first signature is used and JD_UTC is the epoch of this frame. On the other hand, if the origin and destination frame contain two of date frame[1], e.g. TOD => MOD, then the second signature must be used in which JD_UTCo is the epoch of the origin frame and JD_UTCf is the epoch of the destination frame.\n\nThe rotation description that will be used is given by T, which can be DCM or Quaternion. The origin ECI frame is selected by the input ECIo and the destination ECI frame is selected by the input ECIf. The model used to compute the rotation is specified by the selection of the origin and destination frames. Currently, there are two models supported: IAU-76/FK5 and IAU-2006 with 2010 conventions (CIO and equinox approaches).\n\n[1]: TEME is an of date frame.\n\nRotation description\n\nThe rotations that aligns the origin ECI frame with the destination ECI frame can be described by Direction Cosine Matrices or Quaternions. This is selected by the parameter T.\n\nThe possible values are:\n\nDCM: The rotation will be described by a Direction Cosine Matrix.\nQuaternion: The rotation will be described by a Quaternion.\n\nIf no value is specified, then it falls back to DCM.\n\nConversion model\n\nThe model that will be used to compute the rotation is automatically inferred given the selection of the origin and destination frames. Notice that mixing IAU-76/FK5 and IAU-2006/2010 frames is not supported yet.\n\nECI Frame\n\nThe supported ECI frames for both origin ECIo and destination ECIf are:\n\nTEME(): ECI will be selected as the True Equator Mean Equinox (TEME)           reference frame.\nTOD(): ECI will be selected as the True of Date (TOD).\nMOD(): ECI will be selected as the Mean of Date (MOD).\nJ2000(): ECI will be selected as the J2000 reference frame.\nGCRF(): ECI will be selected as the Geocentric Celestial Reference Frame           (GCRF).\nCIRS(): ECEF will be selected as the Celestial Intermediate Reference System           (CIRS).\nERS(): ECI will be selected as the Earth Reference System (ERS).\nMOD06(): ECI will be selected as the Mean of Date (MOD) according to the            definition in IAU-2006/2010 theory.\nMJ2000(): ECI will be selected as the J2000 mean equatorial frame (MJ2000).\n\nnote: Note\nThe frames MOD() and MOD06() are virtually the same. However, we selected different names to make clear which theory are being used since mixing transformation between frames from IAU-76/FK5 and IAU-2006/2010 must be performed with caution.\n\nEOP Data\n\nThe conversion between the frames depends on EOP Data (see get_iers_eop and read_iers_eop). If IAU-76/FK5 model is used, then the type of eop_data must be EOPData_IAU1980. Otherwise, if IAU-2006/2010 model is used, then the type of eop_data must be EOPData_IAU2000A. The following table shows the requirements for EOP data given the selected frames.\n\nModel ECIo ECIf EOP Data Function Signature\nIAU-76/FK5 GCRF J2000 EOP IAU1980 First\nIAU-76/FK5 GCRF MOD EOP IAU1980 First\nIAU-76/FK5 GCRF TOD EOP IAU1980 First\nIAU-76/FK5 GCRF TEME EOP IAU1980 First\nIAU-76/FK5 J2000 GCRF EOP IAU1980 First\nIAU-76/FK5 J2000 MOD Not required First\nIAU-76/FK5 J2000 TOD Not required First\nIAU-76/FK5 J2000 TEME Not required First\nIAU-76/FK5 MOD GCRF EOP IAU1980 First\nIAU-76/FK5 MOD J2000 Not required First\nIAU-76/FK5 MOD TOD Not required Second\nIAU-76/FK5 MOD TEME Not required Second\nIAU-76/FK5 TOD GCRF EOP IAU1980 First\nIAU-76/FK5 TOD J2000 Not required First\nIAU-76/FK5 TOD MOD Not required Second\nIAU-76/FK5 TOD TEME Not required Second\nIAU-76/FK5 TEME GCRF EOP IAU1980 First\nIAU-76/FK5 TEME J2000 Not required First\nIAU-76/FK5 TEME MOD Not required Second\nIAU-76/FK5 TEME TOD Not required Second\nIAU-2006/2010 CIO-based GCRF CIRS Not required¹ First\nIAU-2006/2010 CIO-based CIRS CIRS Not required¹ Second\nIAU-2006/2010 Equinox-based GCRF MJ2000 Not required First²\nIAU-2006/2010 Equinox-based GCRF MOD06 Not required First\nIAU-2006/2010 Equinox-based GCRF ERS Not required³ First\nIAU-2006/2010 Equinox-based MJ2000 GCRF Not required First²\nIAU-2006/2010 Equinox-based MJ2000 MOD06 Not required First\nIAU-2006/2010 Equinox-based MJ2000 ERS Not required³ First\nIAU-2006/2010 Equinox-based MOD06 GCRF Not required First\nIAU-2006/2010 Equinox-based MOD06 MJ2000 Not required First\nIAU-2006/2010 Equinox-based MOD06 ERS Not required³ First\nIAU-2006/2010 Equinox-based ERS GCRF Not required³ First\nIAU-2006/2010 Equinox-based ERS MJ2000 Not required³ First\nIAU-2006/2010 Equinox-based ERS MOD06 Not required³ First\n\n¹: In this case, the terms that account for the free-core nutation and time dependent effects of the Celestial Intermediate Pole (CIP) position with respect to the GCRF will not be available, reducing the precision.\n\n²: The transformation between GCRF and MJ2000 is a constant rotation matrix called bias. Hence, the date does not modify it. However, this signature was kept to avoid complications in the API.\n\n³: In this case, the terms that corrects the nutation in obliquity and in longitude due to the free core nutation will not be available, reducing the precision.\n\nMOD and TOD\n\nIn this function, if EOP corrections are not provided, then MOD and TOD frames will be computed considering the original IAU-76/FK5 theory. Otherwise, the corrected frame will be used.\n\nReturns\n\nThe rotation description represented by T that rotates the origin ECI reference frame into alignment with the destination ECI reference frame.\n\nExamples\n\njulia> eop_IAU1980 = get_iers_eop(:IAU1980);\n\njulia> r_eci_to_eci(DCM, GCRF(), J2000(), date_to_jd(1986, 6, 19, 21, 35, 0), eop_IAU1980)\n3×3 StaticArrays.SArray{Tuple{3,3},Float64,2,9}:\n  1.0          -2.45469e-12   4.56602e-10\n  2.45466e-12   1.0          -1.84455e-9\n -4.56602e-10   1.84455e-9    1.0\n\njulia> r_eci_to_eci(Quaternion, TEME(), GCRF(), date_to_jd(1986, 6, 19, 21, 35, 0), eop_IAU1980)\nQuaternion{Float64}:\n  + 0.9999986335698654 + 1.8300414020900853e-5.i + 0.0006653038276169474.j - 0.0015132396749411375.k\n\njulia> r_eci_to_eci(TOD(), date_to_jd(1986,6,19,21,35,0), TOD(), date_to_jd(1987,5,19,3,0,0), eop_IAU1980)\n3×3 StaticArrays.SArray{Tuple{3,3},Float64,2,9}:\n 1.0          -0.000224087  -9.73784e-5\n 0.000224086   1.0          -5.79859e-6\n 9.73797e-5    5.77677e-6    1.0\n\njulia> r_eci_to_eci(Quaternion, TOD(), JD_J2000, MOD(), JD_J2000, eop_IAU1980)\nQuaternion{Float64}:\n  + 0.9999999993282687 - 1.400220690336851e-5.i + 1.3473593746216003e-5.j - 3.107834312843103e-5.k\n\njulia> r_eci_to_eci(J2000(), TEME(), date_to_jd(1986,6,19,21,35,0))\n3×3 StaticArrays.SArray{Tuple{3,3},Float64,2,9}:\n  0.999995    0.0030265    0.00133055\n -0.00302645  0.999995    -3.86125e-5\n -0.00133066  3.45854e-5   0.999999\n\njulia> eop_IAU2000A = get_iers_eop(:IAU2000A);\n\njulia> r_eci_to_eci(CIRS(), GCRF(), date_to_jd(1986,6,19,21,35,0), eop_IAU2000A)\n3×3 StaticArrays.SArray{Tuple{3,3},Float64,2,9}:\n 0.999999     3.88379e-8  -0.00133066\n 7.18735e-9   1.0          3.45882e-5\n 0.00133066  -3.45882e-5   0.999999\n\njulia> r_eci_to_eci(Quaternion, CIRS(), GCRF(), date_to_jd(1986,6,19,21,35,0), eop_IAU2000A)\nQuaternion{Float64}:\n  + 0.9999997785177528 + 1.7294102099105917e-5.i + 0.0006653310148723835.j + 7.912627369563795e-9.k\n\n\n\n\n\n","category":"method"},{"location":"lib/library/#SatelliteToolbox.r_ers_to_mod_iau2006","page":"Library","title":"SatelliteToolbox.r_ers_to_mod_iau2006","text":"r_ers_to_mod_iau2006([T::Type,] JD_TT::Number, δΔϵ_2000::Number = 0, δΔΨ_2000::Number = 0)\n\nCompute the rotation that aligns the Earth Reference System (ERS) with the Mean of Date (MOD) reference frame at Julian day JD_TT [Terrestrial Time]. This algorithm uses the IAU-2006 theory.\n\nNotice that one can provide corrections for the nutation in obliquity (δΔϵ_2000) and in longitude (δΔψ_2000) [rad] that are usually obtained from IERS EOP Data (see get_iers_eop and deps_dpsi). This corrections are related to Free Core Nutation (FCN) that models the effect of a liquid Earth core.\n\nThe rotation type is described by the optional variable T. If it is DCM, then a DCM will be returned. Otherwise, if it is Quaternion, then a Quaternion will be returned. In case this parameter is omitted, then it falls back to DCM.\n\nReturns\n\nThe rotation that aligns the ERS frame with the MOD frame. The rotation representation is selected by the optional parameter T.\n\nRemarks\n\nThe reference systems ERS and MOD are separated by the nutation of the pole.\n\n\n\n\n\n","category":"function"},{"location":"lib/library/#SatelliteToolbox.r_ers_to_tirs_iau2006","page":"Library","title":"SatelliteToolbox.r_ers_to_tirs_iau2006","text":"r_ers_to_tirs_iau2006(JD_UT1::Number, JD_TT::Number, δΔΨ_2000::Number = 0)\n\nCompute the rotation that aligns the Earth Reference System (ERS) with the Terrestrial Intermediate Reference System (TIRS) at the Julian Day JD_UT1 [UT1] and JD_TT [Terrestrial Time]. This algorithm uses the IAU-2006 theory.\n\nNotice that one can provide corrections for the nutation in longitude (δΔψ_2000) [rad] that are usually obtained from IERS EOP Data (see get_iers_eop and deps_dpsi). This corrections are related to Free Core Nutation (FCN) that models the effect of a liquid Earth core.\n\nThe rotation type is described by the optional variable T. If it is DCM, then a DCM will be returned. Otherwise, if it is Quaternion, then a Quaternion will be returned. In case this parameter is omitted, then it falls back to DCM.\n\nReturns\n\nThe rotation that aligns the ERS frame with the TIRS frame. The rotation representation is selected by the optional parameter T.\n\nRemarks\n\nThe reference frames TIRS and ERS are separated by a rotation about the Z-axis of the Greenwhich apparent sidereal angle (GAST). This angle is computed using the IAU-2006 theory, which consist of obtaining the Earth Rotation Angle (ERA) and subtracting the result of the Equation of Origins (EO).\n\n\n\n\n\n","category":"function"},{"location":"lib/library/#SatelliteToolbox.r_gcrf_to_cirs_iau2006","page":"Library","title":"SatelliteToolbox.r_gcrf_to_cirs_iau2006","text":"r_gcrf_to_cirs_iau2006([T::Type,] JD_TT::Number, dX::Number = 0, dY::Number = 0)\n\nCompute the rotation that aligns the Geocentric Celestial Reference Frame (GCRF) with the Celestial Intermediate Reference System (CIRS) at the Julian Day JD_TT [TT] and considering the IERS EOP Data dX [rad] and dY [rad] (see get_iers_eop). This algorithm uses the IAU-2006 theory.\n\nThe IERS EOP Data dX and dY accounts for the free-core nutation and time dependent effects of the Celestial Intermediate Pole (CIP) position with respect to the GCRF.\n\nThe rotation type is described by the optional variable T. If it is DCM, then a DCM will be returned. Otherwise, if it is Quaternion, then a Quaternion will be returned. In case this parameter is omitted, then it falls back to DCM.\n\nReturns\n\nThe rotation that aligns the GCRF frame with the CIRS frame. The rotation representation is selected by the optional parameter T.\n\n\n\n\n\n","category":"function"},{"location":"lib/library/#SatelliteToolbox.r_gcrf_to_itrf_fk5","page":"Library","title":"SatelliteToolbox.r_gcrf_to_itrf_fk5","text":"r_gcrf_to_itrf_fk5([T,] JD_UT1::Number, JD_TT::Number, x_p::Number, y_p::Number [, δΔϵ_1980::Number, δΔψ_1980::Number])\n\nCompute the rotation that aligns the Geocentric Celestial Reference Frame (GCRF) with the International Terrestrial Reference Frame (ITRF) at the Julian Day JD_UT1 [UT1] and JD_TT [Terrestrial Time], and considering the IERS EOP Data x_p [rad], y_p [rad], δΔϵ_1980 [rad], and δΔψ_1980 [rad] (see get_iers_eop). This algorithm uses the IAU-76/FK5 theory.\n\nx_p is the polar motion displacement about X-axis, which is the IERS Reference Meridian direction (positive south along the 0˚ longitude meridian). y_p is the polar motion displacement about Y-axis (90˚W or 270˚E meridian). δΔϵ_1980 is the nutation in obliquity. δΔψ_1980 is the nutation in longitude.\n\nThe Julian Day in UT1 is used to compute the Greenwich Mean Sidereal Time (GMST) (see jd_to_gmst), whereas the Julian Day in Terrestrial Time is used to compute the nutation in the longitude. Notice that the Julian Day in UT1 and in Terrestrial Time must be equivalent, i.e. must be related to the same instant. This function does not check this.\n\nThe rotation type is described by the optional variable T. If it is DCM, then a DCM will be returned. Otherwise, if it is Quaternion, then a Quaternion will be returned. In case this parameter is omitted, then it falls back to DCM.\n\nReturns\n\nThe rotation that aligns the GCRF frame with the ITRF frame. The rotation representation is selected by the optional parameter T.\n\nRemarks\n\nThe EOP data related to the polar motion (x_p and y_p) is required, since this is the only way available to compute the conversion ITRF <=> PEF (the models are highly imprecise since the motion is still not very well understood [1]). However, the EOP data related to the nutation of the obliquity (δΔϵ_1980) and the nutation of the longitude (δΔψ_1980) can be omitted. In this case, the GCRF frame is what is usually called J2000 reference frame.\n\n\n\n\n\n","category":"function"},{"location":"lib/library/#SatelliteToolbox.r_gcrf_to_mj2000_iau2006","page":"Library","title":"SatelliteToolbox.r_gcrf_to_mj2000_iau2006","text":"r_gcrf_to_mj2000_iau2006([T::Type,] JD_TT::Number = 0)\n\nCompute the rotation that aligns the Geocentric Celestial Reference Frame (GCRF) with the J2000 mean equatorial frame. This algorithm uses the IAU-2006 theory. Notice that this rotation is just a bias matrix that does not depend on the date. However, this function receives the argument JD_TT just to keep the API compatibility.\n\nThe rotation type is described by the optional variable T. If it is DCM, then a DCM will be returned. Otherwise, if it is Quaternion, then a Quaternion will be returned. In case this parameter is omitted, then it falls back to DCM.\n\nReturns\n\nThe rotation that aligns the MJ2000 frame with the MOD frame. The rotation representation is selected by the optional parameter T.\n\nRemarks\n\nAccording to [1], the frame bias that converts MJ2000 <=> GCRF is not a precise transformation for all the times.\n\n\n\n\n\n","category":"function"},{"location":"lib/library/#SatelliteToolbox.r_gcrf_to_mod_fk5-Tuple{Number}","page":"Library","title":"SatelliteToolbox.r_gcrf_to_mod_fk5","text":"r_gcrf_to_mod_fk5([T,] JD_TT::Number)\n\nCompute the rotation that aligns the Geocentric Celestial Reference Frame (GCRF) with the Mean of Date (MOD) frame at the Julian Day [Terrestrial Time] JD_TT. This algorithm uses the IAU-76/FK5 theory.\n\nThe rotation type is described by the optional variable T. If it is DCM, then a DCM will be returned. Otherwise, if it is Quaternion, then a Quaternion will be returned. In case this parameter is omitted, then it falls back to DCM.\n\nReturns\n\nThe rotation that aligns the GCRF frame with the MOD frame. The rotation representation is selected by the optional parameter T.\n\nRemarks\n\nThe Geocentric Celestial Reference Frame (GCRF) is rotated into the Mean of Date (MOD) frame considering the IAU 1976 Precession model.\n\nNotice that if the conversion MOD => TOD is performed without considering the EOP corrections, then the GCRF in this rotation is what is usually called the J2000 reference frame.\n\n\n\n\n\n","category":"method"},{"location":"lib/library/#SatelliteToolbox.r_gcrf_to_teme","page":"Library","title":"SatelliteToolbox.r_gcrf_to_teme","text":"r_gcrf_to_teme([T,] JD_TT::Number [, δΔϵ_1980::Number = 0, δΔψ_1980::Number = 0])\n\nCompute the rotation that aligns the GCRF frame with the True Equator Mean Equinox (TEME) frame at the Julian Day JD_TT [Terrestrial Time]. This algorithm uses the IAU-76/FK5 theory and TEME definition in [1, p. 233]. Notice that one can provide corrections for the nutation in obliquity (δΔϵ_1980) [rad] and in longitude (δΔψ_1980) [rad] that are usually obtained from IERS EOP Data (see get_iers_eop).\n\nThe rotation type is described by the optional variable T. If it is DCM, then a DCM will be returned. Otherwise, if it is Quaternion, then a Quaternion will be returned. In case this parameter is omitted, then it falls back to DCM.\n\nReturns\n\nThe rotation that aligns the GCRF frame with the TEME frame. The rotation representation is selected by the optional parameter T.\n\nRemarks\n\nThe EOP data related to the nutation of the obliquity (δΔϵ_1980) and the nutation of the longitude (δΔψ_1980) can be omitted. In this case, the GCRF frame is what is usually called J2000 reference frame.\n\n\n\n\n\n","category":"function"},{"location":"lib/library/#SatelliteToolbox.r_itrf_to_gcrf_fk5","page":"Library","title":"SatelliteToolbox.r_itrf_to_gcrf_fk5","text":"r_itrf_to_gcrf_fk5([T,] JD_UT1::Number, JD_TT::Number, x_p::Number, y_p::Number [, δΔϵ_1980::Number, δΔψ_1980::Number])\n\nCompute the rotation that aligns the International Terrestrial Reference Frame (ITRF) with the Geocentric Celestial Reference Frame (GCRF) at the Julian Day JD_UT1 [UT1] and JD_TT [Terrestrial Time], and considering the IERS EOP Data x_p [rad], y_p [rad], δΔϵ_1980 [rad], and δΔψ_1980 [rad] (see get_iers_eop). This algorithm uses the IAU-76/FK5 theory.\n\nx_p is the polar motion displacement about X-axis, which is the IERS Reference Meridian direction (positive south along the 0˚ longitude meridian). y_p is the polar motion displacement about Y-axis (90˚W or 270˚E meridian). δΔϵ_1980 is the nutation in obliquity. δΔψ_1980 is the nutation in longitude.\n\nThe Julian Day in UT1 is used to compute the Greenwich Mean Sidereal Time (GMST) (see jd_to_gmst), whereas the Julian Day in Terrestrial Time is used to compute the nutation in the longitude. Notice that the Julian Day in UT1 and in Terrestrial Time must be equivalent, i.e. must be related to the same instant. This function does not check this.\n\nThe rotation type is described by the optional variable T. If it is DCM, then a DCM will be returned. Otherwise, if it is Quaternion, then a Quaternion will be returned. In case this parameter is omitted, then it falls back to DCM.\n\nReturns\n\nThe rotation that aligns the ITRF frame with the GCRF frame. The rotation representation is selected by the optional parameter T.\n\nRemarks\n\nThe EOP data related to the polar motion (x_p and y_p) is required, since this is the only way available to compute the conversion ITRF <=> PEF (the models are highly imprecise since the motion is still not very well understood [1]). However, the EOP data related to the nutation of the obliquity (δΔϵ_1980) and the nutation of the longitude (δΔψ_1980) can be omitted. In this case, the GCRF frame is what is usually called J2000 reference frame.\n\n\n\n\n\n","category":"function"},{"location":"lib/library/#SatelliteToolbox.r_itrf_to_pef_fk5-Tuple{Number, Number}","page":"Library","title":"SatelliteToolbox.r_itrf_to_pef_fk5","text":"r_itrf_to_pef_fk5([T,] x_p::Number, y_p::Number)\n\nCompute the rotation that aligns the International Terrestrial Reference Frame (ITRF) with the Pseudo-Earth Fixed (PEF) frame considering the polar motion represented by the angles x_p [rad] and y_p [rad] that are obtained from IERS EOP Data (see get_iers_eop).\n\nx_p is the polar motion displacement about X-axis, which is the IERS Reference Meridian direction (positive south along the 0˚ longitude meridian). y_p is the polar motion displacement about Y-axis (90˚W or 270˚E meridian).\n\nThe rotation type is described by the optional variable T. If it is DCM, then a DCM will be returned. Otherwise, if it is Quaternion, then a Quaternion will be returned. In case this parameter is omitted, then it falls back to DCM.\n\nReturns\n\nThe rotation that aligns the ITRF frame with the PEF frame. The rotation representation is selected by the optional parameter T.\n\nRemarks\n\nThe ITRF is defined based on the International Reference Pole (IRP), which is the location of the terrestrial pole agreed by international committees [1]. The Pseudo-Earth Fixed, on the other hand, is defined based on the Earth axis of rotation, or the Celestial Intermediate Pole (CIP). Hence, PEF XY-plane contains the True Equator. Furthermore, since the recovered latitude and longitude are sensitive to the CIP, then it should be computed considering the PEF frame.\n\n\n\n\n\n","category":"method"},{"location":"lib/library/#SatelliteToolbox.r_itrf_to_tirs_iau2006-Tuple{Number, Number, Number}","page":"Library","title":"SatelliteToolbox.r_itrf_to_tirs_iau2006","text":"r_itrf_to_tirs_iau2006([T::Type,] JD_TT::Number, x_p::Number, y_p::Number)\n\nCompute the rotation that aligns the International Terrestrial Reference Frame (ITRF) with the Terrestrial Intermediate Reference System (TIRS) considering the polar motion represented by the angles x_p [rad] and y_p [rad] that are obtained from IERS EOP Data (see get_iers_eop).\n\nx_p is the polar motion displacement about X-axis, which is the IERS Reference Meridian direction (positive south along the 0˚ longitude meridian). y_p is the polar motion displacement about Y-axis (90˚W or 270˚E meridian).\n\nThe rotation type is described by the optional variable T. If it is DCM, then a DCM will be returned. Otherwise, if it is Quaternion, then a Quaternion will be returned. In case this parameter is omitted, then it falls back to DCM.\n\nReturns\n\nThe rotation that aligns the ITRF frame with the TIRS frame. The rotation representation is selected by the optional parameter T.\n\nRemarks\n\nThe ITRF is defined based on the International Reference Pole (IRP), which is the location of the terrestrial pole agreed by international committees [1]. The Terrestrial Intermediate Reference Frame (TIRS), on the other hand, is defined based on the Earth axis of rotation, or the Celestial Intermediate Pole (CIP). Hence, TIRS XY-plane contains the True Equator. Furthermore, since the recovered latitude and longitude are sensitive to the CIP, then it should be computed considering the TIRS frame.\n\nThe TIRS and PEF (IAU-76/FK5) are virtually the same reference frame, but according to [1] it is convenient to separate the names as the exact formulae differ.\n\n\n\n\n\n","category":"method"},{"location":"lib/library/#SatelliteToolbox.r_mj2000_to_gcrf_iau2006","page":"Library","title":"SatelliteToolbox.r_mj2000_to_gcrf_iau2006","text":"r_mj2000_to_gcrf_iau2006([T::Type,] JD_TT::Number = 0)\n\nCompute the rotation that aligns the J2000 mean equatorial frame with the Geocentric Celestial Reference Frame (GCRF). This algorithm uses the IAU-2006 theory. Notice that this rotation is just a bias matrix that does not depend on the date. However, this function receives the argument JD_TT just to keep the API compatibility.\n\nThe rotation type is described by the optional variable T. If it is DCM, then a DCM will be returned. Otherwise, if it is Quaternion, then a Quaternion will be returned. In case this parameter is omitted, then it falls back to DCM.\n\nReturns\n\nThe rotation that aligns the MJ2000 frame with the MOD frame. The rotation representation is selected by the optional parameter T.\n\nRemarks\n\nAccording to [1], the frame bias that converts MJ2000 <=> GCRF is not a precise transformation for all the times.\n\n\n\n\n\n","category":"function"},{"location":"lib/library/#SatelliteToolbox.r_mj2000_to_mod_iau2006-Tuple{Number}","page":"Library","title":"SatelliteToolbox.r_mj2000_to_mod_iau2006","text":"r_mj2000_to_mod_iau2006([T::Type,] JD_TT::Number)\n\nCompute the rotation that aligns the J2000 mean equatorial frame with the Mean of Date (MOD) reference frame with the at Julian day JD_TT [Terrestrial Time]. This algorithm uses the IAU-2006 theory.\n\nThe rotation type is described by the optional variable T. If it is DCM, then a DCM will be returned. Otherwise, if it is Quaternion, then a Quaternion will be returned. In case this parameter is omitted, then it falls back to DCM.\n\nReturns\n\nThe rotation that aligns the MJ2000 frame with the MOD frame. The rotation representation is selected by the optional parameter T.\n\nRemarks\n\nThe J2000 reference frame here is not equal to the previous definition in FK5 theory. It is the reason why it is internally called MJ2000. According to [3]:\n\nThe mean equinox of J2000.0 to be considered is not the “rotational dynamical mean equinox of J2000.0” as used in the past, but the “inertial dynamical mean equinox of J2000.0” to which the recent numerical or analytical solutions refer.  The latter is associated with the ecliptic in the inertial sense, which is the plane perpendicular to the angular momentum vector of the orbital motion of the Earth-Moon barycenter as computed from the velocity of the barycenter relative to an inertial system. The rotational equinox is associated with the ecliptic in the rotational sense, which is perpendicular to the angular momentum vector computed from the velocity referred to the rotating orbital plane of the Earth-Moon barycenter. (The difference between the two angular momenta is the angular momentum associated with the rotation of the orbital plane.)\n\n\n\n\n\n","category":"method"},{"location":"lib/library/#SatelliteToolbox.r_mod_to_ers_iau2006","page":"Library","title":"SatelliteToolbox.r_mod_to_ers_iau2006","text":"r_mod_to_ers_iau2006([T::Type,] JD_TT::Number, δΔϵ_2000::Number = 0, δΔΨ_2000::Number = 0)\n\nCompute the rotation that aligns the Mean of Date (MOD) reference frame with the Earth Reference System (ERS) at Julian day JD_TT [Terrestrial Time]. This algorithm uses the IAU-2006 theory.\n\nNotice that one can provide corrections for the nutation in obliquity (δΔϵ_2000) and in longitude (δΔψ_2000) [rad] that are usually obtained from IERS EOP Data (see get_iers_eop and deps_dpsi). This corrections are related to Free Core Nutation (FCN) that models the effect of a liquid Earth core.\n\nThe rotation type is described by the optional variable T. If it is DCM, then a DCM will be returned. Otherwise, if it is Quaternion, then a Quaternion will be returned. In case this parameter is omitted, then it falls back to DCM.\n\nReturns\n\nThe rotation that aligns the MOD frame with the ERS frame. The rotation representation is selected by the optional parameter T.\n\n\n\n\n\n","category":"function"},{"location":"lib/library/#SatelliteToolbox.r_mod_to_gcrf_fk5-Tuple{Number}","page":"Library","title":"SatelliteToolbox.r_mod_to_gcrf_fk5","text":"r_mod_to_gcrf_fk5([T,] JD_TT::Number)\n\nCompute the rotation that aligns the Mean of Date (MOD) frame with the Geocentric Celestial Reference Frame (GCRF) at the Julian Day [Terrestrial Time] JD_TT. This algorithm uses the IAU-76/FK5 theory.\n\nThe rotation type is described by the optional variable T. If it is DCM, then a DCM will be returned. Otherwise, if it is Quaternion, then a Quaternion will be returned. In case this parameter is omitted, then it falls back to DCM.\n\nReturns\n\nThe rotation that aligns the MOD frame with the GCRF frame. The rotation representation is selected by the optional parameter T.\n\nRemarks\n\nThe Mean of Date (MOD) frame is rotated into the Geocentric Celestial Reference Frame (GCRF) considering the IAU 1976 Precession model.\n\nNotice that if the conversion TOD => MOD is performed without considering the EOP corrections, then the GCRF obtained by this rotation is what is usually called the J2000 reference frame.\n\n\n\n\n\n","category":"method"},{"location":"lib/library/#SatelliteToolbox.r_mod_to_mj2000_iau2006-Tuple{Number}","page":"Library","title":"SatelliteToolbox.r_mod_to_mj2000_iau2006","text":"r_mod_to_mj2000_iau2006([T::Type,] JD_TT::Number)\n\nCompute the rotation that aligns the Mean of Date (MOD) reference frame with the J2000 mean equatorial frame at Julian day JD_TT [Terrestrial Time]. This algorithm uses the IAU-2006 theory.\n\nThe rotation type is described by the optional variable T. If it is DCM, then a DCM will be returned. Otherwise, if it is Quaternion, then a Quaternion will be returned. In case this parameter is omitted, then it falls back to DCM.\n\nReturns\n\nThe rotation that aligns the MOD frame with the MJ2000 frame. The rotation representation is selected by the optional parameter T.\n\nRemarks\n\nThe J2000 reference frame here is not equal to the previous definition in FK5 theory. It is the reason why it is internally called MJ2000. According to [3]:\n\nThe mean equinox of J2000.0 to be considered is not the “rotational dynamical mean equinox of J2000.0” as used in the past, but the “inertial dynamical mean equinox of J2000.0” to which the recent numerical or analytical solutions refer.  The latter is associated with the ecliptic in the inertial sense, which is the plane perpendicular to the angular momentum vector of the orbital motion of the Earth-Moon barycenter as computed from the velocity of the barycenter relative to an inertial system. The rotational equinox is associated with the ecliptic in the rotational sense, which is perpendicular to the angular momentum vector computed from the velocity referred to the rotating orbital plane of the Earth-Moon barycenter. (The difference between the two angular momenta is the angular momentum associated with the rotation of the orbital plane.)\n\n\n\n\n\n","category":"method"},{"location":"lib/library/#SatelliteToolbox.r_mod_to_pef_fk5","page":"Library","title":"SatelliteToolbox.r_mod_to_pef_fk5","text":"r_mod_to_pef_fk5([T,] JD_UT1::Number, JD_TT::Number [, δΔϵ_1980::Number, δΔψ_1980::Number])\n\nCompute the rotation that aligns the Mean of Date (MOD) reference frame with the Pseudo-Earth Fixed (PEF) frame at the Julian Day JD_UT1 [UT1] and JD_TT [Terrestrial Time]. This algorithm uses the IAU-76/FK5 theory. Notice that one can provide corrections for the nutation in obliquity (δΔϵ_1980) [rad] and in longitude (δΔψ_1980) [rad] that are usually obtained from IERS EOP Data (see get_iers_eop).\n\nThe Julian Day in UT1 is used to compute the Greenwich Mean Sidereal Time (GMST) (see jd_to_gmst), whereas the Julian Day in Terrestrial Time is used to compute the nutation in the longitude. Notice that the Julian Day in UT1 and in Terrestrial Time must be equivalent, i.e. must be related to the same instant. This function does not check this.\n\nThe rotation type is described by the optional variable T. If it is DCM, then a DCM will be returned. Otherwise, if it is Quaternion, then a Quaternion will be returned. In case this parameter is omitted, then it falls back to DCM.\n\nReturns\n\nThe rotation that aligns the MOD frame with the PEF frame. The rotation representation is selected by the optional parameter T.\n\n\n\n\n\n","category":"function"},{"location":"lib/library/#SatelliteToolbox.r_mod_to_teme","page":"Library","title":"SatelliteToolbox.r_mod_to_teme","text":"r_mod_to_teme([T,] JD_TT::Number [, δΔϵ_1980::Number = 0, δΔψ_1980::Number = 0])\n\nCompute the rotation that aligns the Mean of Date (MOD) frame with the True Equator Mean Equinox (TEME) frame at the Julian Day JD_TT [Terrestrial Time]. This algorithm uses the IAU-76/FK5 theory and TEME definition in [1, p. 233]. Notice that one can provide corrections for the nutation in obliquity (δΔϵ_1980) [rad] and in longitude (δΔψ_1980) [rad] that are usually obtained from IERS EOP Data (see get_iers_eop).  .\n\nThe rotation type is described by the optional variable T. If it is DCM, then a DCM will be returned. Otherwise, if it is Quaternion, then a Quaternion will be returned. In case this parameter is omitted, then it falls back to DCM.\n\nReturns\n\nThe rotation that aligns the MOD frame with the TEME frame. The rotation representation is selected by the optional parameter T.\n\n\n\n\n\n","category":"function"},{"location":"lib/library/#SatelliteToolbox.r_mod_to_tirs_iau2006","page":"Library","title":"SatelliteToolbox.r_mod_to_tirs_iau2006","text":"r_mod_to_tirs_iau2006([T::Type,] JD_UT1::Number, JD_TT::Number, δΔϵ_2000::Number = 0, δΔΨ_2000::Number = 0)\n\nCompute the rotation that aligns the Mean of Date (MOD) reference frame with the Terrestrial Intermediate Reference System (TIRS) at the Julian Day JD_UT1 [UT1] and JD_TT [Terrestrial Time]. This algorithm uses the IAU-2006 theory.\n\nNotice that one can provide corrections for the nutation in obliquity (δΔϵ_2000) and in longitude (δΔψ_2000) [rad] that are usually obtained from IERS EOP Data (see get_iers_eop and deps_dpsi). This corrections are related to Free Core Nutation (FCN) that models the effect of a liquid Earth core.\n\nThe rotation type is described by the optional variable T. If it is DCM, then a DCM will be returned. Otherwise, if it is Quaternion, then a Quaternion will be returned. In case this parameter is omitted, then it falls back to DCM.\n\nReturns\n\nThe rotation that aligns the TIRS frame with the ERS frame. The rotation representation is selected by the optional parameter T.\n\nRemarks\n\nThis composed rotation TIRS <=> ERS <=> MOD is implemented as a new function because the single rotations TIRS <=> ERS and ERS <=> MOD call the function nutation_eo, which has a high computational burden. In this case, the composed algorithm is about 2x faster than calling those function separately.\n\n\n\n\n\n","category":"function"},{"location":"lib/library/#SatelliteToolbox.r_mod_to_tod_fk5","page":"Library","title":"SatelliteToolbox.r_mod_to_tod_fk5","text":"r_mod_to_tod_fk5([T,] JD_TT::Number [, δΔϵ_1980::Number, δΔψ_1980::Number])\n\nCompute the rotation that aligns the Mean of Date (MOD) frame with the True of Date (TOD) frame at the Julian Day JD_TT [Terrestrial Time]. This algorithm uses the IAU-76/FK5 theory. Notice that one can provide corrections for the nutation in obliquity (δΔϵ_1980) [rad] and in longitude (δΔψ_1980) [rad] that are usually obtained from IERS EOP Data (see get_iers_eop).\n\nThe rotation type is described by the optional variable T. If it is DCM, then a DCM will be returned. Otherwise, if it is Quaternion, then a Quaternion will be returned. In case this parameter is omitted, then it falls back to DCM.\n\nReturns\n\nThe rotation that aligns the MOD frame with the TOD frame. The rotation representation is selected by the optional parameter T.\n\nRemarks\n\nThe Mean of Date (MOD) frame is rotated into the True of Date (TOD) frame considering the 1980 IAU Theory of Nutation. The IERS EOP corrections must be added if one wants to make the rotation consistent with the Geocentric Celestial Reference Systems (GCRS).\n\n\n\n\n\n","category":"function"},{"location":"lib/library/#SatelliteToolbox.r_pef_to_itrf_fk5-Tuple{Number, Number}","page":"Library","title":"SatelliteToolbox.r_pef_to_itrf_fk5","text":"r_pef_to_itrf_fk5([T,] x_p::Number, y_p::Number)\n\nCompute the rotation that aligns the Pseudo-Earth Fixed (PEF) with the International Terrestrial Reference Frame (ITRF) considering the polar motion represented by the angles x_p [rad] and y_p [rad] that are obtained from IERS EOP Data (see get_iers_eop).\n\nx_p is the polar motion displacement about X-axis, which is the IERS Reference Meridian direction (positive south along the 0˚ longitude meridian). y_p is the polar motion displacement about Y-axis (90˚W or 270˚E meridian).\n\nThe rotation type is described by the optional variable T. If it is DCM, then a DCM will be returned. Otherwise, if it is Quaternion, then a Quaternion will be returned. In case this parameter is omitted, then it falls back to DCM.\n\nReturns\n\nThe rotation that aligns the PEF frame with the ITRF. The rotation representation is selected by the optional parameter T.\n\nRemarks\n\nThe ITRF is defined based on the International Reference Pole (IRP), which is the location of the terrestrial pole agreed by international committees [1]. The Pseudo-Earth Fixed, on the other hand, is defined based on the Earth axis of rotation, or the Celestial Intermediate Pole (CIP). Hence, PEF XY-plane contains the True Equator. Furthermore, since the recovered latitude and longitude are sensitive to the CIP, then it should be computed considering the PEF frame.\n\n\n\n\n\n","category":"method"},{"location":"lib/library/#SatelliteToolbox.r_pef_to_mod_fk5","page":"Library","title":"SatelliteToolbox.r_pef_to_mod_fk5","text":"r_pef_to_mod_fk5([T,] JD_UT1::Number, JD_TT::Number [, δΔϵ_1980::Number, δΔψ_1980::Number])\n\nCompute the rotation that aligns the Pseudo-Earth Fixed (PEF) frame with the Mean of Date (MOD) at the Julian Day JD_UT1 [UT1] and JD_TT [Terrestrial Time]. This algorithm uses the IAU-76/FK5 theory. Notice that one can provide corrections for the nutation in obliquity (δΔϵ_1980) [rad] and in longitude (δΔψ_1980) [rad] that are usually obtained from IERS EOP Data (see get_iers_eop).\n\nThe Julian Day in UT1 is used to compute the Greenwich Mean Sidereal Time (GMST) (see jd_to_gmst), whereas the Julian Day in Terrestrial Time is used to compute the nutation in the longitude. Notice that the Julian Day in UT1 and in Terrestrial Time must be equivalent, i.e. must be related to the same instant. This function does not check this.\n\nThe rotation type is described by the optional variable T. If it is DCM, then a DCM will be returned. Otherwise, if it is Quaternion, then a Quaternion will be returned. In case this parameter is omitted, then it falls back to DCM.\n\nReturns\n\nThe rotation that aligns the PEF frame with the TOD frame. The rotation representation is selected by the optional parameter T.\n\n\n\n\n\n","category":"function"},{"location":"lib/library/#SatelliteToolbox.r_pef_to_teme-Tuple{Number}","page":"Library","title":"SatelliteToolbox.r_pef_to_teme","text":"r_pef_to_teme([T,] JD_TT::Number)\n\nCompute the rotation that aligns the Pseudo-Earth Fixed (PEF) frame with the True Equator Mean Equinox (TEME) frame at the Julian Day JD_TT [Terrestrial Time]. This algorithm uses the IAU-76/FK5 theory and TEME definition in [1, p. 233].\n\nThe rotation type is described by the optional variable T. If it is DCM, then a DCM will be returned. Otherwise, if it is Quaternion, then a Quaternion will be returned. In case this parameter is omitted, then it falls back to DCM.\n\nReturns\n\nThe rotation that aligns the PEF frame with the TEME frame. The rotation representation is selected by the optional parameter T.\n\n\n\n\n\n","category":"method"},{"location":"lib/library/#SatelliteToolbox.r_pef_to_tod_fk5","page":"Library","title":"SatelliteToolbox.r_pef_to_tod_fk5","text":"r_pef_to_tod_fk5([T,] JD_UT1::Number, JD_TT::Number [, δΔψ_1980::Number])\n\nCompute the rotation that aligns the Pseudo-Earth Fixed (PEF) frame with the True of Date (TOD) frame at the Julian Day JD_UT1 [UT1] and JD_TT [Terrestrial Time]. This algorithm uses the IAU-76/FK5 theory. Notice that one can provide correction for the nutation in longitude (δΔψ_1980) [rad] that is usually obtained from IERS EOP Data (see get_iers_eop).\n\nThe Julian Day in UT1 is used to compute the Greenwich Mean Sidereal Time (GMST) (see jd_to_gmst), whereas the Julian Day in Terrestrial Time is used to compute the nutation in the longitude. Notice that the Julian Day in UT1 and in Terrestrial Time must be equivalent, i.e. must be related to the same instant. This function does not check this.\n\nThe rotation type is described by the optional variable T. If it is DCM, then a DCM will be returned. Otherwise, if it is Quaternion, then a Quaternion will be returned. In case this parameter is omitted, then it falls back to DCM.\n\nReturns\n\nThe rotation that aligns the PEF frame with the TOD frame. The rotation representation is selected by the optional parameter T.\n\nRemarks\n\nThe Pseudo-Earth Fixed (PEF) frame is rotated into the True of Date (TOD) frame considering the 1980 IAU Theory of Nutation. The IERS EOP corrections must be added if one wants to make the rotation consistent with the Geocentric Celestial Reference Systems (GCRS).\n\n\n\n\n\n","category":"function"},{"location":"lib/library/#SatelliteToolbox.r_teme_to_gcrf","page":"Library","title":"SatelliteToolbox.r_teme_to_gcrf","text":"r_teme_to_gcrf([T,] JD_TT::Number [, δΔϵ_1980::Number = 0, δΔψ_1980::Number = 0])\n\nCompute the rotation that aligns the True Equator Mean Equinox (TEME) frame with the Geocentric Celestial Reference Frame (GCRF) at the Julian Day JD_TT [Terrestrial Time]. This algorithm uses the IAU-76/FK5 theory and TEME definition in [1, p. 233]. Notice that one can provide corrections for the nutation in obliquity (δΔϵ_1980) [rad] and in longitude (δΔψ_1980) [rad] that are usually obtained from IERS EOP Data (see get_iers_eop).\n\nThe rotation type is described by the optional variable T. If it is DCM, then a DCM will be returned. Otherwise, if it is Quaternion, then a Quaternion will be returned. In case this parameter is omitted, then it falls back to DCM.\n\nReturns\n\nThe rotation that aligns the TEME frame with the GCRF frame. The rotation representation is selected by the optional parameter T.\n\nRemarks\n\nThe EOP data related to the nutation of the obliquity (δΔϵ_1980) and the nutation of the longitude (δΔψ_1980) can be omitted. In this case, the GCRF frame is what is usually called J2000 reference frame.\n\n\n\n\n\n","category":"function"},{"location":"lib/library/#SatelliteToolbox.r_teme_to_mod","page":"Library","title":"SatelliteToolbox.r_teme_to_mod","text":"r_teme_to_mod([T,] JD_TT::Number [, δΔϵ_1980::Number = 0, δΔψ_1980::Number = 0])\n\nCompute the rotation that aligns the True Equator Mean Equinox (TEME) frame with the Mean of Date (MOD) frame at the Julian Day JD_TT [Terrestrial Time]. This algorithm uses the IAU-76/FK5 theory and TEME definition in [1, p. 233]. Notice that one can provide corrections for the nutation in obliquity (δΔϵ_1980) [rad] and in longitude (δΔψ_1980) [rad] that are usually obtained from IERS EOP Data (see get_iers_eop).\n\nThe rotation type is described by the optional variable T. If it is DCM, then a DCM will be returned. Otherwise, if it is Quaternion, then a Quaternion will be returned. In case this parameter is omitted, then it falls back to DCM.\n\nReturns\n\nThe rotation that aligns the TEME frame with the MOD frame. The rotation representation is selected by the optional parameter T.\n\n\n\n\n\n","category":"function"},{"location":"lib/library/#SatelliteToolbox.r_teme_to_pef-Tuple{Number}","page":"Library","title":"SatelliteToolbox.r_teme_to_pef","text":"r_teme_to_pef([T,] JD_TT::Number)\n\nCompute the rotation that aligns the True Equator Mean Equinox (TEME) frame with the Pseudo-Earth Fixed (PEF) frame at the Julian Day JD_TT [Terrestrial Time]. This algorithm uses the IAU-76/FK5 theory and TEME definition in [1, p. 233].\n\nThe rotation type is described by the optional variable T. If it is DCM, then a DCM will be returned. Otherwise, if it is Quaternion, then a Quaternion will be returned. In case this parameter is omitted, then it falls back to DCM.\n\nReturns\n\nThe rotation that aligns the TEME frame with the PEF frame. The rotation representation is selected by the optional parameter T.\n\n\n\n\n\n","category":"method"},{"location":"lib/library/#SatelliteToolbox.r_teme_to_tod","page":"Library","title":"SatelliteToolbox.r_teme_to_tod","text":"r_teme_to_tod([T,] JD_TT::Number [, δΔϵ_1980::Number = 0, δΔψ_1980::Number = 0])\n\nCompute the rotation that aligns the True Equator Mean Equinox (TEME) frame with the True of Date (TOD) frame at the Julian Day JD_TT [Terrestrial Time]. This algorithm uses the IAU-76/FK5 theory and TEME definition in [1, p. 233]. Notice that one can provide corrections for the nutation in obliquity (δΔϵ_1980) [rad] and in longitude (δΔψ_1980) [rad] that are usually obtained from IERS EOP Data (see get_iers_eop).\n\nThe rotation type is described by the optional variable T. If it is DCM, then a DCM will be returned. Otherwise, if it is Quaternion, then a Quaternion will be returned. In case this parameter is omitted, then it falls back to DCM.\n\nReturns\n\nThe rotation that aligns the TEME frame with the TOD frame. The rotation representation is selected by the optional parameter T.\n\n\n\n\n\n","category":"function"},{"location":"lib/library/#SatelliteToolbox.r_tirs_to_cirs_iau2006-Tuple{Number}","page":"Library","title":"SatelliteToolbox.r_tirs_to_cirs_iau2006","text":"r_tirs_to_cirs_iau2006([T::Type,] JD_UT1::Number)\n\nCompute the rotation that aligns the Terrestrial Intermediate Reference System (TIRS) with the Celestial Intermediate Reference System (CIRS) at the Julian Day JD_UT1 [UT1]. This algorithm uses the IAU-2006 theory.\n\nThe rotation type is described by the optional variable T. If it is DCM, then a DCM will be returned. Otherwise, if it is Quaternion, then a Quaternion will be returned. In case this parameter is omitted, then it falls back to DCM.\n\nReturns\n\nThe rotation that aligns the TIRS frame with the CIRS frame. The rotation representation is selected by the optional parameter T.\n\nRemarks\n\nThe reference frames TIRS and CIRS are separated by a rotation about the Z-axis of the Earth Rotation Angle, which is the angle between the Conventional International Origin (CIO) and the Terrestrial Intermediate Origin (TIO) [1]. The latter is a reference meridian on Earth that is located about 100m away from Greenwich meridian along the equator of the Celestial Intermediate Pole (CIP) [1].\n\n\n\n\n\n","category":"method"},{"location":"lib/library/#SatelliteToolbox.r_tirs_to_ers_iau2006","page":"Library","title":"SatelliteToolbox.r_tirs_to_ers_iau2006","text":"r_tirs_to_ers_iau2006([T::Type,] JD_UT1::Number, JD_TT::Number, δΔΨ_2000::Number = 0)\n\nCompute the rotation that aligns the Terrestrial Intermediate Reference System (TIRS) with the Earth Reference System (ERS) at the Julian Day JD_UT1 [UT1] and JD_TT [Terrestrial Time]. This algorithm uses the IAU-2006 theory.\n\nNotice that one can provide corrections for the nutation in longitude (δΔψ_2000) [rad] that are usually obtained from IERS EOP Data (see get_iers_eop and deps_dpsi). This corrections are related to Free Core Nutation (FCN) that models the effect of a liquid Earth core.\n\nThe rotation type is described by the optional variable T. If it is DCM, then a DCM will be returned. Otherwise, if it is Quaternion, then a Quaternion will be returned. In case this parameter is omitted, then it falls back to DCM.\n\nReturns\n\nThe rotation that aligns the TIRS frame with the ERS frame. The rotation representation is selected by the optional parameter T.\n\nRemarks\n\nThe reference frames TIRS and ERS are separated by a rotation about the Z-axis of the Greenwhich apparent sidereal angle (GAST). This angle is computed using the IAU-2006 theory, which consist of obtaining the Earth Rotation Angle (ERA) and subtracting the result of the Equation of Origins (EO).\n\n\n\n\n\n","category":"function"},{"location":"lib/library/#SatelliteToolbox.r_tirs_to_itrf_iau2006-Tuple{Number, Number, Number}","page":"Library","title":"SatelliteToolbox.r_tirs_to_itrf_iau2006","text":"r_tirs_to_itrf_iau2006([T::Type,] JD_TT::Number, x_p::Number, y_p::Number)\n\nCompute the rotation that aligns the Terrestrial Intermediate Reference System (TIRS) with the International Terrestrial Reference Frame (ITRF) considering the polar motion represented by the angles x_p [rad] and y_p [rad] that are obtained from IERS EOP Data (see get_iers_eop).\n\nx_p is the polar motion displacement about X-axis, which is the IERS Reference Meridian direction (positive south along the 0˚ longitude meridian). y_p is the polar motion displacement about Y-axis (90˚W or 270˚E meridian).\n\nThe rotation type is described by the optional variable T. If it is DCM, then a DCM will be returned. Otherwise, if it is Quaternion, then a Quaternion will be returned. In case this parameter is omitted, then it falls back to DCM.\n\nReturns\n\nThe rotation that aligns the TIRS frame with the ITRF frame. The rotation representation is selected by the optional parameter T.\n\nRemarks\n\nThe ITRF is defined based on the International Reference Pole (IRP), which is the location of the terrestrial pole agreed by international committees [1]. The Terrestrial Intermediate Reference Frame (TIRS), on the other hand, is defined based on the Earth axis of rotation, or the Celestial Intermediate Pole (CIP). Hence, TIRS XY-plane contains the True Equator. Furthermore, since the recovered latitude and longitude are sensitive to the CIP, then it should be computed considering the TIRS frame.\n\nThe TIRS and PEF (IAU-76/FK5) are virtually the same reference frame, but according to [1] it is convenient to separate the names as the exact formulae differ.\n\n\n\n\n\n","category":"method"},{"location":"lib/library/#SatelliteToolbox.r_tirs_to_mod_iau2006","page":"Library","title":"SatelliteToolbox.r_tirs_to_mod_iau2006","text":"r_tirs_to_mod_iau2006([T::Type,] JD_UT1::Number, JD_TT::Number, δΔϵ_2000::Number = 0, δΔΨ_2000::Number = 0)\n\nCompute the rotation that aligns the Terrestrial Intermediate Reference System (TIRS) with the Mean of Date (MOD) reference frame at the Julian Day JD_UT1 [UT1] and JD_TT [Terrestrial Time]. This algorithm uses the IAU-2006 theory.\n\nNotice that one can provide corrections for the nutation in obliquity (δΔϵ_2000) and in longitude (δΔψ_2000) [rad] that are usually obtained from IERS EOP Data (see get_iers_eop and deps_dpsi). This corrections are related to Free Core Nutation (FCN) that models the effect of a liquid Earth core.\n\nThe rotation type is described by the optional variable T. If it is DCM, then a DCM will be returned. Otherwise, if it is Quaternion, then a Quaternion will be returned. In case this parameter is omitted, then it falls back to DCM.\n\nReturns\n\nThe rotation that aligns the TIRS frame with the ERS frame. The rotation representation is selected by the optional parameter T.\n\nRemarks\n\nThis composed rotation TIRS <=> ERS <=> MOD is implemented as a new function because the single rotations TIRS <=> ERS and ERS <=> MOD call the function nutation_eo, which has a high computational burden. In this case, the composed algorithm is about 2x faster than calling those function separately.\n\n\n\n\n\n","category":"function"},{"location":"lib/library/#SatelliteToolbox.r_tod_to_mod_fk5","page":"Library","title":"SatelliteToolbox.r_tod_to_mod_fk5","text":"r_tod_to_mod_fk5([T,] JD_TT::Number [, δΔϵ_1980::Number, δΔψ_1980::Number])\n\nCompute the rotation that aligns the True of Date (TOD) frame with the Mean of Date (MOD) frame at the Julian Day JD_TT [Terrestrial Time]. This algorithm uses the IAU-76/FK5 theory. Notice that one can provide corrections for the nutation in obliquity (δΔϵ_1980) [rad] and in longitude (δΔψ_1980) [rad] that are usually obtained from IERS EOP Data (see get_iers_eop).\n\nThe rotation type is described by the optional variable T. If it is DCM, then a DCM will be returned. Otherwise, if it is Quaternion, then a Quaternion will be returned. In case this parameter is omitted, then it falls back to DCM.\n\nReturns\n\nThe rotation that aligns the TOD frame with the MOD frame. The rotation representation is selected by the optional parameter T.\n\nRemarks\n\nThe True of Date (TOD) frame is rotated into the Mean of Date (MOD) frame considering the 1980 IAU Theory of Nutation. The IERS EOP corrections must be added if one wants to make the rotation consistent with the Geocentric Celestial Reference Systems (GCRS).\n\n\n\n\n\n","category":"function"},{"location":"lib/library/#SatelliteToolbox.r_tod_to_pef_fk5","page":"Library","title":"SatelliteToolbox.r_tod_to_pef_fk5","text":"r_tod_to_pef_fk5([T,] JD_UT1::Number, JD_TT::Number [, δΔψ_1980::Number])\n\nCompute the rotation that aligns the True of Date (TOD) frame with the Pseudo-Earth Fixed (PEF) frame at the Julian Day JD_UT1 [UT1] and JD_TT [Terrestrial Time]. This algorithm uses the IAU-76/FK5 theory. Notice that one can provide correction for the nutation in longitude (δΔψ_1980) [rad] that is usually obtained from IERS EOP Data (see get_iers_eop).\n\nThe Julian Day in UT1 is used to compute the Greenwich Mean Sidereal Time (GMST) (see jd_to_gmst), whereas the Julian Day in Terrestrial Time is used to compute the nutation in the longitude. Notice that the Julian Day in UT1 and in Terrestrial Time must be equivalent, i.e. must be related to the same instant. This function does not check this.\n\nThe rotation type is described by the optional variable T. If it is DCM, then a DCM will be returned. Otherwise, if it is Quaternion, then a Quaternion will be returned. In case this parameter is omitted, then it falls back to DCM.\n\nReturns\n\nThe rotation that aligns the TOD frame with the PEF frame. The rotation representation is selected by the optional parameter T.\n\nRemarks\n\nThe True of Date (TOD) frame is rotated into the Pseudo-Earth Fixed (PEF) frame considering the 1980 IAU Theory of Nutation. The IERS EOP corrections must be added if one wants to make the rotation consistent with the Geocentric Celestial Reference Systems (GCRS).\n\n\n\n\n\n","category":"function"},{"location":"lib/library/#SatelliteToolbox.r_tod_to_teme","page":"Library","title":"SatelliteToolbox.r_tod_to_teme","text":"r_tod_to_teme([T,] JD_TT::Number [, δΔϵ_1980::Number = 0, δΔψ_1980::Number = 0])\n\nCompute the rotation that aligns the True of Date (TOD) frame with the True Equator Mean Equinox (TEME) frame at the Julian Day JD_TT [Terrestrial Time]. This algorithm uses the IAU-76/FK5 theory and TEME definition in [1, p. 233]. Notice that one can provide corrections for the nutation in obliquity (δΔϵ_1980) [rad] and in longitude (δΔψ_1980) [rad] that are usually obtained from IERS EOP Data (see get_iers_eop).\n\nThe rotation type is described by the optional variable T. If it is DCM, then a DCM will be returned. Otherwise, if it is Quaternion, then a Quaternion will be returned. In case this parameter is omitted, then it falls back to DCM.\n\nReturns\n\nThe rotation that aligns the TOD frame with the TEME frame. The rotation representation is selected by the optional parameter T.\n\n\n\n\n\n","category":"function"},{"location":"lib/library/#SatelliteToolbox.read_iers_eop","page":"Library","title":"SatelliteToolbox.read_iers_eop","text":"read_iers_eop(filename::String, data_type::Symbol = :IAU1980)\n\nRead IERS EOP Data from the file filename. The user must specify if the data is related to the model IAU 1980 (data_type = :IAU1980), which is the default, or to the model IAU 2000A (data_type = :IAU2000A).\n\nReturns\n\nA structure (EOPData_IAU1980 or EOPData_IAU2000A, depending on data_type) with the interpolations of the EOP parameters. Notice that the interpolation indexing is set to the Julian Day.\n\nRemarks\n\nThe input file must be exactly the same as provided by IERS. One can download it using the following commands:\n\nIAU 1980\n  curl -O https://datacenter.iers.org/data/latestVersion/223_EOP_C04_14.62-NOW.IAU1980223.txt\n  wget https://datacenter.iers.org/data/latestVersion/223_EOP_C04_14.62-NOW.IAU1980223.txt\nIAU 2000A\n  curl -O https://datacenter.iers.org/data/latestVersion/224_EOP_C04_14.62-NOW.IAU2000A224.txt\n  wget https://datacenter.iers.org/data/latestVersion/224_EOP_C04_14.62-NOW.IAU2000A224.txt\n\n\n\n\n\n","category":"function"},{"location":"lib/library/#SatelliteToolbox.rv_to_kepler","page":"Library","title":"SatelliteToolbox.rv_to_kepler","text":"rv_to_kepler(r_i::AbstractVector, v_i::AbstractVector, t::Number = 0)\nrv_to_kepler(x::Number, y::Number, z::Number, vx::Number, vy::Number, vz::Number, t::Number = 0)\n\nConvert a Cartesian representation (position vector r_i [m] and velocity vector v_i [m/s²]) to the Keplerian elements. Optionally, the user can specify the epoch of the returned elements using the parameter t. It it is omitted, then it default to 0.\n\nThe input vectors can also be passed component by component:\n\nr_i = [x,   y,  z]\nv_i = [vx, vy, vz]\n\nReturns\n\nAn instance of the structure KeplerianElements [SI units].\n\nRemarks\n\nThe special cases are treated as follows:\n\nCircular and equatorial: the right ascension of the ascending node and the argument of perigee are set to 0. Hence, the true anomaly is equal to the true longitude.\nElliptical and equatorial: the right ascension of the ascending node is set to 0. Hence, the argument of perigee is equal to the longitude of periapsis.\nCircular and inclined: the argument of perigee is set to 0. Hence, the true anomaly is equal to the argument of latitude.\n\nReferences\n\nThe algorithm was adapted from [1].\n\n\n\n\n\n","category":"function"},{"location":"lib/library/#SatelliteToolbox.rv_to_mean_elements_j2osc-Union{Tuple{Tv}, Tuple{T}, Tuple{AbstractVector{T}, AbstractVector{Tv}, AbstractVector{Tv}}, Tuple{AbstractVector{T}, AbstractVector{Tv}, AbstractVector{Tv}, Any}} where {T, Tv<:(AbstractVector{T} where T)}","page":"Library","title":"SatelliteToolbox.rv_to_mean_elements_j2osc","text":"rv_to_mean_elements_j2osc(vJD::AbstractVector{T}, vr::AbstractVector{Tv}, vv::AbstractVector{Tv}, W = I; mean_elements_epoch::Symbol = :end, max_it::Int = 50, j2_gc = sgp4_gc_wgs84, atol::Number = 2e-4, rtol::Number = 2e-4) where {T,Tv<:AbstractVector}\n\nCompute the mean elements for SGP4 based on the position vr and velocity vectors vr represented in TEME reference frame. The epoch of those measurements [Julian Day] must be in vJD.\n\nThe matrix W defined the weights for the least-square algorithm.\n\nKeywords\n\nestimate_bstar: If true, then the BSTAR parameters of the TLE will be                   estimated.\nmean_elements_epoch: If it is  :end, the epoch of the mean elements will                        be equal to the last value in vJD. Otherwise, if it                        is :begin, the epoch will be selected as the first                        value in vJD.\nmax_it: The maximum allowed number of iterations.\nsgp4_gc: SPG4 constants (see SGP4_GravCte).\natol: The tolerance for the absolute value of the residue. If, at any         iteration, the residue is lower than atol, then the iterations stop.\nrtol: The tolerance for the relative difference between the residues. If, at         any iteration, the relative difference between the residues in two         consecutive iterations is lower than rtol, then the iterations stop.\n\nReturns\n\nThe epoch of the elements [Julian Day].\nThe mean elements for SGP4 algorithm:\nSemi-major axis [m];\nEccentricity [ ];\nInclination [rad];\nRight ascension of the ascending node [rad];\nArgument of perigee [rad];\nTrue anomaly [rad];\nBSTAR (0 if estimate_bstar is false).\nThe covariance matrix of the mean elements estimation.\n\n\n\n\n\n","category":"method"},{"location":"lib/library/#SatelliteToolbox.rv_to_mean_elements_sgp4-Union{Tuple{Tv}, Tuple{T}, Tuple{AbstractVector{T}, AbstractVector{Tv}, AbstractVector{Tv}}, Tuple{AbstractVector{T}, AbstractVector{Tv}, AbstractVector{Tv}, Any}} where {T, Tv<:(AbstractVector{T} where T)}","page":"Library","title":"SatelliteToolbox.rv_to_mean_elements_sgp4","text":"rv_to_mean_elements_sgp4(vJD::AbstractVector{T}, vr::AbstractVector{Tv}, vv::AbstractVector{Tv}, W = I; estimate_bstar::Bool = true, mean_elements_epoch::Symbol = :end, max_it::Int = 50, sgp4_gc = sgp4_gc_wgs84, atol::Number = 2e-4, rtol::Number = 2e-4) where {T,Tv<:AbstractVector}\n\nCompute the mean elements for SGP4 based on the position vr and velocity vectors vr represented in TEME reference frame. The epoch of those measurements [Julian Day] must be in vJD.\n\nThe matrix W defined the weights for the least-square algorithm.\n\nKeywords\n\nestimate_bstar: If true, then the BSTAR parameters of the TLE will be                   estimated.\nmean_elements_epoch: If it is  :end, the epoch of the mean elements will                        be equal to the last value in vJD. Otherwise, if it                        is :begin, the epoch will be selected as the first                        value in vJD.\nmax_it: The maximum allowed number of iterations.\nsgp4_gc: SPG4 constants (see SGP4_GravCte).\natol: The tolerance for the absolute value of the residue. If, at any         iteration, the residue is lower than atol, then the iterations stop.\nrtol: The tolerance for the relative difference between the residues. If, at         any iteration, the relative difference between the residues in two         consecutive iterations is lower than rtol, then the iterations stop.\n\nReturns\n\nThe epoch of the elements [Julian Day].\nThe mean elements for SGP4 algorithm:\nSemi-major axis [m];\nEccentricity [ ];\nInclination [rad];\nRight ascension of the ascending node [rad];\nArgument of perigee [rad];\nTrue anomaly [rad];\nBSTAR (0 if estimate_bstar is false).\nThe covariance matrix of the mean elements estimation.\n\n\n\n\n\n","category":"method"},{"location":"lib/library/#SatelliteToolbox.rv_to_tle-Tuple","page":"Library","title":"SatelliteToolbox.rv_to_tle","text":"rv_to_tle(args...; name::String = \"UNDEFINED\", sat_num::Int = 9999, classification::Char = 'U', int_designator = \"999999\", elem_set_number::Int = 0, rev_num, kwargs...)\n\nConvert a set of position and velocity vectors represented in TEME reference frame to a TLE. The arguments args and keywords kwargs are the same as those described in the function rv_to_mean_elements_sgp4.\n\nAdditionally, the user can specify some parameters of the generated TLE.\n\nThis function returns the TLE and the covariance of the estimated elements (state vector).\n\n\n\n\n\n","category":"method"},{"location":"lib/library/#SatelliteToolbox.satellite_check_Brazil-Tuple{Number, Number}","page":"Library","title":"SatelliteToolbox.satellite_check_Brazil","text":"satellite_check_Brazil(lat::Number, lon::Number)\n\nVerify if a point described by latitude lat [rad] and longitude lon [rad] is inside Brazil. Returns true if the point is inside Brazil, of false otherwise.\n\nRemarks\n\nThis function was based on the algorithm sent by Renato Branco to Ronan Arraes by e-mail at 2016-02-16.\n\n\n\n\n\n","category":"method"},{"location":"lib/library/#SatelliteToolbox.satellite_lighting_condition-Tuple{AbstractVector{T} where T, AbstractVector{T} where T}","page":"Library","title":"SatelliteToolbox.satellite_lighting_condition","text":"satellite_lighting_condition(r_i::AbstractVector, s_i::AbstractVector)\n\nCompute the satellite lighting condition given the Sun unitary vector s_i [m] and the satellite position vector r_i [m].\n\nReturns\n\nSAT_LIGHTING_SUNLIGHT: Satellite is under sunlight.\nSAT_LIGHTING_PENUMBRA: Satellite is at penumbra region.\nSAT_LIGHTING_UMBRA: Satellite is at umbra region.\n\n\n\n\n\n","category":"method"},{"location":"lib/library/#SatelliteToolbox.satellite_position_i-NTuple{6, Number}","page":"Library","title":"SatelliteToolbox.satellite_position_i","text":"satellite_position_i(a::Number, e::Number, i::Number, RAAN::Number, w::Number, f::Number)\n\nCompute the satellite position in the Earth-Centered Inertial (ECI) reference frame given the orbital elements a, e, i, RAAN, w, and f.\n\nNotice that the ECI frame used will be the same as the frame of the orbital elements.\n\nArgs\n\na: Semi-major axis.\ne: Eccentricity.\ni: Inclination [rad].\nRAAN: Right ascension of the ascending node [rad].\nw: Argument of perigee [rad].\nf: True anomaly [rad].\n\nReturns\n\nThe satellite position vector represented in the ECI reference frame.\nThe unit vector perpendicular to the satellite position vector that lies on the orbit plane represented in the ECI reference frame.\n\nRemarks\n\nThe satellite position vector will have the same unit of the semi-major axis.\n\n\n\n\n\n","category":"method"},{"location":"lib/library/#SatelliteToolbox.satellite_sun_angle_earth_pointing","page":"Library","title":"SatelliteToolbox.satellite_sun_angle_earth_pointing","text":"satellite_sun_angle_earth_pointing(JD0::Number, a::Number, e::Number, i::Number, RAAN::Number, w::Number, numDays::Integer, fN_k::Function, meanAnomaly::Bool = false, step::Number = 0.1*pi/180.0)\n\nCompute the Sun angle on a satellite surface for an Earth-pointing mission.\n\nArgs\n\nJD0: Initial instant for the analysis [Julian day].\na: Semi-major axis of the orbit [m].\ne: Orbit eccentricity.\ni: Orbit inclination [rad].\nw: Argument of perigee [rad].\nRAAN: Right ascension of the ascending node at JD0 [rad].\nnumDays: Number of days for the analysis.\nfN_k: Function f(s_b) that describes the solar panel normal at each k-th         sampling step. Notice that s_b is the Sun vector represented in         the body coordinate frame.\nmeanAnomaly: (OPTIONAL) If true, compute using angular steps in the mean                anomaly instead of in the orbit latitude (Default: false).\nstep: (OPTIONAL) Mean anomaly step (Default: 0.1 deg).\n\nReturns\n\nA matrix containing the sun angle [rad] for each position in orbit for each day.\n\nNOTE: if the Sun angle is larger than 90 deg or if the satellite is in eclipse, then NaN is returned in the matrix.\n\nRemarks\n\nThe body reference frame is defined as:\n\nZ axis points towards the center of Earth;\nY axis points towards the negative direction of orbit normal;\nX axis completes the right-hand reference frame.\n\nIf the mean anomaly is used, then the average value of the output is the average sun radiation received by the satellite surface, because every angular steps have a fixed time interval.\n\nIf the mean anomaly is used, then the angle interval is [0, 2π]. Otherwise, the angle interval is [-π,π].\n\n\n\n\n\n","category":"function"},{"location":"lib/library/#SatelliteToolbox.satellite_sun_angle_earth_pointing-2","page":"Library","title":"SatelliteToolbox.satellite_sun_angle_earth_pointing","text":"satellite_sun_angle_earth_pointing(JD0::Number, a::Number, e::Number, i::Number, RAAN::Number, w::Number, numDays::Integer, N::AbstractVector, step::Number = 0.1*pi/180.0)\n\nCompute the Sun angle on a satellite surface for an Earth-pointing mission.\n\nArgs\n\nJD0: Initial instant for the analysis [Julian day].\na: Semi-major axis of the orbit [m].\ne: Orbit eccentricity.\ni: Orbit inclination [rad].\nw: Argument of perigee [rad].\nRAAN: Right ascension of the ascending node at JD0 [rad].\nnumDays: Number of days for the analysis.\nN: Vector normal to the surface represented in the body reference frame.\nmeanAnomaly: (OPTIONAL) If true, compute using angular steps in the mean                anomaly instead of in the orbit latitude (Default: false).\nstep: (OPTIONAL) Mean anomaly step (Default: 0.1 deg).\n\nReturns\n\nA matrix containing the Sun angle for each position in orbit for each day.\n\nNOTE: if the Sun angle is larger than 90 deg or if the satellite is in eclipse, then NaN is returned in the matrix.\n\nRemarks\n\nThe body reference frame is defined as:\n\nZ axis points towards the center of Earth;\nY axis points towards the negative direction of orbit normal;\nX axis completes the right-hand reference frame.\n\nIf the mean anomaly is used, then the average value of the output is the average sun radiation received by the satellite surface, because every angular steps have a fixed time interval.\n\nIf the mean anomaly is used, then the angle interval is [0, 2π]. Otherwise, the angle interval is [-π,π].\n\n\n\n\n\n","category":"function"},{"location":"lib/library/#SatelliteToolbox.satellite_sun_radiation_earth_pointing","page":"Library","title":"SatelliteToolbox.satellite_sun_radiation_earth_pointing","text":"satellite_sun_radiation_earth_pointing(JD0::Number, a::Number, e::Number, i::Number, RAAN::Number, w::Number, numDays::Integer, N::Vector, meanAnomaly::Bool = false, step::Number = 0.1*pi/180.0)\n\nCompute the Sun radiation on a satellite surface for an Earth-pointing mission.\n\nArgs\n\nJD0: Initial instant for the analysis [Julian day].\na: Semi-major axis of the orbit [m].\ne: Orbit eccentricity.\ni: Orbit inclination [rad].\nw: Argument of perigee [rad].\nRAAN: Right ascension of the ascending node at JD0 [rad].\nnumDays: Number of days for the analysis.\nN: Vector normal to the surface represented in the body reference frame.\nmeanAnomaly: (OPTIONAL) If true, compute using angular steps in the mean                anomaly instead of in the orbit latitude (Default: false).\nstep: (OPTIONAL) Mean anomaly step (Default: 0.1 deg).\n\nReturns\n\nA matrix containing the Sun radiation [W/m²] for each position in orbit for each day.\n\nNOTE: if the Sun angle is larger than 90 deg or if the satellite is in eclipse, then NaN is returned in the matrix.\n\nRemarks\n\nThe body reference frame is defined as:\n\nZ axis points towards the center of Earth;\nY axis points towards the negative direction of orbit normal;\nX axis completes the right-hand reference frame.\n\nIf the mean anomaly is used, then the average value of the output is the average sun radiation received by the satellite surface, because every angular steps have a fixed time interval.\n\nIf the mean anomaly is used, then the angle interval is [0, 2π]. Otherwise, the angle interval is [-π,π].\n\n\n\n\n\n","category":"function"},{"location":"lib/library/#SatelliteToolbox.satellite_sun_radiation_earth_pointing-2","page":"Library","title":"SatelliteToolbox.satellite_sun_radiation_earth_pointing","text":"satellite_sun_radiation_earth_pointing(JD0::Number, a::Number, e::Number, i::Number, RAAN::Number, w::Number, numDays::Integer, fN_k::Function, meanAnomaly::Bool = false, step::Number = 0.1*pi/180.0)\n\nCompute the Sun radiation on a satellite surface for an Earth-pointing mission.\n\nArgs\n\nJD0: Initial instant for the analysis [Julian day].\na: Semi-major axis of the orbit [m].\ne: Orbit eccentricity.\ni: Orbit inclination [rad].\nw: Argument of perigee [rad].\nRAAN: Right ascension of the ascending node at JD0 [rad].\nnumDays: Number of days for the analysis.\nfN_k: Function f(s_b) that describes the solar panel normal at each k-th         sampling step. Notice that s_b is the Sun vector represented in         the body coordinate frame.\nmeanAnomaly: (OPTIONAL) If true, compute using angular steps in the mean                anomaly instead of in the orbit latitude (Default: false).\nstep: (OPTIONAL) Mean anomaly step (Default: 0.1 deg).\n\nReturns\n\nA matrix containing the Sun radiation [W/m²] for each position in orbit for each day.\n\nNOTE: if the Sun angle is larger than 90 deg or if the satellite is in eclipse, then NaN is returned in the matrix.\n\nRemarks\n\nThe body reference frame is defined as:\n\nZ axis points towards the center of Earth;\nY axis points towards the negative direction of orbit normal;\nX axis completes the right-hand reference frame.\n\nIf the mean anomaly is used, then the average value of the output is the average sun radiation received by the satellite surface, because every angular steps have a fixed time interval.\n\nIf the mean anomaly is used, then the angle interval is [0, 2π]. Otherwise, the angle interval is [-π,π].\n\n\n\n\n\n","category":"function"},{"location":"lib/library/#SatelliteToolbox.satellite_sun_radiation_earth_pointing_mean","page":"Library","title":"SatelliteToolbox.satellite_sun_radiation_earth_pointing_mean","text":"satellite_sun_radiation_earth_pointing_mean(JD0::Number, a::Number, e::Number, i::Number, RAAN::Number, w::Number, numDays::Integer, N::AbstractVector, step::Number = 0.1*pi/180.0)\n\nCompute the mean Sun radiation on a satellite surface for an Earth-pointing mission.\n\nArgs\n\nJD0: Initial instant for the analysis [Julian day].\na: Semi-major axis of the orbit [m].\ne: Orbit eccentricity.\ni: Orbit inclination [rad].\nw: Argument of perigee [rad].\nRAAN: Right ascension of the ascending node at JD0 [rad].\nnumDays: Number of days for the analysis.\nN: Vector normal to the surface represented in the body reference frame.\nmeanAnomaly: (OPTIONAL) If true, compute using angular steps in the mean                anomaly instead of in the orbit latitude (Default: false).\nstep: (OPTIONAL) Mean anomaly step (Default: 0.1 deg).\n\nReturns\n\nThe mean Sun radiation on a surface [W/m²].\n\nRemarks\n\nFor more details, see satellitesunradiationearthpointing.\n\n\n\n\n\n","category":"function"},{"location":"lib/library/#SatelliteToolbox.satellite_sun_radiation_earth_pointing_mean-2","page":"Library","title":"SatelliteToolbox.satellite_sun_radiation_earth_pointing_mean","text":"satellite_sun_radiation_earth_pointing_mean(JD0::Number, a::Number, e::Number, i::Number, RAAN::Number, w::Number, numDays::Integer, fN_k::Function, step::Number = 0.1*pi/180.0)\n\nCompute the mean Sun radiation on a satellite surface for an Earth-pointing mission.\n\nArgs\n\nJD0: Initial instant for the analysis [Julian day].\na: Semi-major axis of the orbit [m].\ne: Orbit eccentricity.\ni: Orbit inclination [rad].\nw: Argument of perigee [rad].\nRAAN: Right ascension of the ascending node at JD0 [rad].\nnumDays: Number of days for the analysis.\nfN_k: Function f(s_b) that describes the solar panel normal at each k-th         sampling step. Notice that s_b is the Sun vector represented in         the body coordinate frame.\nmeanAnomaly: (OPTIONAL) If true, compute using angular steps in the mean                anomaly instead of in the orbit latitude (Default: false).\nstep: (OPTIONAL) Mean anomaly step (Default: 0.1 deg).\n\nReturns\n\nThe mean Sun radiation on a surface [W/m²].\n\nRemarks\n\nFor more details, see satellitesunradiationearthpointing.\n\n\n\n\n\n","category":"function"},{"location":"lib/library/#SatelliteToolbox.sim_RAAN_J2-Tuple{Number, Number, Number, Number, Integer}","page":"Library","title":"SatelliteToolbox.sim_RAAN_J2","text":"sim_RAAN_J2(a::Number, e::Number, i::Number, RAAN_0::Number, numDays::Integer)\n\nSimulate the RAAN of an orbit with semi-major axis a [m], eccentricity e, inclination i [rad], and initial RAAN RAAN_0 [rad] considering J2 perturbations. The analysis is performed for numDays days.\n\nReturns\n\nA numDays × 2 matrix in which the i-th line is:\n\n| day | RAAN (0,2π) [rad] |\n\n\n\n\n\n","category":"method"},{"location":"lib/library/#SatelliteToolbox.sort_list_ss_orbits_by_height-Tuple{Matrix{T} where T}","page":"Library","title":"SatelliteToolbox.sort_list_ss_orbits_by_height","text":"sort_list_ss_orbits_by_height(ss_orbits::Matrix)\n\nSort the list of Sun-synchronous orbits ss_orbits (see list_ss_orbits_by_rep_period) by height and return a new matrix.\n\n\n\n\n\n","category":"method"},{"location":"lib/library/#SatelliteToolbox.step!","page":"Library","title":"SatelliteToolbox.step!","text":"step!(orbp::OrbitPropagator{T}, Δt::Number)\n\nPropagate the orbit in orbp by Δt [s] using the algorithm of orbp. The new parameters will be written in orbp.\n\nReturns\n\nThe position vector represented in the inertial frame after the step [m].\nThe velocity vector represented in the inertial frame after the step [m].\n\n\n\n\n\n","category":"function"},{"location":"lib/library/#SatelliteToolbox.sun_position_i-Tuple{Number}","page":"Library","title":"SatelliteToolbox.sun_position_i","text":"sun_position_i(JD::Number)\n\nCompute the Sun position represented in the Mean Equinox of Date (MOD) at the Julian Day JD. The algorithm was adapted from [3, p. 277-279].\n\n\n\n\n\n","category":"method"},{"location":"lib/library/#SatelliteToolbox.sun_velocity_i-Tuple{Number}","page":"Library","title":"SatelliteToolbox.sun_velocity_i","text":"sun_velocity_i(JD::Number)\n\nCompute the Sun velocity represented in the Mean Equinox of Date (MOD) at the Julian Day JD. The algorithm was obtained by computing the time derivative of the Sun position in [3, p. 277-279].\n\n\n\n\n\n","category":"method"},{"location":"lib/library/#SatelliteToolbox.sv_ecef_to_ecef-Tuple{OrbitStateVector, Vararg{Any, N} where N}","page":"Library","title":"SatelliteToolbox.sv_ecef_to_ecef","text":"sv_ecef_to_ecef(sv::OrbitStateVector, args...)\n\nConvert the orbit state vector sv from an ECEF frame to another ECEF frame. The arguments args... must match those of the function r_ecef_to_ecef wihtout the rotation representation.\n\n\n\n\n\n","category":"method"},{"location":"lib/library/#SatelliteToolbox.sv_ecef_to_eci-Tuple{OrbitStateVector, Val{:ITRF}, Union{Val{:GCRF}, Val{:J2000}, Val{:TOD}, Val{:MOD}, Val{:TEME}}, Number, EOPData_IAU1980}","page":"Library","title":"SatelliteToolbox.sv_ecef_to_eci","text":"sv_ecef_to_eci(sv::OrbitStateVector, ECEF, ECI, JD_UTC [, eop_data])\n\nConvert the orbit state vector sv from the Earth-Centered, Earth-Fixed (ECEF) reference frame ECEF to the Earth-Centered Inertial (ECI) reference frame at the Julian day JD_UTC [UTC]. The eop_data may be required depending on the selection of the input and output reference system. For more information, see the documentation of the function r_ecef_to_eci.\n\ninfo: Info\nIt is assumed that the input velocity and acceleration in sv are obtained by an observer on the ECEF frame. Thus, the output will contain the velocity and acceleration as measured by an observer on the ECI frame.\n\n\n\n\n\n","category":"method"},{"location":"lib/library/#SatelliteToolbox.sv_eci_to_ecef-Tuple{OrbitStateVector, Union{Val{:GCRF}, Val{:J2000}, Val{:TOD}, Val{:MOD}, Val{:TEME}}, Val{:ITRF}, Number, EOPData_IAU1980}","page":"Library","title":"SatelliteToolbox.sv_eci_to_ecef","text":"sv_eci_to_ecef(sv::OrbitStateVector, ECI, ECEF, JD_UTC [, eop_data])\n\nConvert the orbit state vector sv from the Earth-Centered Inertial (ECI) reference frame ECI to the Earth-Centered, Earth-Fixed (ECEF) reference frame at the Julian day JD_UTC [UTC]. The eop_data may be required depending on the selection of the input and output reference system. For more information, see the documentation of the function r_eci_to_ecef.\n\ninfo: Info\nIt is assumed that the input velocity and acceleration in sv are obtained by an observer on the ECI frame. Thus, the output will contain the velocity and acceleration as measured by an observer on the ECEF frame.\n\n\n\n\n\n","category":"method"},{"location":"lib/library/#SatelliteToolbox.sv_eci_to_eci-Tuple{OrbitStateVector, Vararg{Any, N} where N}","page":"Library","title":"SatelliteToolbox.sv_eci_to_eci","text":"sv_eci_to_eci(sv::OrbitStateVector, args...)\n\nConvert the orbit state vector sv from an ECI frame to another ECI frame. The arguments args... must match those of the function r_eci_to_eci wihtout the rotation representation.\n\n\n\n\n\n","category":"method"},{"location":"lib/library/#SatelliteToolbox.sv_to_kepler-Tuple{OrbitStateVector}","page":"Library","title":"SatelliteToolbox.sv_to_kepler","text":"sv_to_kepler(sv::OrbitStateVector)\n\nConvert the state vector sv to Keplerian elements represented by an instance of the structure KeplerianElements.\n\n\n\n\n\n","category":"method"},{"location":"lib/library/#SatelliteToolbox.swath_width-Tuple{Real, Real}","page":"Library","title":"SatelliteToolbox.swath_width","text":"swath_width(h::real, HalfFOV::real)\n\nCompute the swath width given the orbit altitude and the half FOV.\n\nArgs\n\nh: Orbit altitude [m].\nHalfFOV: Half field of view [rad].\n\nReturns\n\nThe swath width [m].\n\n\n\n\n\n","category":"method"},{"location":"lib/library/#SatelliteToolbox.twobody!-Tuple{TwoBody_Structure, Number}","page":"Library","title":"SatelliteToolbox.twobody!","text":"twobody!(tbd::TwoBody_Structure, t::Number)\n\nPropagate the orbit defined in tbd (see TwoBody_Structure) until the time t [s]. Notice that the values in tbd will be modified.\n\nReturns\n\nThe position vector represented in the inertial frame at time t [m].\nThe velocity vector represented in the inertial frame at time t [m/s]\n\nRemarks\n\nThe inertial frame in which the output is represented depends on which frame it was used to generate the orbit parameters.\n\n\n\n\n\n","category":"method"},{"location":"lib/library/#SatelliteToolbox.twobody_init-Union{Tuple{T}, NTuple{7, Number}} where T","page":"Library","title":"SatelliteToolbox.twobody_init","text":"twobody_init(epoch::Number, a_0::Number, e_0::Number, i_0::Number, Ω_0::Number, ω_0::Number, f_0::Number; μ::T = m0) where T\n\nInitialize the data structure of two body orbit propagator algorithm.\n\nArgs\n\nepoch: Epoch of the initial mean orbital elements [s].\na_0: Initial mean semi-major axis [m].\ne_0: Initial mean eccentricity.\ni_0: Initial mean inclination [rad].\nΩ_0: Initial mean right ascension of the ascending node [rad].\nω_0: Initial mean argument of perigee [rad].\nf_0: Initial mean true anomaly.\n\nKeywords\n\nμ: Standard gravitational parameter of the central body [m^3/s^2].      (Default = m0)\n\nReturns\n\nThe structure TwoBody_Structure with the initialized parameters.\n\n\n\n\n\n","category":"method"},{"location":"lib/library/#SatelliteToolbox.@_keyword_found-Tuple{Any, Any, Any}","page":"Library","title":"SatelliteToolbox.@_keyword_found","text":"@_keyword_found(keyword, keywords_found, current_line)\n\nCheck if the keyword exists in the list keywords_found. If true, then throw an error indicating that the problem occurred on the current_line.\n\n\n\n\n\n","category":"macro"},{"location":"lib/library/#SatelliteToolbox.@_parse_float-Tuple{Any}","page":"Library","title":"SatelliteToolbox.@_parse_float","text":"@_parse_float(input)\n\nParse the input to float substituting all Ds and ds  to e, so that we can convert numbers in FORTRAN format.\n\n\n\n\n\n","category":"macro"},{"location":"lib/library/#SatelliteToolbox.@check_orbit-Tuple{Any, Any}","page":"Library","title":"SatelliteToolbox.@check_orbit","text":"@check_orbit(a, e)\n\nVerify if the orbit with semi-major axis a [m] and eccentricity e is valid. This macro throws an exception if the orbit is not valid.\n\nReturn true is the orbit is valid, and false otherwise.\n\n\n\n\n\n","category":"macro"},{"location":"lib/library/#SatelliteToolbox.SGP4.SGP4_GravCte","page":"Library","title":"SatelliteToolbox.SGP4.SGP4_GravCte","text":"SGP4_GravCte{T<:Real}\n\nGravitational constants for SGP4.\n\nFields\n\nR0: Earth equatorial radius [km].\nXKE: √GM [er/s]^(3/2).\nJ2: The second gravitational zonal harmonic of the Earth.\nJ3: The thrid gravitational zonal harmonic of the Earth.\nJ4: The fourth gravitational zonal harmonic of the Earth.\n\n\n\n\n\n","category":"type"},{"location":"lib/library/#SatelliteToolbox.SGP4.SGP4_Structure","page":"Library","title":"SatelliteToolbox.SGP4.SGP4_Structure","text":"SGP4_Structure{T<:Real}\n\nLow level SGP4 structure.\n\n\n\n\n\n","category":"type"},{"location":"lib/library/#SatelliteToolbox.SGP4.dsinit-Union{Tuple{T}, NTuple{11, T}} where T<:Number","page":"Library","title":"SatelliteToolbox.SGP4.dsinit","text":"dsinit(epoch::T, nll_0::T, all_0::T, e_0::T, i_0::T, Ω_0::T, ω_0::T, M_0::T, dotM::T, dotω::T, dotΩ::T) where T<:Number\n\nInitialize the deep space structure. This function performs the initial computations and save the values at an instance of the structure SGP4_DeepSpace. Those will be used when calling the functions dsper! and dpsec!.\n\nArgs\n\nepoch: Epoch of the initial orbit [Julian Day].\nnll_0: Initial mean motion [rad/min].\nall_0: Initial semi-major axis [ER].\ne_0: Initial eccentricity.\ni_0: Initial inclination [rad].\nΩ_0: Initial right ascencion of the ascending node [rad].\nω_0: Initial argument of perigee [rad].\nM_0: Initial mean motion [rad].\ndotM: Time-derivative of the mean motion [rad/min].\ndotω: Time-derivative of the argument of perigee [rad/min].\ndotΩ: Time-derivative of the RAAN [rad/min].\n\nReturns\n\nAn instance of the structure SGP4_DeepSpace with the initalized values.\n\n\n\n\n\n","category":"method"},{"location":"lib/library/#SatelliteToolbox.SGP4.dsper!-Union{Tuple{T}, Tuple{SatelliteToolbox.SGP4.SGP4_DeepSpace{T}, T, T, T, T, T, Number}} where T<:Number","page":"Library","title":"SatelliteToolbox.SGP4.dsper!","text":"dsper!(sgp4_ds::SGP4_DeepSpace{T}, e_k::T, i_k::T, Ω_k::T, ω_k::T, M_k::T, Δt:Number) where T<:Number\n\nCompute the effects caused by Lunar-Solar periodics.\n\nNotice that the values in the structure sgp4_ds will be modified.\n\nArgs\n\nsgp4_ds: Deep space structure (see SGP4_DeepSpace).\ne_k: Current eccentricity.\ni_k: Current inclination [rad].\nΩ_k: Current right ascension of the ascending node [rad].\nω_k: Current argument of perigee [rad].\nM_k: Current mean anomaly [rad].\nΔt: Time interval since the epoch [min].\n\nReturns\n\nThe following elements perturbed by lunar-solar periodics.\n\nEccentricity.\nInclination [rad].\nRight ascension of the ascending node [rad].\nArgument of perigee [rad].\nMean anomaly [rad].\n\n\n\n\n\n","category":"method"},{"location":"lib/library/#SatelliteToolbox.SGP4.dssec!-Union{Tuple{T}, Tuple{SatelliteToolbox.SGP4.SGP4_DeepSpace{T}, T, T, T, T, T, T, T, T, Number}} where T<:Number","page":"Library","title":"SatelliteToolbox.SGP4.dssec!","text":"dssec!(sgp4_ds::SGP4_DeepSpace{T}, nll_0::T, e_0::T, i_0::T, ω_0::T, Ω_k::T, ω_k::T, M_k::T, dotω::T, Δt::Number) where T<:Number\n\nCompute the secular effects.\n\nNotice that the values in the structure sgp4_ds will be modified.\n\nArgs\n\nsgp4_ds: Deep space structure (see SGP4_DeepSpace).\nnll_0: Initial mean motion [rad/min].\ne_0: Initial eccentricity.\ni_0: Initial inclination [rad].\nω_0: Initial argument of perigee [rad].\nΩ_k: Current right ascension of the ascending node [rad].\nω_k: Current argument of perigee [rad].\nM_k: Current mean anomaly [rad].\ndotω: Time-derivative of the argument of perigee [rad/min].\nΔt: Time interval since the epoch [min].\n\nReturns\n\nThe following elements perturbed by the secular effects:\n\nMean motion [rad/min].\nEccentricity.\nInclination [rad].\nRight ascension of the ascending node [rad].\nArgument of perigee [rad].\nMean anomaly [rad].\n\n\n\n\n\n","category":"method"},{"location":"lib/library/#SatelliteToolbox.SGP4.j2000_to_gmst-Tuple{Number}","page":"Library","title":"SatelliteToolbox.SGP4.j2000_to_gmst","text":"j2000_to_gmst(J2000_UT1::Number)\n\nCompute the Greenwich Mean Sideral Time (GMST) [rad] given the instant J2000_UT1 in J2000.0 reference [UT1].\n\nRemarks\n\nBased on algorithm in 2, accessed at 2015-12-01.\n\n\n\n\n\n","category":"method"},{"location":"lib/library/#SatelliteToolbox.SGP4.jd_to_gmst-Tuple{Number}","page":"Library","title":"SatelliteToolbox.SGP4.jd_to_gmst","text":"jd_to_gmst(JD_UT1::Number)\n\nCompute the Greenwich Mean Sideral Time (GMST) [rad] for the Julian Day JD_UT1 [UT1].\n\nRemarks\n\nBased on algorithm in [1, pp. 188].\n\n\n\n\n\n","category":"method"},{"location":"lib/library/#SatelliteToolbox.SGP4.sgp4!-Union{Tuple{T}, Tuple{SGP4_Structure{T}, Number}} where T","page":"Library","title":"SatelliteToolbox.SGP4.sgp4!","text":"sgp4!(sgp4d::SGP4_Structure{T}, t::Number) where T\n\nPropagate the orbit defined in sgp4d (see SGP4_Structure) until the time t [min]. Notice that the values in sgp4d will be modified.\n\nReturns\n\nThe position vector represented in TEME frame at time t [km].\nThe velocity vector represented in TEME frame at time t [km/s].\n\n\n\n\n\n","category":"method"},{"location":"lib/library/#SatelliteToolbox.SGP4.sgp4-Tuple{Any, Vararg{Any, N} where N}","page":"Library","title":"SatelliteToolbox.SGP4.sgp4","text":"sgp4(Δt, args...)\n\nFunction that initialize the SGP4 structure and propagate the orbit until the time Δt.\n\nReturns\n\nThe position vector [km].\nThe velocity vector [km/s].\nThe SGP4 structure (see SGP4_Structure).\n\n\n\n\n\n","category":"method"},{"location":"lib/library/#SatelliteToolbox.SGP4.sgp4_init","page":"Library","title":"SatelliteToolbox.SGP4.sgp4_init","text":"sgp4_init(spg4_gc::SGP4_GravCte{T}, epoch::Number, n_0::Number, e_0::Number, i_0::Number, Ω_0::Number, ω_0::Number, M_0::Number, bstar::Number) where T\nsgp4_init(tle::TLE, sgp4_gc::SGP4_GravCte = sgp4_gc_wgs84)\n\nInitialize the data structure of SGP4 algorithm.\n\nArgs\n\nspg4_gc: SPG4 gravitational constants (see SGP4_GravCte).\nepoch: Epoch of the orbital elements [Julian Day].\nn_0: SGP type \"mean\" mean motion at epoch [rad/min].\ne_0: \"Mean\" eccentricity at epoch.\ni_0: \"Mean\" inclination at epoch [rad].\nΩ_0: \"Mean\" longitude of the ascending node at epoch [rad].\nω_0: \"Mean\" argument of perigee at epoch [rad].\nM_0: \"Mean\" mean anomaly at epoch [rad].\nbstar: Drag parameter (B*).\ntle: TLE to initialize the SPG4 (see TLE).\n\nReturns\n\nThe structure SGP4_Structure with the initialized parameters.\n\n\n\n\n\n","category":"function"},{"location":"lib/library/#SatelliteToolbox.SatelliteToolboxTLE.TLE","page":"Library","title":"SatelliteToolbox.SatelliteToolboxTLE.TLE","text":"TLE\n\nThis structure contains the same elements of the TLE with the same units.\n\nFields\n\nname: Name of the satellite.\n\nFirst line\n\nsat_num: Satellite number.\nclassification: Classification ('U', 'C', or 'S').\nint_designator: International designator.\nepoch_year: Epoch year (two digits).\nepoch_day: Epoch day (day + fraction of the day).\nepoch: The epoch represented in Julian Day.\ndn_o2: 1st time derivative of mean motion / 2 [rev/day²].\nddn_o6: 2nd time derivative of mean motion / 6 [rev/day³].\nbstar: B* drag term.\nelem_set_number: Element set number.\nchecksum_l1: Checksum of the line 1 (modulo 10).\n\nSecond line\n\ni: Inclination [deg].\nΩ: Right ascension of the ascending node [deg].\ne: Eccentricity.\nω: Argument of perigee [deg].\nM: Mean anomaly [deg].\nn: Mean motion [rev/day].\nrev_num: Revolution number at epoch [rev].\nchecksum_l2: Checksum of the line 2 (modulo 10).\n\n\n\n\n\n","category":"type"},{"location":"lib/library/#SatelliteToolbox.SatelliteToolboxTLE._show_tle","page":"Library","title":"SatelliteToolbox.SatelliteToolboxTLE._show_tle","text":"_show_tle(io::IO, tle::TLE, color::Bool = true)\n\nShow the TLE tle in the IO io.\n\nIf color is true, then the text will be printed using colors. If color is omitted, then it defaults to true.\n\n\n\n\n\n","category":"function"},{"location":"lib/library/#SatelliteToolbox.SatelliteToolboxTLE.compute_checksum-Tuple{AbstractString}","page":"Library","title":"SatelliteToolbox.SatelliteToolboxTLE.compute_checksum","text":"compute_checksum(str::AbstractString)\n\nCompute the checksum of the line str modulo 10.\n\nThe algorithm is simple: add all the numbers in the line, ignoring letters, spaces, periods, and plus signs, but assigning +1 to the minus signs. The checksum is the remainder of the division by 10.\n\n\n\n\n\n","category":"method"},{"location":"lib/library/#SatelliteToolbox.SatelliteToolboxTLE.print_tle-Tuple{Any}","page":"Library","title":"SatelliteToolbox.SatelliteToolboxTLE.print_tle","text":"print_tle(io::IO, tle; kwargs...)\n\nPrint the TLE tle to the IO io. If io is omited, then stdout is used.\n\nThe keywords of this function are the same that can be used in tle_to_str.\n\n\n\n\n\n","category":"method"},{"location":"lib/library/#SatelliteToolbox.SatelliteToolboxTLE.read_tle","page":"Library","title":"SatelliteToolbox.SatelliteToolboxTLE.read_tle","text":"read_tle(tle_filename::String, verify_checksum::Bool = true)\n\nRead the TLEs in the file tle_filename and return an array of TLE with the parsed TLEs.\n\nIf verify_checksum if true, then the checksum of both TLE lines will be verified. Otherwise, the checksum will not be checked. If verify_checksum is omitted, then it defaults to true.\n\n\n\n\n\n","category":"function"},{"location":"lib/library/#SatelliteToolbox.SatelliteToolboxTLE.read_tle_from_string","page":"Library","title":"SatelliteToolbox.SatelliteToolboxTLE.read_tle_from_string","text":"read_tle_from_string(tles::String, verify_checksum::Bool = true)\nread_tle_from_string(tle_l1::String, tle_l2::String, verify_checksum::Bool = false)\n\nParse a set of TLEs in the string tles or one TLE with first line tle_l1 and second line tle_l2. This function returns an array of TLE with the parsed TLEs.\n\nIf verify_checksum if true, then the checksum of both TLE lines will be verified. Otherwise, the checksum will not be checked. If verify_checksum is omitted, then it defaults to true.\n\n\n\n\n\n","category":"function"},{"location":"lib/library/#SatelliteToolbox.SatelliteToolboxTLE.tle_to_str-Tuple{TLE}","page":"Library","title":"SatelliteToolbox.SatelliteToolboxTLE.tle_to_str","text":"tle_to_str(tle::TLE; recompute_checksum = true, bstar_exp_le = true)\n\nConvert the TLE tle to a string. If recompute_checksum is true, then the checksums in tle will be ignored and they will be computed considering the TLE data.\n\nThe keyword bstar_exp_le selects if the BSTAR exponent signal will be + or - when BSTAR is zero. This is required for the tests because it is not standardized in TLE generation. If it is true, then the exponent signal will be - when BSTAR is zero.\n\n\n\n\n\n","category":"method"},{"location":"lib/library/#SatelliteToolbox.SatelliteToolboxTLE.@parse_value-Tuple{Any, Any, Any}","page":"Library","title":"SatelliteToolbox.SatelliteToolboxTLE.@parse_value","text":"@parse_value(T, str, line_num)\n\nParse the string str using the type T. If it is not succeeded, then throw an error indicating the line line_num with the problem.\n\n\n\n\n\n","category":"macro"},{"location":"lib/library/#SatelliteToolbox.SatelliteToolboxTLE.@tle_str-Tuple{Any}","page":"Library","title":"SatelliteToolbox.SatelliteToolboxTLE.@tle_str","text":"@tle_str(str)\n\nParse a set of TLEs in the string str and return as an array of TLE. This version verifies the checksum of the TLE. If the checksum verification is not desired, see @tlenc_str.\n\nExample\n\njulia> tles = tle\"\"\"\n       CBERS 4\n       1 40336U 14079A   18166.15595376 -.00000014  00000-0  10174-4 0  9993\n       2 40336  98.4141 237.7928 0001694  75.7582 284.3804 14.35485112184485\n       SCD 1\n       1 22490U 93009B   18165.62596833  .00000225  00000-0  11410-4 0  9991\n       2 22490  24.9690 231.7852 0042844 200.7311 292.7198 14.44524498338066\n       SCD 2\n       1 25504U 98060A   18165.15074951  .00000201  00000-0  55356-5 0  9994\n       2 25504  24.9961  80.1303 0017060 224.4822 286.6438 14.44043397 37312\n       \"\"\"\n\n\n\n\n\n","category":"macro"},{"location":"lib/library/#SatelliteToolbox.SatelliteToolboxTLE.@tlenc_str-Tuple{Any}","page":"Library","title":"SatelliteToolbox.SatelliteToolboxTLE.@tlenc_str","text":"@tlenc_str(str)\n\nParse a set of TLEs in the string str and return as an array of TLE. This version does not verify the checksum of the TLE. If the checksum verification is required, see @tle_str.\n\nExample\n\njulia> tles = tlenc\"\"\"\n       CBERS 4\n       1 40336U 14079A   18166.15595376 -.00000014  00000-0  10174-4 0  9993\n       2 40336  98.4141 237.7928 0001694  75.7582 284.3804 14.35485112184485\n       SCD 1\n       1 22490U 93009B   18165.62596833  .00000225  00000-0  11410-4 0  9991\n       2 22490  24.9690 231.7852 0042844 200.7311 292.7198 14.44524498338066\n       SCD 2\n       1 25504U 98060A   18165.15074951  .00000201  00000-0  55356-5 0  9994\n       2 25504  24.9961  80.1303 0017060 224.4822 286.6438 14.44043397 37312\n       \"\"\"\n\n\n\n\n\n","category":"macro"},{"location":"#SatelliteToolbox.jl","page":"Home","title":"SatelliteToolbox.jl","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"CurrentModule = SatelliteToolbox\nDocTestSetup = quote\n    using SatelliteToolbox\nend","category":"page"},{"location":"","page":"Home","title":"Home","text":"This package contains several functions to build simulations related with satellites. It is used on a daily basis on projects at the Brazilian National Institute for Space Research (INPE), and it is the engine of the Forplan Satellite Simulator.","category":"page"},{"location":"","page":"Home","title":"Home","text":"warning: Warning\nThis documentation is under construction. However, the functions are extensively documented using the Julia documentation system, which can be accessed by typing ? followed by the function name in REPL.","category":"page"},{"location":"#Requirements","page":"Home","title":"Requirements","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"Julia >= 1.0\nCrayons >= 4.0.0\nInterpolations >= 0.12\nOptionalData >= 0.3\nParameters >= 0.12\nPolynomialRoots >= 0.2\nReferenceFrameRotations >= 0.5\nRemoteFiles >= 0.3\nStaticArrays >= 0.12","category":"page"},{"location":"#Installation","page":"Home","title":"Installation","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"This package can be installed using:","category":"page"},{"location":"","page":"Home","title":"Home","text":"julia> using Pkg\njulia> Pkg.add(\"SatelliteToolbox\")","category":"page"}]
}
