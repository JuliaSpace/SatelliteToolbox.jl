<!DOCTYPE html>
<html lang="en"><head><meta charset="UTF-8"/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><title>Library · Satellite Toolbox</title><link rel="canonical" href="https://juliaspace.github.io/SatelliteToolbox.jl/stable/lib/library/"/><link href="https://fonts.googleapis.com/css?family=Lato|Roboto+Mono" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.0/css/fontawesome.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.0/css/solid.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.0/css/brands.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/KaTeX/0.11.1/katex.min.css" rel="stylesheet" type="text/css"/><script>documenterBaseURL="../.."</script><script src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.3.6/require.min.js" data-main="../../assets/documenter.js"></script><script src="../../siteinfo.js"></script><script src="../../../versions.js"></script><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../../assets/themes/documenter-dark.css" data-theme-name="documenter-dark" data-theme-primary-dark/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../../assets/themes/documenter-light.css" data-theme-name="documenter-light" data-theme-primary/><script src="../../assets/themeswap.js"></script></head><body><div id="documenter"><nav class="docs-sidebar"><a class="docs-logo" href="../../"><img src="../../assets/logo.png" alt="Satellite Toolbox logo"/></a><div class="docs-package-name"><span class="docs-autofit">Satellite Toolbox</span></div><form class="docs-search" action="../../search/"><input class="docs-search-query" id="documenter-search-query" name="q" type="text" placeholder="Search docs"/></form><ul class="docs-menu"><li><a class="tocitem" href="../../">Home</a></li><li><span class="tocitem">Earth</span><ul><li><a class="tocitem" href="../../man/earth/atmospheric_models/">Earth atmospheric models</a></li><li><a class="tocitem" href="../../man/earth/geomagnetic_field_models/">Earth geomagnetic field models</a></li><li><a class="tocitem" href="../../man/earth/space_indices/">Space indices</a></li></ul></li><li><span class="tocitem">Orbit</span><ul><li><a class="tocitem" href="../../man/orbit/anomalies/">Anomalies</a></li><li><a class="tocitem" href="../../man/orbit/general/">General analysis</a></li><li><a class="tocitem" href="../../man/orbit/propagators/">Orbit propagators</a></li><li><a class="tocitem" href="../../man/orbit/tle/">TLE</a></li></ul></li><li><span class="tocitem">Transformations</span><ul><li><a class="tocitem" href="../../man/transformations/ecef_eci/">ECEF and ECI</a></li><li><a class="tocitem" href="../../man/transformations/geodetic_geocentric/">Geodetic and Geocentric</a></li></ul></li><li class="is-active"><a class="tocitem" href>Library</a></li></ul><div class="docs-version-selector field has-addons"><div class="control"><span class="docs-label button is-static is-size-7">Version</span></div><div class="docs-selector control is-expanded"><div class="select is-fullwidth is-size-7"><select id="documenter-version-selector"></select></div></div></div></nav><div class="docs-main"><header class="docs-navbar"><nav class="breadcrumb"><ul class="is-hidden-mobile"><li class="is-active"><a href>Library</a></li></ul><ul class="is-hidden-tablet"><li class="is-active"><a href>Library</a></li></ul></nav><div class="docs-right"><a class="docs-edit-link" href="https://github.com/JuliaSpace/SatelliteToolbox.jl/blob/master/docs/src/lib/library.md" title="Edit on GitHub"><span class="docs-icon fab"></span><span class="docs-label is-hidden-touch">Edit on GitHub</span></a><a class="docs-settings-button fas fa-cog" id="documenter-settings-button" href="#" title="Settings"></a><a class="docs-sidebar-button fa fa-bars is-hidden-desktop" id="documenter-sidebar-button" href="#"></a></div></header><article class="content" id="documenter-page"><h1 id="Library"><a class="docs-heading-anchor" href="#Library">Library</a><a id="Library-1"></a><a class="docs-heading-anchor-permalink" href="#Library" title="Permalink"></a></h1><p>Documentation for <code>SatelliteToolbox.jl</code>.</p><article class="docstring"><header><a class="docstring-binding" id="SatelliteToolbox.T_ECEFs" href="#SatelliteToolbox.T_ECEFs"><code>SatelliteToolbox.T_ECEFs</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia">T_ECEFs</code></pre><p>Union of all Earth-Centered Earth-Fixed (ECEF) frames supported by the IAU-76/FK5 theory.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaSpace/SatelliteToolbox.jl/blob/c7a891ae8cbd18d844cb2ba648927c3c6dfa564f/src/types/reference_frames.jl#L13-L19">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="SatelliteToolbox.T_ECEFs_IAU_2006" href="#SatelliteToolbox.T_ECEFs_IAU_2006"><code>SatelliteToolbox.T_ECEFs_IAU_2006</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia">T_ECEFs_IAU_2006</code></pre><p>Union of all Earth-Centered Earth-Fixed (ECEF) frames supported by IAU-2006/2010 theory.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaSpace/SatelliteToolbox.jl/blob/c7a891ae8cbd18d844cb2ba648927c3c6dfa564f/src/types/reference_frames.jl#L40-L46">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="SatelliteToolbox.T_ECIs" href="#SatelliteToolbox.T_ECIs"><code>SatelliteToolbox.T_ECIs</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia">T_ECIs</code></pre><p>Union of all Earth-Centered Inertial (ECI) frames supported by the IAU-76/FK5 theory.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaSpace/SatelliteToolbox.jl/blob/c7a891ae8cbd18d844cb2ba648927c3c6dfa564f/src/types/reference_frames.jl#L22-L28">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="SatelliteToolbox.T_ECIs_IAU_2006" href="#SatelliteToolbox.T_ECIs_IAU_2006"><code>SatelliteToolbox.T_ECIs_IAU_2006</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia">T_ECIs_IAU_2006</code></pre><p>Union of all Earth-Centered Inertial (ECI) frames supported by IAU-2006/2010 theory.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaSpace/SatelliteToolbox.jl/blob/c7a891ae8cbd18d844cb2ba648927c3c6dfa564f/src/types/reference_frames.jl#L67-L73">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="SatelliteToolbox.T_ECIs_IAU_2006_CIO" href="#SatelliteToolbox.T_ECIs_IAU_2006_CIO"><code>SatelliteToolbox.T_ECIs_IAU_2006_CIO</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia">T_ECIs_IAU_2006_CIO</code></pre><p>Union of all Earth-Centered Inertial (ECI) frames supported by CIO-based IAU-2006/2010 theory.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaSpace/SatelliteToolbox.jl/blob/c7a891ae8cbd18d844cb2ba648927c3c6dfa564f/src/types/reference_frames.jl#L49-L55">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="SatelliteToolbox.T_ECIs_IAU_2006_Equinox" href="#SatelliteToolbox.T_ECIs_IAU_2006_Equinox"><code>SatelliteToolbox.T_ECIs_IAU_2006_Equinox</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia">T_ECIs_IAU_2006_Equinox</code></pre><p>Union of all Earth-Centered Inertial (ECI) frames supported by Equinox-based IAU-2006/2010 theory.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaSpace/SatelliteToolbox.jl/blob/c7a891ae8cbd18d844cb2ba648927c3c6dfa564f/src/types/reference_frames.jl#L58-L64">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="SatelliteToolbox.T_ECIs_IAU_2006_Equinox_of_date" href="#SatelliteToolbox.T_ECIs_IAU_2006_Equinox_of_date"><code>SatelliteToolbox.T_ECIs_IAU_2006_Equinox_of_date</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia">T_ECIs_IAU_2006_Equinox_of_date</code></pre><p>Union of all <em>of date</em> Earth-Centered Inertial (ECI) frames supported by the equinox-based IAU-2006/2010 theory.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaSpace/SatelliteToolbox.jl/blob/c7a891ae8cbd18d844cb2ba648927c3c6dfa564f/src/types/reference_frames.jl#L76-L82">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="SatelliteToolbox.T_ECIs_of_date" href="#SatelliteToolbox.T_ECIs_of_date"><code>SatelliteToolbox.T_ECIs_of_date</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia">T_ECIs_of_date</code></pre><p>Union of all <em>of date</em> Earth-Centered Inertial (ECI) frames supported by the IAU-76/FK5 theory.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaSpace/SatelliteToolbox.jl/blob/c7a891ae8cbd18d844cb2ba648927c3c6dfa564f/src/types/reference_frames.jl#L31-L37">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="SatelliteToolbox.T_ROT" href="#SatelliteToolbox.T_ROT"><code>SatelliteToolbox.T_ROT</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia">T_ROT</code></pre><p>Union of all supported rotation descriptions.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaSpace/SatelliteToolbox.jl/blob/c7a891ae8cbd18d844cb2ba648927c3c6dfa564f/src/types/reference_frames.jl#L85-L90">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="SatelliteToolbox._expatmosphere_H" href="#SatelliteToolbox._expatmosphere_H"><code>SatelliteToolbox._expatmosphere_H</code></a> — <span class="docstring-category">Constant</span></header><section><div><pre><code class="language-julia">_expatmosphere_H</code></pre><p>Scale height for the exponential atmospheric model [km].</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaSpace/SatelliteToolbox.jl/blob/c7a891ae8cbd18d844cb2ba648927c3c6dfa564f/src/earth/atmospheric_models/expatmosphere/expatmosphere.jl#L82-L87">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="SatelliteToolbox._expatmosphere_h₀" href="#SatelliteToolbox._expatmosphere_h₀"><code>SatelliteToolbox._expatmosphere_h₀</code></a> — <span class="docstring-category">Constant</span></header><section><div><pre><code class="language-julia">_expatmosphere_h₀</code></pre><p>Base altitude for the exponential atmospheric model [km].</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaSpace/SatelliteToolbox.jl/blob/c7a891ae8cbd18d844cb2ba648927c3c6dfa564f/src/earth/atmospheric_models/expatmosphere/expatmosphere.jl#L58-L63">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="SatelliteToolbox._expatmosphere_ρ₀" href="#SatelliteToolbox._expatmosphere_ρ₀"><code>SatelliteToolbox._expatmosphere_ρ₀</code></a> — <span class="docstring-category">Constant</span></header><section><div><pre><code class="language-julia">_expatmosphere_ρ₀</code></pre><p>Nominal density for the exponential atmospheric model [kg/m³].</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaSpace/SatelliteToolbox.jl/blob/c7a891ae8cbd18d844cb2ba648927c3c6dfa564f/src/earth/atmospheric_models/expatmosphere/expatmosphere.jl#L68-L73">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="SatelliteToolbox._jr1971_constants" href="#SatelliteToolbox._jr1971_constants"><code>SatelliteToolbox._jr1971_constants</code></a> — <span class="docstring-category">Constant</span></header><section><div><pre><code class="language-julia">_jr1971_constants</code></pre><p>Constants for the Jacchia-Roberts 1971 Atmospheric Model.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaSpace/SatelliteToolbox.jl/blob/c7a891ae8cbd18d844cb2ba648927c3c6dfa564f/src/earth/atmospheric_models/jr1971/jr1971_priv.jl#L196-L201">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="SatelliteToolbox._jr1971_id" href="#SatelliteToolbox._jr1971_id"><code>SatelliteToolbox._jr1971_id</code></a> — <span class="docstring-category">Constant</span></header><section><div><pre><code class="language-julia">_jr1971_id</code></pre><p>Index of the species for the Jacchia-Roberts 1971 Atmospheric Model.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaSpace/SatelliteToolbox.jl/blob/c7a891ae8cbd18d844cb2ba648927c3c6dfa564f/src/earth/atmospheric_models/jr1971/jr1971_priv.jl#L204-L209">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="SatelliteToolbox.EOPData_IAU1980" href="#SatelliteToolbox.EOPData_IAU1980"><code>SatelliteToolbox.EOPData_IAU1980</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia">EOPData_IAU1980{T}</code></pre><p>EOP Data for IAU 1980.</p><p><strong>Fields</strong></p><ul><li><code>x, y</code>: Polar motion with respect to the crust [arcsec].</li><li><code>UT1_UTC</code>: Irregularities of the rotation angle [s].</li><li><code>LOD</code>: Length of day offset [s].</li><li><code>dPsi, dEps</code>: Celestial pole offsets referred to the model IAU1980 [arcsec].</li><li><code>*_err</code>: Errors in the components [same unit as the component].</li></ul><p><strong>Remarks</strong></p><p>Each field will be an <code>AbstractInterpolation</code> indexed by the Julian Day. Hence, if one want to obtain, for example, the X component of the polar motion with respect to the crust at 19 June 2018, the following can be used:</p><pre><code class="language-none">x[DatestoJD(2018,19,06,0,0,0)]</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaSpace/SatelliteToolbox.jl/blob/c7a891ae8cbd18d844cb2ba648927c3c6dfa564f/src/types/iers_eop.jl#L12-L33">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="SatelliteToolbox.EOPData_IAU2000A" href="#SatelliteToolbox.EOPData_IAU2000A"><code>SatelliteToolbox.EOPData_IAU2000A</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia">EOPData_IAU2000A{T}</code></pre><p>EOP Data for IAU 2000A.</p><p><strong>Fields</strong></p><ul><li><code>x, y</code>: Polar motion with respect to the crust [arcsec].</li><li><code>UT1_UTC</code>: Irregularities of the rotation angle [s].</li><li><code>LOD</code>: Length of day offset [s].</li><li><code>dX, dY</code>: Celestial pole offsets referred to the model IAU2000A [arcsec].</li><li><code>*_err</code>: Errors in the components [same unit as the component].</li></ul><p><strong>Remarks</strong></p><p>Each field will be an <code>AbstractInterpolation</code> indexed by the Julian Day. Hence, if one want to obtain, for example, the X component of the polar motion with respect to the crust at 19 June 2018, the following can be used:</p><pre><code class="language-none">x[DatestoJD(2018,19,06,0,0,0)]</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaSpace/SatelliteToolbox.jl/blob/c7a891ae8cbd18d844cb2ba648927c3c6dfa564f/src/types/iers_eop.jl#L51-L72">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="SatelliteToolbox.GravityModel_Coefs" href="#SatelliteToolbox.GravityModel_Coefs"><code>SatelliteToolbox.GravityModel_Coefs</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia">GravityModel_Coefs{T}</code></pre><p>Structure to store the information about a gravity model.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaSpace/SatelliteToolbox.jl/blob/c7a891ae8cbd18d844cb2ba648927c3c6dfa564f/src/types/gravity_models.jl#L40-L45">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="SatelliteToolbox.ICGEM" href="#SatelliteToolbox.ICGEM"><code>SatelliteToolbox.ICGEM</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia">ICGEM</code></pre><p>Structure to store the information contained in ICGEM files.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaSpace/SatelliteToolbox.jl/blob/c7a891ae8cbd18d844cb2ba648927c3c6dfa564f/src/types/gravity_models.jl#L12-L17">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="SatelliteToolbox.J2_GravCte" href="#SatelliteToolbox.J2_GravCte"><code>SatelliteToolbox.J2_GravCte</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia">J2_GravCte{T}</code></pre><p>Gravitational constants for J2 orbit propagator.</p><p><strong>Fields</strong></p><ul><li><code>R0</code>: Earth equatorial radius [m].</li><li><code>μm</code>: √GM [er/s]^(3/2).</li><li><code>J2</code>: The second gravitational zonal harmonic of the Earth.</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaSpace/SatelliteToolbox.jl/blob/c7a891ae8cbd18d844cb2ba648927c3c6dfa564f/src/types/propagators.jl#L80-L91">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="SatelliteToolbox.J2_Structure" href="#SatelliteToolbox.J2_Structure"><code>SatelliteToolbox.J2_Structure</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia">J2_Structure{T}</code></pre><p>Low level J2 orbit propagator structure.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaSpace/SatelliteToolbox.jl/blob/c7a891ae8cbd18d844cb2ba648927c3c6dfa564f/src/types/propagators.jl#L98-L103">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="SatelliteToolbox.J2osc_Structure" href="#SatelliteToolbox.J2osc_Structure"><code>SatelliteToolbox.J2osc_Structure</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia">J2osc_Structure{T}</code></pre><p>Low level J2 osculating orbit propagator structure.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaSpace/SatelliteToolbox.jl/blob/c7a891ae8cbd18d844cb2ba648927c3c6dfa564f/src/types/propagators.jl#L160-L165">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="SatelliteToolbox.J4_GravCte" href="#SatelliteToolbox.J4_GravCte"><code>SatelliteToolbox.J4_GravCte</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia">J4_GravCte{T}</code></pre><p>Gravitational constants for J4 orbit propagator.</p><p><strong>Fields</strong></p><ul><li><code>R0</code>: Earth equatorial radius [m].</li><li><code>μm</code>: √GM [er/s]^(3/2).</li><li><code>J2</code>: The second gravitational zonal harmonic of the Earth.</li><li><code>J4</code>: The fourth gravitational zonal harmonic of the Earth.</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaSpace/SatelliteToolbox.jl/blob/c7a891ae8cbd18d844cb2ba648927c3c6dfa564f/src/types/propagators.jl#L205-L217">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="SatelliteToolbox.J4_Structure" href="#SatelliteToolbox.J4_Structure"><code>SatelliteToolbox.J4_Structure</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia">J4_Structure{T}</code></pre><p>Low level J4 orbit propagator structure.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaSpace/SatelliteToolbox.jl/blob/c7a891ae8cbd18d844cb2ba648927c3c6dfa564f/src/types/propagators.jl#L225-L230">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="SatelliteToolbox.JB2008_Output" href="#SatelliteToolbox.JB2008_Output"><code>SatelliteToolbox.JB2008_Output</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia">JB2008_Output</code></pre><p>Output structure of the Jacchia-Bowman 2008.</p><p><strong>Fields</strong></p><ul><li><code>nN2</code>: Number density of N₂ [1/m³].</li><li><code>nO2</code>: Number density of O₂ [1/m³].</li><li><code>nO</code>: Number density of O [1/m³].</li><li><code>nAr</code>: Number density of Ar [1/m³].</li><li><code>nHe</code>: Number density of He [1/m³].</li><li><code>nH</code>: Number density of H [1/m³].</li><li><code>rho</code>: Total density [kg/m³].</li><li><code>T_exo</code>: Exospheric temperature [K].</li><li><code>Tz</code>: Temperature at the selected altitude [K].</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaSpace/SatelliteToolbox.jl/blob/c7a891ae8cbd18d844cb2ba648927c3c6dfa564f/src/types/atmospheric_models.jl#L15-L32">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="SatelliteToolbox.JR1971_CONSTANTS" href="#SatelliteToolbox.JR1971_CONSTANTS"><code>SatelliteToolbox.JR1971_CONSTANTS</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia">JR1971_CONSTANTS{T}</code></pre><p>Structure with the constants for the Jacchia-Roberts 1971 Atmospheric Model.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaSpace/SatelliteToolbox.jl/blob/c7a891ae8cbd18d844cb2ba648927c3c6dfa564f/src/earth/atmospheric_models/jr1971/jr1971_priv.jl#L30-L35">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="SatelliteToolbox.JR1971_Output" href="#SatelliteToolbox.JR1971_Output"><code>SatelliteToolbox.JR1971_Output</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia">JR1971_Output</code></pre><p>Output structure of the Jacchia-Roberts 1971 model.</p><p><strong>Fields</strong></p><ul><li><code>nN2</code>: Number density of N₂ [1/m³].</li><li><code>nO2</code>: Number density of O₂ [1/m³].</li><li><code>nO</code>: Number density of O [1/m³].</li><li><code>nAr</code>: Number density of Ar [1/m³].</li><li><code>nHe</code>: Number density of He [1/m³].</li><li><code>nH</code>: Number density of H [1/m³].</li><li><code>rho</code>: Total density [kg/m³].</li><li><code>T_exo</code>: Exospheric temperature [K].</li><li><code>Tz</code>: Temperature at the selected altitude [K].</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaSpace/SatelliteToolbox.jl/blob/c7a891ae8cbd18d844cb2ba648927c3c6dfa564f/src/types/atmospheric_models.jl#L50-L67">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="SatelliteToolbox.KeplerianElements" href="#SatelliteToolbox.KeplerianElements"><code>SatelliteToolbox.KeplerianElements</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia">KeplerianElements{T1,T2}</code></pre><p>This structure defines the orbit in terms of the Keplerian elements.</p><p><strong>Fields</strong></p><ul><li><code>t</code>: Epoch.</li><li><code>a</code>: Semi-major axis [m].</li><li><code>e</code>: Eccentricity [ ].</li><li><code>i</code>: Inclination [rad].</li><li><code>Ω</code>: Right ascension of the ascending node [rad].</li><li><code>ω</code>: Argument of perigee [rad].</li><li><code>f</code>: True anomaly [rad].</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaSpace/SatelliteToolbox.jl/blob/c7a891ae8cbd18d844cb2ba648927c3c6dfa564f/src/types/orbit.jl#L20-L35">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="SatelliteToolbox.NRLMSISE00_Flags" href="#SatelliteToolbox.NRLMSISE00_Flags"><code>SatelliteToolbox.NRLMSISE00_Flags</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia">NRLMSISE00_Flags</code></pre><p>Flags to configure NRLMSISE-00.</p><p><strong>Fields</strong></p><ul><li><code>output_m_kg</code></li><li><code>F107_Mean</code></li><li><code>time_independent</code></li><li><code>sym_annual</code></li><li><code>sym_semiannual</code></li><li><code>asym_annual</code></li><li><code>asyn_semiannual</code></li><li><code>diurnal</code></li><li><code>semidiurnal</code></li><li><code>daily_ap</code></li><li><code>all_ut_long_effects</code></li><li><code>longitudinal</code></li><li><code>ut_mixed_ut_long</code></li><li><code>mixed_ap_ut_long</code></li><li><code>terdiurnal</code></li><li><code>departures_from_eq</code></li><li><code>all_tinf_var</code></li><li><code>all_tlb_var</code></li><li><code>all_tn1_var</code></li><li><code>all_s_var</code></li><li><code>all_tn2_var</code></li><li><code>all_nlb_var</code></li><li><code>all_tn3_var</code></li><li><code>turbo_scale_height</code></li><li><code>use_ap_array</code></li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaSpace/SatelliteToolbox.jl/blob/c7a891ae8cbd18d844cb2ba648927c3c6dfa564f/src/types/atmospheric_models.jl#L85-L118">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="SatelliteToolbox.NRLMSISE00_Output" href="#SatelliteToolbox.NRLMSISE00_Output"><code>SatelliteToolbox.NRLMSISE00_Output</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia">NRLMSISE00_Output</code></pre><p>Output structure for NRLMSISE00 model.</p><p><strong>Fields</strong></p><ul><li><code>den_N</code>: Nitrogen number density [U].</li><li><code>den_N2</code>: N₂ number density [U].</li><li><code>den_O</code>: Oxygen number density [U].</li><li><code>den_aO</code>: Anomalous Oxygen number density [U].</li><li><code>den_O2</code>: O₂ number density [U].</li><li><code>den_H</code>: Hydrogen number density [U].</li><li><code>den_He</code>: Helium number density [U].</li><li><code>den_Ar</code>: Argon number density [U].</li><li><code>den_Total</code>: Total mass density [T/U] (this value has different meanings for              routines <code>gtd7</code> and <code>gtd7d</code>).</li><li><code>T_exo</code>: Exospheric temperature [K].</li><li><code>T_alt</code>: Temperature at the selected altitude [K].</li><li><code>flags</code>: Flags used to compute NRLMSISE-00 model.</li></ul><p>Notice that:</p><ul><li>If <code>flags.output_m_kg</code> is <code>false</code>, then [U] is [cm⁻³] and [T] is [g/cm⁻³].</li><li>If <code>flags.output_m_kg</code> is <code>true</code>, then [U] is [m⁻³] and [T] is [kg/m⁻³].</li></ul><p><strong>Remarks</strong></p><p>Anomalous oxygen is defined as hot atomic oxygen or ionized oxygen that can become appreciable at high altitudes (<code>&gt; 500 km</code>) for some ranges of inputs, thereby affection drag on satellites and debris. We group these species under the term <strong>Anomalous Oxygen</strong>, since their individual variations are not presently separable with the drag data used to define this model component.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaSpace/SatelliteToolbox.jl/blob/c7a891ae8cbd18d844cb2ba648927c3c6dfa564f/src/types/atmospheric_models.jl#L195-L229">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="SatelliteToolbox.NRLMSISE00_Structure" href="#SatelliteToolbox.NRLMSISE00_Structure"><code>SatelliteToolbox.NRLMSISE00_Structure</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia">NRLMSISE00_Structure{T}</code></pre><p>Structure with the configuration parameters for NRLMSISE-00 model. It can be created using the function <code>conf_nrlmsise00</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaSpace/SatelliteToolbox.jl/blob/c7a891ae8cbd18d844cb2ba648927c3c6dfa564f/src/types/atmospheric_models.jl#L147-L153">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="SatelliteToolbox.Orbit" href="#SatelliteToolbox.Orbit"><code>SatelliteToolbox.Orbit</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia">Orbit</code></pre><p>Abstract type of an orbit representation.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaSpace/SatelliteToolbox.jl/blob/c7a891ae8cbd18d844cb2ba648927c3c6dfa564f/src/types/orbit.jl#L12-L17">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="SatelliteToolbox.OrbitPropagator" href="#SatelliteToolbox.OrbitPropagator"><code>SatelliteToolbox.OrbitPropagator</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia">OrbitPropagator{T}</code></pre><p>Abstract type of the orbit propagator. Every propagator structure must be a subtype of this type and must implement the following API functions:</p><pre><code class="language-none">propagate!(orbp, t::Number)
propagate!(orbp, t::AbstractVector)
propagate_to_epoch!(orbp, JD::Number)
propagate_to_epoch!(orbp, JD::AbstractVector)
step!(orbp, Δt::Number)</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaSpace/SatelliteToolbox.jl/blob/c7a891ae8cbd18d844cb2ba648927c3c6dfa564f/src/types/propagators.jl#L12-L24">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="SatelliteToolbox.OrbitPropagatorJ2" href="#SatelliteToolbox.OrbitPropagatorJ2"><code>SatelliteToolbox.OrbitPropagatorJ2</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia">OrbitPropagatorJ2{T} &lt;: OrbitPropagator{T}</code></pre><p>Structure that holds the information related to the J2 orbit propagator.</p><p><strong>Fields</strong></p><ul><li><code>j2d</code>: Structure that stores the J2 orbit propagator data (see        <code>J2_Structure</code>).</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaSpace/SatelliteToolbox.jl/blob/c7a891ae8cbd18d844cb2ba648927c3c6dfa564f/src/types/propagators.jl#L140-L150">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="SatelliteToolbox.OrbitPropagatorJ2osc" href="#SatelliteToolbox.OrbitPropagatorJ2osc"><code>SatelliteToolbox.OrbitPropagatorJ2osc</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia">OrbitPropagatorJ2osc{T} &lt;: OrbitPropagator{T}</code></pre><p>Structure that holds the information related to the J2 osculating orbit propagator.</p><p><strong>Fields</strong></p><ul><li><code>j2oscd</code>: Structure that stores the J2 osculating orbit propagator data (see           <code>J2osc_Structure</code>).</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaSpace/SatelliteToolbox.jl/blob/c7a891ae8cbd18d844cb2ba648927c3c6dfa564f/src/types/propagators.jl#L184-L195">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="SatelliteToolbox.OrbitPropagatorJ4" href="#SatelliteToolbox.OrbitPropagatorJ4"><code>SatelliteToolbox.OrbitPropagatorJ4</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia">OrbitPropagatorJ4{T} &lt;: OrbitPropagator{T}</code></pre><p>Structure that holds the information related to the J4 orbit propagator.</p><p><strong>Fields</strong></p><ul><li><code>j4d</code>: Structure that stores the J4 orbit propagator data (see        <code>J4_Structure</code>).</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaSpace/SatelliteToolbox.jl/blob/c7a891ae8cbd18d844cb2ba648927c3c6dfa564f/src/types/propagators.jl#L267-L277">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="SatelliteToolbox.OrbitPropagatorSGP4" href="#SatelliteToolbox.OrbitPropagatorSGP4"><code>SatelliteToolbox.OrbitPropagatorSGP4</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia">OrbitPropagatorSGP4{T} &lt;: OrbitPropagator{T}</code></pre><p>Structure that holds the information related to the SGP4 propagator.</p><p><strong>Fields</strong></p><ul><li><code>sgp4d</code>: Structure that stores the SGP4 data (see <code>SGP4_Structure</code>).</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaSpace/SatelliteToolbox.jl/blob/c7a891ae8cbd18d844cb2ba648927c3c6dfa564f/src/types/propagators.jl#L287-L296">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="SatelliteToolbox.OrbitPropagatorTwoBody" href="#SatelliteToolbox.OrbitPropagatorTwoBody"><code>SatelliteToolbox.OrbitPropagatorTwoBody</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia">OrbitPropagatorTwoBody{T} &lt;: OrbitPropagator{T}</code></pre><p>Structure that holds the information related to the Two Body orbit propagator.</p><p><strong>Fields</strong></p><ul><li><code>orb</code>: Mean orbital elements (see <code>Orbit</code>).</li><li><code>tbd</code>: Structure that stores the Two Body orbit propagator data (see       <code>TwoBody_Structure</code>).</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaSpace/SatelliteToolbox.jl/blob/c7a891ae8cbd18d844cb2ba648927c3c6dfa564f/src/types/propagators.jl#L59-L70">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="SatelliteToolbox.OrbitStateVector" href="#SatelliteToolbox.OrbitStateVector"><code>SatelliteToolbox.OrbitStateVector</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia">OrbitStateVector{T}</code></pre><p>Store the state vector representation of an orbit.</p><p><strong>Fields</strong></p><ul><li><code>t</code>: Epoch [Julian Day].</li><li><code>r</code>: Position vector [m].</li><li><code>v</code>: Velocity vector [m/s].</li><li><code>a</code>: Acceleration vector [m/s²].</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaSpace/SatelliteToolbox.jl/blob/c7a891ae8cbd18d844cb2ba648927c3c6dfa564f/src/types/orbit.jl#L52-L64">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="SatelliteToolbox.TwoBody_Structure" href="#SatelliteToolbox.TwoBody_Structure"><code>SatelliteToolbox.TwoBody_Structure</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia">TwoBody_Structure{T}</code></pre><p>Low level Two Body orbit propagator structure.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaSpace/SatelliteToolbox.jl/blob/c7a891ae8cbd18d844cb2ba648927c3c6dfa564f/src/types/propagators.jl#L32-L37">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="SatelliteToolbox._DTCFILE_Structure" href="#SatelliteToolbox._DTCFILE_Structure"><code>SatelliteToolbox._DTCFILE_Structure</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia">_DTCFILE_Structure</code></pre><p>Structure to store the interpolations of the data in <code>DTCFILE.TXT</code> file.</p><p><strong>Fields</strong></p><ul><li><code>DstΔTc</code>: Temperature variation due to Dst [K].</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaSpace/SatelliteToolbox.jl/blob/c7a891ae8cbd18d844cb2ba648927c3c6dfa564f/src/earth/space_indices/dtcfile.jl#L16-L25">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="SatelliteToolbox._SOLFSMY_Structure" href="#SatelliteToolbox._SOLFSMY_Structure"><code>SatelliteToolbox._SOLFSMY_Structure</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia">_SOLFSMY_Structure</code></pre><p>Structure to store the interpolations of the data in <code>SOLFSMY.TXT</code> file.</p><p><strong>Fields</strong></p><ul><li><code>F10</code>: 10.7-cm solar flux [10⁻²² W/(m² Hz)].</li><li><code>F81a</code>: 10.7-cm averaged solar flux, 81-day centered on input time.</li><li><code>S10</code>: EUV index.</li><li><code>S81a</code>: EUV 81-day averaged centered index.</li><li><code>M10</code>: MG2 index scaled to F10.</li><li><code>M81a</code>: MG2 81-day averaged centered index.</li><li><code>Y81a</code>: Solar X-ray &amp; Lya 81-day averaged centered index.</li><li><code>Y81a</code>: Solar X-ray &amp; Lya 81-day averaged centered index.</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaSpace/SatelliteToolbox.jl/blob/c7a891ae8cbd18d844cb2ba648927c3c6dfa564f/src/earth/space_indices/solfsmy.jl#L20-L36">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="SatelliteToolbox._WDC_Structure" href="#SatelliteToolbox._WDC_Structure"><code>SatelliteToolbox._WDC_Structure</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia">_WDC_Structure</code></pre><p>Structure to store the interpolations of the data in WDC files.</p><p><strong>Fields</strong></p><ul><li><code>Kp</code>: Kp index.</li><li><code>Ap</code>: Ap index.</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaSpace/SatelliteToolbox.jl/blob/c7a891ae8cbd18d844cb2ba648927c3c6dfa564f/src/earth/space_indices/wdcfiles.jl#L20-L30">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="SatelliteToolbox.E_to_M-Tuple{Number, Number}" href="#SatelliteToolbox.E_to_M-Tuple{Number, Number}"><code>SatelliteToolbox.E_to_M</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">E_to_M(e::Number, E::Number)</code></pre><p>Compute the mean anomaly (0,2π) [rad] given the eccentricity <code>e</code> and the eccentric anomaly <code>E</code> [rad].</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaSpace/SatelliteToolbox.jl/blob/c7a891ae8cbd18d844cb2ba648927c3c6dfa564f/src/orbit/anomalies.jl#L91-L97">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="SatelliteToolbox.E_to_f-Tuple{Number, Number}" href="#SatelliteToolbox.E_to_f-Tuple{Number, Number}"><code>SatelliteToolbox.E_to_f</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">E_to_f(e::Number, E::Number)</code></pre><p>Compute the true anomaly (0,2π) [rad] given the eccentricity <code>e</code> and the eccentric anomaly <code>E</code> [rad].</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaSpace/SatelliteToolbox.jl/blob/c7a891ae8cbd18d844cb2ba648927c3c6dfa564f/src/orbit/anomalies.jl#L77-L83">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="SatelliteToolbox.M_to_E" href="#SatelliteToolbox.M_to_E"><code>SatelliteToolbox.M_to_E</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">M_to_E(e::Number, M::Number, tol::Number = 1e-10)</code></pre><p>Compute the eccentric anomaly (0,2π) [rad] given the eccentricity <code>e</code> and the mean anomaly <code>M</code> [rad]. This function uses the Newton-Raphson algorithm and the tolerance to accept the solution is <code>tol</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaSpace/SatelliteToolbox.jl/blob/c7a891ae8cbd18d844cb2ba648927c3c6dfa564f/src/orbit/anomalies.jl#L24-L31">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="SatelliteToolbox.M_to_f" href="#SatelliteToolbox.M_to_f"><code>SatelliteToolbox.M_to_f</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">M_to_f(e::Number, M::Number, tol::Number = 1e-10)</code></pre><p>Compute the true anomaly (0,2π) [rad] given the eccentricity <code>e</code> and the mean anomaly <code>M</code> [rad]. This function uses the Newton-Raphson algorithm and the tolerance to accept the solution is <code>tol</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaSpace/SatelliteToolbox.jl/blob/c7a891ae8cbd18d844cb2ba648927c3c6dfa564f/src/orbit/anomalies.jl#L57-L64">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="SatelliteToolbox._ccor-Union{Tuple{T}, NTuple{4, T}} where T&lt;:Number" href="#SatelliteToolbox._ccor-Union{Tuple{T}, NTuple{4, T}} where T&lt;:Number"><code>SatelliteToolbox._ccor</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">_ccor(alt::T, r::T, h1::T, zh::T) where T&lt;:Number</code></pre><p>Chemistry / Dissociation correction for MSIS models.</p><p><strong>Args</strong></p><ul><li><code>alt</code>: Altitude.</li><li><code>r</code>: Target ratio.</li><li><code>h1</code>: Transition scale length.</li><li><code>zh</code>: Altitude of <code>1/2 r</code>.</li></ul><p><strong>Returns</strong></p><p>The chemistry / dissociation correction.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaSpace/SatelliteToolbox.jl/blob/c7a891ae8cbd18d844cb2ba648927c3c6dfa564f/src/earth/atmospheric_models/nrlmsise00/nrlmsise00_priv.jl#L28-L44">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="SatelliteToolbox._ccor2-Union{Tuple{T}, NTuple{5, T}} where T&lt;:Number" href="#SatelliteToolbox._ccor2-Union{Tuple{T}, NTuple{5, T}} where T&lt;:Number"><code>SatelliteToolbox._ccor2</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">_ccor2(alt::T, r::T, h1::T, zh::T, h2::T) where T&lt;:Number</code></pre><p>Chemistry / Dissociation correction for MSIS models.</p><p><strong>Args</strong></p><ul><li><code>alt</code>: Altitude.</li><li><code>r</code>: Target ration.</li><li><code>h1</code>: Transition scale length.</li><li><code>zh</code>: Altitude of <code>1/2 r</code>.</li><li><code>h2</code>: Transition scale length 2.</li></ul><p><strong>Returns</strong></p><p>The chemistry / dissociation correction.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaSpace/SatelliteToolbox.jl/blob/c7a891ae8cbd18d844cb2ba648927c3c6dfa564f/src/earth/atmospheric_models/nrlmsise00/nrlmsise00_priv.jl#L54-L71">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="SatelliteToolbox._densm-Union{Tuple{N3}, Tuple{N2}, Tuple{T}, Tuple{T, T, T, T, T, T, StaticArrays.StaticVector{N3, T}, AbstractVector{T}, AbstractVector{T}, StaticArrays.StaticVector{N2, T}, AbstractVector{T}, AbstractVector{T}}} where {T&lt;:Number, N2, N3}" href="#SatelliteToolbox._densm-Union{Tuple{N3}, Tuple{N2}, Tuple{T}, Tuple{T, T, T, T, T, T, StaticArrays.StaticVector{N3, T}, AbstractVector{T}, AbstractVector{T}, StaticArrays.StaticVector{N2, T}, AbstractVector{T}, AbstractVector{T}}} where {T&lt;:Number, N2, N3}"><code>SatelliteToolbox._densm</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">_densm(re::T, gsurf::T, alt::T, d0::T, xm::T, tz::T, zn3::StaticVector{N3,T}, tn3::AbstractVector{T}, tgn3::AbstractVector{T}, zn2::StaticVector{N2,T}, tn2::AbstractVector{T}, tgn2::AbstractVector{T}) where {T&lt;:Number,N2,N3}</code></pre><p>Compute the temperature and density profiles for lower atmosphere.</p><p><strong>Returns</strong></p><ul><li>The density.</li><li>The temperature.</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaSpace/SatelliteToolbox.jl/blob/c7a891ae8cbd18d844cb2ba648927c3c6dfa564f/src/earth/atmospheric_models/nrlmsise00/nrlmsise00_priv.jl#L83-L93">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="SatelliteToolbox._densu-Union{Tuple{N}, Tuple{T}, Tuple{T, T, T, T, T, T, T, T, T, T, StaticArrays.StaticVector{N, T}, AbstractVector{T}, AbstractVector{T}}} where {T&lt;:Number, N}" href="#SatelliteToolbox._densu-Union{Tuple{N}, Tuple{T}, Tuple{T, T, T, T, T, T, T, T, T, T, StaticArrays.StaticVector{N, T}, AbstractVector{T}, AbstractVector{T}}} where {T&lt;:Number, N}"><code>SatelliteToolbox._densu</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">_densu(re::T, gsurf::T, alt::T, dlb::T, tinf::T, tlb::T, xm::T, alpha::T, zlb::T, s2::T, zn1::StaticVector{N,T}, tn1::AbstractVector{T}, tgn1::AbstractVector{T}) where {T&lt;:Number,N}</code></pre><p>Compute the temperature and density profiles for MSIS models.</p><p>This algorithm uses new lower thermo polynomial.</p><p><strong>Returns</strong></p><ul><li>The density.</li><li>The temperature.</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaSpace/SatelliteToolbox.jl/blob/c7a891ae8cbd18d844cb2ba648927c3c6dfa564f/src/earth/atmospheric_models/nrlmsise00/nrlmsise00_priv.jl#L215-L227">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="SatelliteToolbox._dnet-Union{Tuple{T}, NTuple{5, T}} where T&lt;:Number" href="#SatelliteToolbox._dnet-Union{Tuple{T}, NTuple{5, T}} where T&lt;:Number"><code>SatelliteToolbox._dnet</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">_dnet(dd::T, dm::T, zhm::T, xmm::T, xm::T) where T&lt;:Number</code></pre><p>Turbopause correction for MSIS models.</p><p><strong>Args</strong></p><ul><li><code>dd</code>: Diffusive density.</li><li><code>dm</code>: Full mixed density.</li><li><code>zhm</code>: Transition scale length.</li><li><code>xmm</code>: Full mixed molecular weight.</li><li><code>xm</code>: Species molecular weight.</li></ul><p><strong>Returns</strong></p><p>The combined density.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaSpace/SatelliteToolbox.jl/blob/c7a891ae8cbd18d844cb2ba648927c3c6dfa564f/src/earth/atmospheric_models/nrlmsise00/nrlmsise00_priv.jl#L324-L341">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="SatelliteToolbox._get_degree_and_order-NTuple{4, Any}" href="#SatelliteToolbox._get_degree_and_order-NTuple{4, Any}"><code>SatelliteToolbox._get_degree_and_order</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">_get_degree_and_order(dP, P, n_max, m_max)</code></pre><p>Return the maximum degree and order to compute the Legendre associated functions given the matrices <code>dP</code>, <code>P</code>, and the configuration values <code>n_max</code> and <code>m_max</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaSpace/SatelliteToolbox.jl/blob/c7a891ae8cbd18d844cb2ba648927c3c6dfa564f/src/misc/dlegendre.jl#L527-L533">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="SatelliteToolbox._get_degree_and_order-Tuple{Any, Any, Any}" href="#SatelliteToolbox._get_degree_and_order-Tuple{Any, Any, Any}"><code>SatelliteToolbox._get_degree_and_order</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">_get_degree_and_order(P, n_max, m_max)</code></pre><p>Return the maximum degree and order to compute the Legendre associated functions given the matrix <code>P</code> and the configuration values <code>n_max</code> and <code>m_max</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaSpace/SatelliteToolbox.jl/blob/c7a891ae8cbd18d844cb2ba648927c3c6dfa564f/src/misc/legendre.jl#L504-L510">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="SatelliteToolbox._glob7s-Union{Tuple{T}, Tuple{AbstractVector{T}, NRLMSISE00_Structure{T}}} where T&lt;:Number" href="#SatelliteToolbox._glob7s-Union{Tuple{T}, Tuple{AbstractVector{T}, NRLMSISE00_Structure{T}}} where T&lt;:Number"><code>SatelliteToolbox._glob7s</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">_glob7s(p::AbstractVector{T}, nrlmsise00d::NRLMSISE00_Structure{T}) where T&lt;:Number</code></pre><p>Version of Globe for lower atmosphere (1999-10-26).</p><p><strong>Args</strong></p><ul><li><code>p</code>: Vector with the coefficients.</li><li><code>nrlmsise00d</code>: NRLMSISE-00 structure (see <code>NRLMSISE00_Structure</code>).</li></ul><p><strong>Returns</strong></p><p>The temperature (?).</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaSpace/SatelliteToolbox.jl/blob/c7a891ae8cbd18d844cb2ba648927c3c6dfa564f/src/earth/atmospheric_models/nrlmsise00/nrlmsise00_priv.jl#L596-L610">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="SatelliteToolbox._globe7!-Union{Tuple{T}, Tuple{AbstractVector{T}, NRLMSISE00_Structure{T}}} where T&lt;:Number" href="#SatelliteToolbox._globe7!-Union{Tuple{T}, Tuple{AbstractVector{T}, NRLMSISE00_Structure{T}}} where T&lt;:Number"><code>SatelliteToolbox._globe7!</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">_globe7!(p::AbstractVector{T}, nrlmsise00d::NRLMSISE00_Structure{T}) where T&lt;:Number</code></pre><p>Compute G(L) function.</p><p>Notice that the parameters <code>apt</code> and <code>apdf</code> of structure <code>nrlmsise00d</code> are modified.</p><p><strong>Args</strong></p><ul><li><code>p</code>: Vector with the coefficients.</li><li><code>nrlmsise00d</code>: NRLMSISE-00 structure (see <code>NRLMSISE00_Structure</code>).</li></ul><p><strong>Returns</strong></p><p>The temperature (?).</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaSpace/SatelliteToolbox.jl/blob/c7a891ae8cbd18d844cb2ba648927c3c6dfa564f/src/earth/atmospheric_models/nrlmsise00/nrlmsise00_priv.jl#L371-L388">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="SatelliteToolbox._init_dtcfile-Tuple{}" href="#SatelliteToolbox._init_dtcfile-Tuple{}"><code>SatelliteToolbox._init_dtcfile</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">_init_dctfile(;force_download = false, local_path = nothing)</code></pre><p>Initialize the data in the file <code>DTCFILE.TXT</code> by creating <code>_dtcfile_data</code>. The initialization process is composed of:</p><ol><li>Download the file, if it is necessary;</li><li>Parse the file;</li><li>Create the interpolations and the structures.</li></ol><p>If the keyword <code>force_download</code> is <code>true</code>, then the file will always be downloaded.</p><p>The user can also specify a location for the file using the keyword <code>local_path</code>. If it is <code>nothing</code>, which is the default, then the file will be downloaded.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaSpace/SatelliteToolbox.jl/blob/c7a891ae8cbd18d844cb2ba648927c3c6dfa564f/src/earth/space_indices/dtcfile.jl#L78-L95">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="SatelliteToolbox._init_fluxtable-Tuple{}" href="#SatelliteToolbox._init_fluxtable-Tuple{}"><code>SatelliteToolbox._init_fluxtable</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">_init_fluxtable(;force_download = false, local_path = nothing)</code></pre><p>Initialize the data in the file <code>fluxtable.txt</code> by creating <code>_fluxtable_data</code>. The initialization process is composed of:</p><ol><li>Download the file, if it is necessary;</li><li>Parse the file;</li><li>Create the interpolations and the structures.</li></ol><p>If the keyword <code>force_download</code> is <code>true</code>, then the file will always be downloaded.</p><p>The user can also specify a location for the file using the keyword <code>local_path</code>. If it is <code>nothing</code>, which is the default, then the file will be downloaded.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaSpace/SatelliteToolbox.jl/blob/c7a891ae8cbd18d844cb2ba648927c3c6dfa564f/src/earth/space_indices/fluxtable.jl#L35-L52">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="SatelliteToolbox._init_solfsmy-Tuple{}" href="#SatelliteToolbox._init_solfsmy-Tuple{}"><code>SatelliteToolbox._init_solfsmy</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">_init_solfsmy(;force_download = false, local_path = nothing)</code></pre><p>Initialize the data in the file <code>SOLFSMY.TXT</code> by creating <code>_solfsmy_data</code>. The initialization process is composed of:</p><ol><li>Download the file, if it is necessary;</li><li>Parse the file;</li><li>Create the interpolations and the structures.</li></ol><p>If the keyword <code>force_download</code> is <code>true</code>, then the file will always be downloaded.</p><p>The user can also specify a location for the file using the keyword <code>local_path</code>. If it is <code>nothing</code>, which is the default, then the file will be downloaded.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaSpace/SatelliteToolbox.jl/blob/c7a891ae8cbd18d844cb2ba648927c3c6dfa564f/src/earth/space_indices/solfsmy.jl#L96-L113">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="SatelliteToolbox._init_wdcfiles-Tuple{}" href="#SatelliteToolbox._init_wdcfiles-Tuple{}"><code>SatelliteToolbox._init_wdcfiles</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">_init_wdcfiles(;force_download = false, local_dir = nothing, wdcfiles_oldest_year = year(now())-3)</code></pre><p>Initialize the data in the WDC files by creating <code>_wdcfiles_data</code>. The initialization process is composed of:</p><ol><li>Download the files, if it is necessary;</li><li>Parse the files;</li><li>Create the interpolations and the structures.</li></ol><p>If the keyword <code>force_download</code> is <code>true</code>, then the files will always be downloaded.</p><p>The user can also specify a location for the directory with the WDC files using the keyword <code>local_dir</code>. If it is <code>nothing</code>, which is the default, then the file will be downloaded.</p><p>The user can select what is the oldest year in which the data will be downloaded by the keyword <code>wdcfiles_oldest_year</code>. By default, it will download the data from 3 previous years.</p><p>The user can select what is the newest year in which the data will be downloaded by the keyword <code>wdcfiles_newest_year</code>. It it is <code>nothing</code>, which is the default, then it is set to the current year.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaSpace/SatelliteToolbox.jl/blob/c7a891ae8cbd18d844cb2ba648927c3c6dfa564f/src/earth/space_indices/wdcfiles.jl#L126-L151">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="SatelliteToolbox._jb2008_M-Tuple{R} where R" href="#SatelliteToolbox._jb2008_M-Tuple{R} where R"><code>SatelliteToolbox._jb2008_M</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">_jb2008_M(z::R) where R</code></pre><p>Compute the mean molecular mass at altitude <code>z</code> [km] using the empirical profile in eq. 1 [3].</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaSpace/SatelliteToolbox.jl/blob/c7a891ae8cbd18d844cb2ba648927c3c6dfa564f/src/earth/atmospheric_models/jb2008/jb2008_priv.jl#L186-L192">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="SatelliteToolbox._jb2008_T-Union{Tuple{R}, Tuple{R, R, R}} where R&lt;:Number" href="#SatelliteToolbox._jb2008_T-Union{Tuple{R}, Tuple{R, R, R}} where R&lt;:Number"><code>SatelliteToolbox._jb2008_T</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">_jb2008_T(z::R, Tx::R, T∞::R) where R&lt;:Number</code></pre><p>Compute the temperature [K] at height <code>z</code> [km] given the temperature <code>Tx</code> [K] at the inflection point, and the exospheric temperature <code>T∞</code> [K] according to the theory of the model Jacchia 1971 [3].</p><p>The inflection point is considered to by <code>z = 125 km</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaSpace/SatelliteToolbox.jl/blob/c7a891ae8cbd18d844cb2ba648927c3c6dfa564f/src/earth/atmospheric_models/jb2008/jb2008_priv.jl#L262-L271">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="SatelliteToolbox._jb2008_grav-Tuple{R} where R" href="#SatelliteToolbox._jb2008_grav-Tuple{R} where R"><code>SatelliteToolbox._jb2008_grav</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">_jb2008_grav(z::R) where R</code></pre><p>Compute the gravity [m/s] at altitude <code>z</code> [km] according to the model Jacchia 1971 [3].</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaSpace/SatelliteToolbox.jl/blob/c7a891ae8cbd18d844cb2ba648927c3c6dfa564f/src/earth/atmospheric_models/jb2008/jb2008_priv.jl#L70-L76">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="SatelliteToolbox._jb2008_highaltitude-Tuple{Number, Number}" href="#SatelliteToolbox._jb2008_highaltitude-Tuple{Number, Number}"><code>SatelliteToolbox._jb2008_highaltitude</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">_jb2008_highaltitude(h::Number, F10ₐ::Number)</code></pre><p>Compute the high altitude exospheric density correction factor in altitude <code>h</code> [km] and the averaged 10.7-cm solar flux (81-day centered on input time) [10⁻²² W/(M² Hz)].</p><p>This function uses the model in Section 6.2 of [2].</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaSpace/SatelliteToolbox.jl/blob/c7a891ae8cbd18d844cb2ba648927c3c6dfa564f/src/earth/atmospheric_models/jb2008/jb2008_priv.jl#L88-L97">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="SatelliteToolbox._jb2008_int-Tuple{Number, Number, Number, Number, Number, Function}" href="#SatelliteToolbox._jb2008_int-Tuple{Number, Number, Number, Number, Number, Function}"><code>SatelliteToolbox._jb2008_int</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">_jb2008_int(z₀::Number, z₁::Number, R::Number, Tx::Number, T∞::Number, δf::Function)</code></pre><p>Compute the integral of the function <code>δf</code> between <code>z₀</code> and <code>z₁</code> using the Newton-Cotes 4th degree method. <code>R</code> is a number that defines the step size, <code>Tx</code> is the temperature at the inflection point, and <code>T∞</code> is the exospheric temperature.</p><p>The signature of the function <code>δf</code> is:</p><pre><code class="language-none">δf(z, Tx, T∞)</code></pre><p>and it must be <code>_jb2008_δf1</code> or <code>_jb2008_δf2</code>.</p><p>This function returns a tuple containing the integral and last value of <code>z</code> used in the numerical algorithm.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaSpace/SatelliteToolbox.jl/blob/c7a891ae8cbd18d844cb2ba648927c3c6dfa564f/src/earth/atmospheric_models/jb2008/jb2008_priv.jl#L127-L144">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="SatelliteToolbox._jb2008_semiannual-NTuple{5, Number}" href="#SatelliteToolbox._jb2008_semiannual-NTuple{5, Number}"><code>SatelliteToolbox._jb2008_semiannual</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">_jb2008_semiannual(doy::Number, h::Number, F10ₐ::Number, S10ₐ::Number, M10ₐ::Number)</code></pre><p>Compute the semiannual variation of the density considering the JB2008 model [1].</p><p><strong>Args</strong></p><ul><li><code>doy</code>: Day of the year + fraction of the day.</li><li><code>h</code>: Height [km].</li><li><code>F10ₐ</code>: Averaged 10.7-cm flux (81-day centered on input-time)         [10⁻²² W/(M² Hz)].</li><li><code>S10ₐ</code>: EUV 81-day averaged centered index.</li><li><code>M10ₐ</code>: MG2 81-day averaged centered index.</li></ul><p><strong>Returns</strong></p><ul><li>Semiannual F(z) heigh function.</li><li>Semiannual G(t) yearly periodic function.</li><li>Semiannual variation of the density <code>Δsalog₁₀ρ</code>.</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaSpace/SatelliteToolbox.jl/blob/c7a891ae8cbd18d844cb2ba648927c3c6dfa564f/src/earth/atmospheric_models/jb2008/jb2008_priv.jl#L205-L226">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="SatelliteToolbox._jb2008_ΔTc-NTuple{4, Number}" href="#SatelliteToolbox._jb2008_ΔTc-NTuple{4, Number}"><code>SatelliteToolbox._jb2008_ΔTc</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">_jb2008_ΔTc(F10::Number, lst::Number, glat::Number, h::Number)</code></pre><p>Compute the correction in the <code>Tc</code> for Jacchia-Bowman model.</p><p>This correction is mention in [2]. However, the equations do not seem to match those in the source-code. The ones implemented here are exactly the same as in the source-code.</p><p><strong>Args</strong></p><ul><li><code>F10</code>: F10.7 flux.</li><li><code>lst</code>: Local solar time (0 - 24) [hr].</li><li><code>glat</code>: Geocentric latitude [rad].</li><li><code>h</code>: Altitude [km].</li></ul><p><strong>Returns</strong></p><p>The correction <code>ΔTc</code> [K].</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaSpace/SatelliteToolbox.jl/blob/c7a891ae8cbd18d844cb2ba648927c3c6dfa564f/src/earth/atmospheric_models/jb2008/jb2008_priv.jl#L308-L328">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="SatelliteToolbox._jb2008_δf1-Tuple{Any, Any, Any}" href="#SatelliteToolbox._jb2008_δf1-Tuple{Any, Any, Any}"><code>SatelliteToolbox._jb2008_δf1</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">_jb2008_δf1(z, Tx, T∞)</code></pre><p>Auxiliary function to compute the integrand in <code>_jb2008_int</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaSpace/SatelliteToolbox.jl/blob/c7a891ae8cbd18d844cb2ba648927c3c6dfa564f/src/earth/atmospheric_models/jb2008/jb2008_priv.jl#L425-L430">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="SatelliteToolbox._jb2008_δf2-Tuple{Any, Any, Any}" href="#SatelliteToolbox._jb2008_δf2-Tuple{Any, Any, Any}"><code>SatelliteToolbox._jb2008_δf2</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">_jb2008_δf2(z, Tx, T∞)</code></pre><p>Auxiliary function to compute the integrand in <code>_jb2008_int</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaSpace/SatelliteToolbox.jl/blob/c7a891ae8cbd18d844cb2ba648927c3c6dfa564f/src/earth/atmospheric_models/jb2008/jb2008_priv.jl#L438-L443">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="SatelliteToolbox._jr1971_M-Tuple{R} where R" href="#SatelliteToolbox._jr1971_M-Tuple{R} where R"><code>SatelliteToolbox._jr1971_M</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">_jr1971_M(z::R) where R</code></pre><p>Compute the mean molecular mass at altitude <code>z</code> [km] using the empirical profile in eq. 1 [3,4].</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaSpace/SatelliteToolbox.jl/blob/c7a891ae8cbd18d844cb2ba648927c3c6dfa564f/src/earth/atmospheric_models/jr1971/jr1971_priv.jl#L216-L222">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="SatelliteToolbox._jr1971_T-Union{Tuple{R}, Tuple{R, R, R}} where R&lt;:Number" href="#SatelliteToolbox._jr1971_T-Union{Tuple{R}, Tuple{R, R, R}} where R&lt;:Number"><code>SatelliteToolbox._jr1971_T</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">_jr1971_T(z::R, Tx::R, T∞::R) where R&lt;:Number</code></pre><p>Compute the temperature [K] at height <code>z</code> [km] given the temperature <code>Tx</code> [K] at the inflection point, and the exospheric temperature <code>T∞</code> [K] according to the theory of the model Jacchia-Roberts 1971 [1,3,4].</p><p>The inflection point is considered to by <code>z = 125 km</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaSpace/SatelliteToolbox.jl/blob/c7a891ae8cbd18d844cb2ba648927c3c6dfa564f/src/earth/atmospheric_models/jr1971/jr1971_priv.jl#L264-L273">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="SatelliteToolbox._jr1971_roots-Union{Tuple{Vector{R}}, Tuple{R}} where R" href="#SatelliteToolbox._jr1971_roots-Union{Tuple{Vector{R}}, Tuple{R}} where R"><code>SatelliteToolbox._jr1971_roots</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">_jr1971_roots(p::Polynomial{R}) where R</code></pre><p>Compute the roots of the polynomial <code>p</code> necessary to compute the density below 125 km. It returns the value <code>r₁</code>, <code>r₂</code>, <code>x</code>, and <code>y</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaSpace/SatelliteToolbox.jl/blob/c7a891ae8cbd18d844cb2ba648927c3c6dfa564f/src/earth/atmospheric_models/jr1971/jr1971_priv.jl#L229-L235">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="SatelliteToolbox._parse_dtcfile-Tuple{AbstractString}" href="#SatelliteToolbox._parse_dtcfile-Tuple{AbstractString}"><code>SatelliteToolbox._parse_dtcfile</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">_parse_dtcfile(path::AbstractString)</code></pre><p>Parse the <code>DTCFILE.TXT</code> file in <code>path</code> and return an instance of the structure <code>_DTCFILE_Structure</code> with the initialized interpolations.</p><p>The format of the file <code>DTCFILE.TXT</code> must be:</p><pre><code class="language-none">DTC YYYY DOY DTC_0h DTC_1h DTC_2h ... DTC_22h DTC_23h</code></pre><p>in which <code>DOY</code> is the day of the year and <code>DTC_Xh</code> is the <code>ΔTc</code> at hour <code>X</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaSpace/SatelliteToolbox.jl/blob/c7a891ae8cbd18d844cb2ba648927c3c6dfa564f/src/earth/space_indices/dtcfile.jl#L108-L120">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="SatelliteToolbox._parse_fluxtable-Tuple{AbstractString}" href="#SatelliteToolbox._parse_fluxtable-Tuple{AbstractString}"><code>SatelliteToolbox._parse_fluxtable</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">_parse_fluxtable(path::AbstractString)</code></pre><p>Parse the <code>fluxtable.txt</code> file in <code>path</code> and return an instance of the structure <code>_fluxtable_Structure</code> with the initialize interpolations.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaSpace/SatelliteToolbox.jl/blob/c7a891ae8cbd18d844cb2ba648927c3c6dfa564f/src/earth/space_indices/fluxtable.jl#L65-L71">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="SatelliteToolbox._parse_solfsmy-Tuple{AbstractString}" href="#SatelliteToolbox._parse_solfsmy-Tuple{AbstractString}"><code>SatelliteToolbox._parse_solfsmy</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">_parse_solfsmy(path::AbstractString)</code></pre><p>Parse the <code>SOLFSMY.TXT</code> file in <code>path</code> and retur an instance of the structure <code>_SOLFSMY_Structure</code> with the initialized interpolations.</p><p>The format of the file <code>SOLFSMY.TXT</code> must be:</p><pre><code class="language-none">YYYY DDD   JulianDay  F10   F81c  S10   S81c  M10   M81c  Y10   Y81c  Ssrc</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaSpace/SatelliteToolbox.jl/blob/c7a891ae8cbd18d844cb2ba648927c3c6dfa564f/src/earth/space_indices/solfsmy.jl#L126-L136">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="SatelliteToolbox._parse_wdcfiles-Tuple{Vector{String}, Vector{Int64}}" href="#SatelliteToolbox._parse_wdcfiles-Tuple{Vector{String}, Vector{Int64}}"><code>SatelliteToolbox._parse_wdcfiles</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">_parse_wdcfiles(filepaths::Vector{String}, years::Vector{Int})</code></pre><p>Parse the WDC files with paths in <code>filepaths</code> related to the years in <code>years</code>.</p><p><strong>Notice that the files must be sorted by the year!</strong></p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaSpace/SatelliteToolbox.jl/blob/c7a891ae8cbd18d844cb2ba648927c3c6dfa564f/src/earth/space_indices/wdcfiles.jl#L217-L224">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="SatelliteToolbox._prepare_wdc_remote_files-Tuple{Number, Number}" href="#SatelliteToolbox._prepare_wdc_remote_files-Tuple{Number, Number}"><code>SatelliteToolbox._prepare_wdc_remote_files</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">_prepare_wdc_remote_files(oldest_year::Number, newest_year::Number)</code></pre><p>Configure all the WDC remote files between <code>newest_year</code> and <code>oldest_year</code>. Notice that previous years will never be updated whereas the current year will be updated daily.</p><p>If <code>oldest_year</code> is greater than current year, then only the files from the current year will be downloaded.</p><p>If <code>newest_year</code> is smaller than <code>oldest_year</code>, then only the files from the <code>oldest_year</code> will be downloaded.</p><p>This function modifies the global variable <code>_wdcfiles</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaSpace/SatelliteToolbox.jl/blob/c7a891ae8cbd18d844cb2ba648927c3c6dfa564f/src/earth/space_indices/wdcfiles.jl#L272-L287">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="SatelliteToolbox._spline-Union{Tuple{N}, Tuple{T}, Tuple{StaticArrays.StaticVector{N, T}, StaticArrays.StaticVector{N, T}, T, T}} where {T&lt;:Number, N}" href="#SatelliteToolbox._spline-Union{Tuple{N}, Tuple{T}, Tuple{StaticArrays.StaticVector{N, T}, StaticArrays.StaticVector{N, T}, T, T}} where {T&lt;:Number, N}"><code>SatelliteToolbox._spline</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">_spline(x::StaticVector{N,T}, y::StaticVector{N,T}, yp1::T, ypn::T) where {T&lt;:Number,N}</code></pre><p>Compute the 2nd derivatives of cubic spline interpolation function tabulated by <code>x</code> and <code>y</code> given the 2nd derivatives values at <code>x[1]</code> (<code>yp1</code>) and at <code>x[N]</code> (<code>ypn</code>).</p><p>This function was adapted from Numerical Recipes.</p><p><strong>Args</strong></p><ul><li><code>x</code>: X components of the tabulated function in ascending order.</li><li><code>y</code>: Y components of the tabulated function evaluated at <code>x</code>.</li><li><code>yp1</code>: 2nd derivative value at <code>x[1]</code>.</li><li><code>ypn</code>: 2nd derivative value at <code>x[N]</code>.</li></ul><p><strong>Returns</strong></p><p>The 2nd derivative of cubic spline interpolation function evaluated at <code>x</code>.</p><p><strong>Remarks</strong></p><p>Values higher than <code>1e30</code> in the 2nd derivatives at the borders (<code>yp1</code> and <code>ypn</code>) are interpreted as <code>0</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaSpace/SatelliteToolbox.jl/blob/c7a891ae8cbd18d844cb2ba648927c3c6dfa564f/src/earth/atmospheric_models/nrlmsise00/nrlmsise00_priv.jl#L1255-L1280">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="SatelliteToolbox._splini-Union{Tuple{N}, Tuple{T}, Tuple{StaticArrays.StaticVector{N, T}, StaticArrays.StaticVector{N, T}, StaticArrays.StaticVector{N, T}, T}} where {T&lt;:Number, N}" href="#SatelliteToolbox._splini-Union{Tuple{N}, Tuple{T}, Tuple{StaticArrays.StaticVector{N, T}, StaticArrays.StaticVector{N, T}, StaticArrays.StaticVector{N, T}, T}} where {T&lt;:Number, N}"><code>SatelliteToolbox._splini</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">_splini(xa::StaticVector{N,T}, ya::StaticVector{N,T}, y2a::StaticVector{N,T}, x::T) where {T&lt;:Number,N}</code></pre><p>Compute the integral of the cubic spline function from <code>xa[1]</code> to <code>x</code>.</p><p><strong>Args</strong></p><ul><li><code>xa</code>: X components of the tabulated function in ascending order.</li><li><code>ya</code>: Y components of the tabulated function evaluated at <code>xa</code>.</li><li><code>y2a</code>: Second derivatives.</li><li><code>x</code>: Abscissa endpoint for integration.</li></ul><p><strong>Returns</strong></p><p>The integral of cubic spline function from <code>xa[1]</code> to <code>x</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaSpace/SatelliteToolbox.jl/blob/c7a891ae8cbd18d844cb2ba648927c3c6dfa564f/src/earth/atmospheric_models/nrlmsise00/nrlmsise00_priv.jl#L1202-L1218">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="SatelliteToolbox._splint-Union{Tuple{N}, Tuple{T}, Tuple{StaticArrays.StaticVector{N, T}, StaticArrays.StaticVector{N, T}, StaticArrays.StaticVector{N, T}, T}} where {T&lt;:Number, N}" href="#SatelliteToolbox._splint-Union{Tuple{N}, Tuple{T}, Tuple{StaticArrays.StaticVector{N, T}, StaticArrays.StaticVector{N, T}, StaticArrays.StaticVector{N, T}, T}} where {T&lt;:Number, N}"><code>SatelliteToolbox._splint</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">_splint(xa::StaticVector{N,T}, ya::StaticVector{N,T}, y2a::StaticVector{N,T}, x::T) where {T&lt;:Number,N}</code></pre><p>Compute the cubic spline interpolation value at <code>x</code>.</p><p>This function was adapted from Numerical Recipes.</p><p><strong>Args</strong></p><ul><li><code>xa</code>: X components of the tabulated function in ascending order.</li><li><code>ya</code>: Y components of the tabulated function evaluated at <code>xa</code>.</li><li><code>y2a</code>: Second derivatives.</li><li><code>x</code>: Abscissa endpoint for interpolation.</li></ul><p><strong>Returns</strong></p><p>The cubic spline interpolation value at <code>x</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaSpace/SatelliteToolbox.jl/blob/c7a891ae8cbd18d844cb2ba648927c3c6dfa564f/src/earth/atmospheric_models/nrlmsise00/nrlmsise00_priv.jl#L1323-L1341">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="SatelliteToolbox.adjacent_track_angle_grss-Tuple{Number, Number, Number, Int64, Number}" href="#SatelliteToolbox.adjacent_track_angle_grss-Tuple{Number, Number, Number, Int64, Number}"><code>SatelliteToolbox.adjacent_track_angle_grss</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">adjacent_track_angle_grss(h::Number, T::Number, i::Number, To::Int, lat::Number)</code></pre><p>Compute the angle between two adjacent ground tracks [rad] in a given latitude <code>lat</code> [rad] measured from the satellite position for a ground repeating, Sun-synchronous orbit with altitude in the Equator <code>h</code> [m], period <code>T</code> [s], inclination <code>i</code> [rad], and orbit cycle <code>To</code> [days].</p><p><strong>Remarks</strong></p><p>The functions <strong>does not</strong> check if the orbit is a GRSS orbit.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaSpace/SatelliteToolbox.jl/blob/c7a891ae8cbd18d844cb2ba648927c3c6dfa564f/src/orbit/orbit_sun_sync_ground_reap.jl#L58-L70">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="SatelliteToolbox.adjacent_track_angle_grss-Tuple{Number, Number, Number, Number, Int64, Number}" href="#SatelliteToolbox.adjacent_track_angle_grss-Tuple{Number, Number, Number, Number, Int64, Number}"><code>SatelliteToolbox.adjacent_track_angle_grss</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">adjacent_track_angle_grss(h::Number, a::Number, e::Number, i::Number, To::Int, lat::Number)</code></pre><p>Compute the angle between two adjacent ground tracks [rad] in a given latitude <code>lat</code> [rad] measured from the satellite position for a ground repeating, Sun-synchronous orbit with altitude in the Equator <code>h</code> [m], semi-major axis <code>a</code> [m], eccentricity <code>e</code>, inclination <code>i</code> [rad], and orbit cycle <code>To</code> [days].</p><p><strong>Remarks</strong></p><p>The functions <em>does not</em> check if the orbit is a GRSS orbit.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaSpace/SatelliteToolbox.jl/blob/c7a891ae8cbd18d844cb2ba648927c3c6dfa564f/src/orbit/orbit_sun_sync_ground_reap.jl#L87-L99">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="SatelliteToolbox.adjacent_track_distance_grss-Tuple{Number, Number, Int64, Number}" href="#SatelliteToolbox.adjacent_track_distance_grss-Tuple{Number, Number, Int64, Number}"><code>SatelliteToolbox.adjacent_track_distance_grss</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">adjacent_track_distance_grss(T::Number, i::Number, To::Int, lat::Number)</code></pre><p>Compute the distance between adjacent ground tracks [m] at a given latitude <code>lat</code> [rad] for a ground repeating, Sun-synchronous orbit with period <code>T</code> [s], inclination <code>i</code> [rad], and orbit cycle <code>To</code> [days].</p><p><strong>Remarks</strong></p><p>The functions <strong>does not</strong> check if the orbit is a GRSS orbit.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaSpace/SatelliteToolbox.jl/blob/c7a891ae8cbd18d844cb2ba648927c3c6dfa564f/src/orbit/orbit_sun_sync_ground_reap.jl#L14-L25">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="SatelliteToolbox.adjacent_track_distance_grss-Tuple{Number, Number, Number, Int64, Number}" href="#SatelliteToolbox.adjacent_track_distance_grss-Tuple{Number, Number, Number, Int64, Number}"><code>SatelliteToolbox.adjacent_track_distance_grss</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">adjacent_track_distance_grss(a::Number, e::Number, i::Number, To::Int, lat::Number)</code></pre><p>Compute the distance between adjacent ground tracks [m] at a given latitude <code>lat</code> [rad] for a ground repeating, Sun-synchronous orbit with semi-major axis <code>a</code> [m], eccentricity <code>e</code>, inclination <code>i</code> [rad], and orbit cycle <code>To</code> [days].</p><p><strong>Remarks</strong></p><p>The functions <em>does not</em> check if the orbit is a GRSS orbit.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaSpace/SatelliteToolbox.jl/blob/c7a891ae8cbd18d844cb2ba648927c3c6dfa564f/src/orbit/orbit_sun_sync_ground_reap.jl#L37-L48">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="SatelliteToolbox.angvel" href="#SatelliteToolbox.angvel"><code>SatelliteToolbox.angvel</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">angvel(a::Number, e::Number, i::Number, pert::Symbol = :J2)
angvel(orb::Orbit, pert::Symbol = :J2)</code></pre><p>Compute the angular velocity [rad/s] of an object in an orbit with semi-major axis <code>a</code> [m], eccentricity <code>e</code>, and inclination <code>i</code> [rad], using the perturbation terms specified by the symbol <code>pert</code>. The orbit can also be specified by <code>orb</code> (see <a href="#SatelliteToolbox.Orbit"><code>Orbit</code></a>).</p><p><code>pert</code> can be:</p><ul><li><code>:J0</code>: Consider a Keplerian orbit.</li><li><code>:J2</code>: Consider the perturbation terms up to J2.</li><li><code>:J4</code>: Consider the perturbation terms J2, J4, and J2².</li></ul><p>If <code>pert</code> is omitted, then it defaults to <code>:J2</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaSpace/SatelliteToolbox.jl/blob/c7a891ae8cbd18d844cb2ba648927c3c6dfa564f/src/orbit/general.jl#L49-L66">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="SatelliteToolbox.angvel_to_a" href="#SatelliteToolbox.angvel_to_a"><code>SatelliteToolbox.angvel_to_a</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">angvel_to_a(n::Number, e::Number, i::Number, pert::Symbol = :J2; μ::Number = m0, max_iter::Int = 20, tol::Number = 1e-10)</code></pre><p>Compute the semi-major axis that will provide an angular velocity <code>n</code> [rad/s] in an orbit with eccentricity <code>e</code> and inclination <code>i</code> [rad], using the perturbation terms specified by the symbol <code>pert</code>.</p><p>Notice that the angular velocity <code>n</code> is related to the nodal period, <em>i.e.</em> the time between two consecutive passages by the ascending node.</p><p><code>pert</code> can be:</p><ul><li><code>:J0</code>: Consider a Keplerian orbit.</li><li><code>:J2</code>: Consider the perturbation terms up to J2.</li><li><code>:J4</code>: Consider the perturbation terms J2, J4, and J2².</li></ul><p>If <code>pert</code> is omitted, then it defaults to <code>:J2</code>.</p><p><strong>Keyword</strong></p><ul><li><code>μ</code>: Standard gravitational parameter for Earth [m^3/s^2].      (<strong>Default</strong> = <code>m0</code>)</li><li><code>max_iter</code>: Maximum number of iterations allowed in the Newton-Raphson             algorithm. (<strong>Default</strong> = 20)</li><li><code>tol</code>: Tolerance to stop the Newton-Raphson algorithm. (<strong>Default</strong> = 1e-10)</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaSpace/SatelliteToolbox.jl/blob/c7a891ae8cbd18d844cb2ba648927c3c6dfa564f/src/orbit/general.jl#L127-L153">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="SatelliteToolbox.beta_angle" href="#SatelliteToolbox.beta_angle"><code>SatelliteToolbox.beta_angle</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">beta_angle(JD₀::Number, a::Number, e::Number, i::Number, RAAN::Number, Δt::Integer, pert::Symbol = :J2)</code></pre><p>Compute the beta angle of an orbit with semi-major axis <code>a</code> [m], eccentricity <code>e</code>, inclination <code>i</code> [rad], and initial right ascension of the ascending node <code>RAAN</code> [rad]. The orbit epoch, which is also the day in which the analysis will begin, is <code>JD₀</code> [Julian Day]. The analysis will be performed for each day during <code>Δt</code> days.</p><p>The argument <code>pert</code> can be used to select the perturbation terms that must be used when propagating the right ascencion of the ascending node. The possible values are:</p><ul><li><code>:J0</code>: Consider a Keplerian orbit.</li><li><code>:J2</code>: Consider the perturbation terms up to J2.</li><li><code>:J4</code>: Consider the perturbation terms J2, J4, and J2².</li></ul><p>If <code>pert</code> is omitted, then it defaults to <code>:J2</code>.</p><p><strong>Returns</strong></p><p>An array with two columns. The first one contains the days of the analysis and the second one contains the beta angle [rad] for each day.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaSpace/SatelliteToolbox.jl/blob/c7a891ae8cbd18d844cb2ba648927c3c6dfa564f/src/analysis/beta_angle.jl#L16-L40">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="SatelliteToolbox.change_oe_frame-Tuple{Number, Number, Number, Number, Number, Number, Vararg{Any, N} where N}" href="#SatelliteToolbox.change_oe_frame-Tuple{Number, Number, Number, Number, Number, Number, Vararg{Any, N} where N}"><code>SatelliteToolbox.change_oe_frame</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">change_oe_frame(a::Number, e::Number, i::Number, Ω::Number, ω::Number, f::Number, conv_args...)
change_oe_frame(oe::Orbit, conv_args...)</code></pre><p>Change the reference frame of orbit elements. The orbit elements can be specified by <code>a</code>, <code>e</code>, <code>i</code>, <code>Ω</code>, <code>ω</code>, and <code>f</code>, or the structure <code>oe</code> (see <a href="#SatelliteToolbox.Orbit"><code>Orbit</code></a>). In the latter, the return value type will match the type of <code>oe</code>.</p><p>The conversion arguments <code>conv_args</code> are <strong>the same</strong> arguments that one should pass to the function <code>r_eci_to_eci</code> to convert between the desired frames. For more information, see the documentation of the function <code>r_eci_to_eci</code>.</p><p><strong>Args</strong></p><ul><li><p><code>a</code>: Semi-major axis [m].</p></li><li><p><code>e</code>: Excentricity.</p></li><li><p><code>i</code>: Inclination [rad].</p></li><li><p><code>Ω</code>: Right-ascension of the ascending node [rad].</p></li><li><p><code>ω</code>: Argument of perigee [rad].</p></li><li><p><code>f</code>: True anomaly [rad].</p></li><li><p><code>conv_args...</code>: Conversion arguments, which are the same arguments that one                 would pass to the function <code>r_eci_to_eci</code> to convert between the                 desired frames.</p></li><li><p><code>oe</code>: An instance of the structure <a href="#SatelliteToolbox.Orbit"><code>Orbit</code></a> with the orbit elements       that will be converted [SI units].</p></li></ul><p><strong>Returns</strong></p><p>Using the first signature, this function returns an instance of <a href="#SatelliteToolbox.KeplerianElements"><code>KeplerianElements</code></a>. If the second signature is used, then the function return an element with the same type of the input.</p><p><strong>Examples</strong></p><pre><code class="language-julia-repl">julia&gt; eop = get_iers_eop(:IAU1980);

julia&gt; teme_epoch = date_to_jd(2016,6,1,11,0,0);

julia&gt; tod_epoch  = date_to_jd(2016,1,1,0,0,0);

julia&gt; k_teme     = KeplerianElements(teme_epoch,
                                      7130.982e3,
                                      0.001111,
                                      98.405*pi/180,
                                      227.336*pi/180,
                                      90*pi/180,
                                      320*pi/180)
KeplerianElements{Float64}:
           Epoch :    2.45754e6 (2016-06-01T11:00:00)
 Semi-major axis : 7130.98     km
    Eccentricity :    0.001111
     Inclination :   98.405    °
            RAAN :  227.336    °
 Arg. of Perigee :   90.0      °
    True Anomaly :  320.0      °

julia&gt; k_j2000 = change_oe_frame(k_teme, TEME(), J2000(), teme_epoch, eop)
KeplerianElements{Float64}:
           Epoch :    2.45754e6 (2016-06-01T11:00:00)
 Semi-major axis : 7130.98     km
    Eccentricity :    0.001111
     Inclination :   98.3365   °
            RAAN :  227.134    °
 Arg. of Perigee :   90.0604   °
    True Anomaly :  320.0      °

julia&gt; k_tod = change_oe_frame(k_teme, TEME(), teme_epoch, TOD(), tod_epoch, eop)
KeplerianElements{Float64}:
           Epoch :    2.45754e6 (2016-06-01T11:00:00)
 Semi-major axis : 7130.98     km
    Eccentricity :    0.001111
     Inclination :   98.4037   °
            RAAN :  227.331    °
 Arg. of Perigee :   90.0014   °
    True Anomaly :  320.0      °</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaSpace/SatelliteToolbox.jl/blob/c7a891ae8cbd18d844cb2ba648927c3c6dfa564f/src/transformations/orbit_elements.jl#L29-L107">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="SatelliteToolbox.cio_iau2006-Tuple{Number}" href="#SatelliteToolbox.cio_iau2006-Tuple{Number}"><code>SatelliteToolbox.cio_iau2006</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">cio_iau2006(JD_TT::Number)</code></pre><p>Compute the coordinates <code>X</code> and <code>Y</code> of the Celestial Intermediate Pole (CIP) with respect to the Geocentric Celestial Reference Frame (GCRF), and the CIO locator <code>s</code>. The algorithm is based on the IAU-2006 theory.</p><p>The CIO locator <code>s</code> provides the position of the CIO on the Equator of the CIP corresponding to the kinematical definition of the non-rotation origin in the GCRS when the CIP is moving with respect to the GCRS between the reference epoch and the epoch due to precession and nutation [1, p. 214].</p><p><strong>Returns</strong></p><ul><li>The coordinate <code>X</code> of the CIP w.r.t. the GCRF.</li><li>The coordinate <code>Y</code> of the CIP w.r.t. the GCRF.</li><li>The CIO locator <code>s</code>.</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaSpace/SatelliteToolbox.jl/blob/c7a891ae8cbd18d844cb2ba648927c3c6dfa564f/src/transformations/iau2006/cio.jl#L23-L41">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="SatelliteToolbox.compute_RAAN_lt-Tuple{Number, Number}" href="#SatelliteToolbox.compute_RAAN_lt-Tuple{Number, Number}"><code>SatelliteToolbox.compute_RAAN_lt</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">compute_RAAN_lt(JD::Number, asc_node_lt::Number)</code></pre><p>Compute the RAAN (0,2π) [rad] so that the orbit plane local time is <code>asc_node_lt</code> [hour] at the Julian day <code>JD</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaSpace/SatelliteToolbox.jl/blob/c7a891ae8cbd18d844cb2ba648927c3c6dfa564f/src/analysis/raan.jl#L12-L18">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="SatelliteToolbox.compute_U-Union{Tuple{T}, Tuple{GravityModel_Coefs{T}, AbstractVector{T} where T}, Tuple{GravityModel_Coefs{T}, AbstractVector{T} where T, Number}, Tuple{GravityModel_Coefs{T}, AbstractVector{T} where T, Number, Number}} where T&lt;:Number" href="#SatelliteToolbox.compute_U-Union{Tuple{T}, Tuple{GravityModel_Coefs{T}, AbstractVector{T} where T}, Tuple{GravityModel_Coefs{T}, AbstractVector{T} where T, Number}, Tuple{GravityModel_Coefs{T}, AbstractVector{T} where T, Number, Number}} where T&lt;:Number"><code>SatelliteToolbox.compute_U</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">compute_U(gm_coefs::GravityModel_Coefs{T}, r::AbstractVector, n_max::Number = -1, m_max::Number = -1) where T&lt;:Number</code></pre><p>Compute the gravitational potential [J/kg] at <code>r</code> (ITRF) [m] using the coefficients <code>gm_coefs</code> (see <code>GravityModel_Coefs</code>). The maximum degree that will be used while computing the spherical harmonics will be <code>n_max</code> and the maximum order is <code>m_max</code>.</p><p>If <code>n_max</code> is negative, then the maximum available degree will be used. If <code>n_max</code> is omitted, then it defaults to 0.</p><p>If <code>m_max</code> is negative or if it is greater than <code>n_max</code>, then it will be set to <code>n_max</code>. If <code>m_max</code> is omitted, then it defaults to 0.</p><div class="admonition is-info"><header class="admonition-header">Info</header><div class="admonition-body"><p>By convention, the result with <code>n_max</code> 0 and 1 will be the same.</p></div></div></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaSpace/SatelliteToolbox.jl/blob/c7a891ae8cbd18d844cb2ba648927c3c6dfa564f/src/earth/gravity_models/gravity_model.jl#L247-L265">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="SatelliteToolbox.compute_dU-Union{Tuple{T}, Tuple{GravityModel_Coefs{T}, AbstractVector{T} where T}, Tuple{GravityModel_Coefs{T}, AbstractVector{T} where T, Number}, Tuple{GravityModel_Coefs{T}, AbstractVector{T} where T, Number, Number}} where T&lt;:Number" href="#SatelliteToolbox.compute_dU-Union{Tuple{T}, Tuple{GravityModel_Coefs{T}, AbstractVector{T} where T}, Tuple{GravityModel_Coefs{T}, AbstractVector{T} where T, Number}, Tuple{GravityModel_Coefs{T}, AbstractVector{T} where T, Number, Number}} where T&lt;:Number"><code>SatelliteToolbox.compute_dU</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">compute_dU(gm_coefs::GravityModel_Coefs{T}, r::AbstractVector, n_max::Number = -1, m_max::Number = -1) where T&lt;:Number</code></pre><p>Compute the derivatives w.r.t. the spherical coordinates of the gravitational field (<code>∂U/∂r</code>, <code>∂U/∂ϕ</code>, <code>∂U/∂λ</code>) defined by the coefficients <code>gm_coefs</code> (see <code>GravityModel_Coefs</code>) at the position <code>r</code> [m] in ITRF. The maximum degree that will be used while computing the spherical harmonics will be <code>n_max</code> and the maximum order is <code>m_max</code>.</p><p>If <code>n_max</code> is negative, then the maximum available degree will be used. If <code>n_max</code> is omitted, then it defaults to 0.</p><p>If <code>m_max</code> is negative or if it is greater than <code>n_max</code>, then it will be set to <code>n_max</code>. If <code>m_max</code> is omitted, then it defaults to 0.</p><div class="admonition is-info"><header class="admonition-header">Info</header><div class="admonition-body"><p>By convention, the result with <code>n_max</code> 0 and 1 will be the same.</p></div></div><p><strong>Returns</strong></p><ul><li>The derivative of the gravitational field w.r.t. the radius (<code>∂U/∂r</code>).</li><li>The derivative of the gravitational field w.r.t. the latitude (<code>∂U/∂ϕ</code>).</li><li>The derivative of the gravitational field w.r.t. the longitude (<code>∂U/∂λ</code>).</li></ul><p><strong>Remarks</strong></p><p>In this case, <code>ϕ</code> is the geocentric latitude and <code>λ</code> is the geocentric longitude.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaSpace/SatelliteToolbox.jl/blob/c7a891ae8cbd18d844cb2ba648927c3c6dfa564f/src/earth/gravity_models/gravity_model.jl#L48-L78">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="SatelliteToolbox.compute_g-Union{Tuple{T}, Tuple{GravityModel_Coefs{T}, AbstractVector{T} where T}, Tuple{GravityModel_Coefs{T}, AbstractVector{T} where T, Number}, Tuple{GravityModel_Coefs{T}, AbstractVector{T} where T, Number, Number}} where T&lt;:Number" href="#SatelliteToolbox.compute_g-Union{Tuple{T}, Tuple{GravityModel_Coefs{T}, AbstractVector{T} where T}, Tuple{GravityModel_Coefs{T}, AbstractVector{T} where T, Number}, Tuple{GravityModel_Coefs{T}, AbstractVector{T} where T, Number, Number}} where T&lt;:Number"><code>SatelliteToolbox.compute_g</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">compute_g(gm_coefs::GravityModel_Coefs{T}, r::AbstractVector, n_max::Number = -1, m_max::Number = -1) where T&lt;:Number</code></pre><p>Compute the gravitational acceleration (ITRF) [m/s²] at position <code>r</code> [m] (ITRF) using the coefficients <code>gm_coefs</code> (see <code>GravityModel_Coefs</code>). The maximum degree that will be used while computing the spherical harmonics will be <code>n_max</code> and the maximum order it <code>m_max</code>.</p><p>If <code>n_max</code> is negative, then the maximum available degree will be used. If <code>n_max</code> is omitted, then it defaults to 0.</p><p>If <code>m_max</code> is negative or if it is greater than <code>n_max</code>, then it will be set to <code>n_max</code>. If <code>m_max</code> is omitted, then it defaults to 0.</p><div class="admonition is-info"><header class="admonition-header">Info</header><div class="admonition-body"><p>By convention, the result with <code>n_max</code> 0 and 1 will be the same.</p></div></div><p><strong>Remarks</strong></p><p>Notice that this function computes the <strong>gravitational acceleration</strong>. Hence, the acceleration due to Earth rotation rate <strong>is not</strong> included.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaSpace/SatelliteToolbox.jl/blob/c7a891ae8cbd18d844cb2ba648927c3c6dfa564f/src/earth/gravity_models/gravity_model.jl#L182-L205">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="SatelliteToolbox.compute_ss_orbit_by_ang_vel-Tuple{Number, Number}" href="#SatelliteToolbox.compute_ss_orbit_by_ang_vel-Tuple{Number, Number}"><code>SatelliteToolbox.compute_ss_orbit_by_ang_vel</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">compute_ss_orbit_by_ang_vel(n::Number, e::Number)</code></pre><p>Compute the Sun-synchronous orbit given the angular velocity <code>n</code> [rad/s] and the eccentricity <code>e</code>.</p><p><strong>Returns</strong></p><ul><li>The semi-major axis [m].</li><li>The inclination [rad].</li><li>The residues of the two functions.</li><li>A boolean variable that indicates if the numerical algorithm converged.</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaSpace/SatelliteToolbox.jl/blob/c7a891ae8cbd18d844cb2ba648927c3c6dfa564f/src/orbit/orbit_sun_sync.jl#L13-L26">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="SatelliteToolbox.compute_ss_orbit_by_inclination-Tuple{Number, Number}" href="#SatelliteToolbox.compute_ss_orbit_by_inclination-Tuple{Number, Number}"><code>SatelliteToolbox.compute_ss_orbit_by_inclination</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">compute_ss_orbit_by_inclination(i::Number, e::Number)</code></pre><p>Compute the Sun-synchronous orbit given the inclination <code>i</code> [rad] and the eccentricity <code>e</code>.</p><p><strong>Returns</strong></p><p>The semi-major axis of the Sun-synchronous orbit [m].</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaSpace/SatelliteToolbox.jl/blob/c7a891ae8cbd18d844cb2ba648927c3c6dfa564f/src/orbit/orbit_sun_sync.jl#L115-L125">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="SatelliteToolbox.compute_ss_orbit_by_num_rev_per_day-Tuple{Number, Number}" href="#SatelliteToolbox.compute_ss_orbit_by_num_rev_per_day-Tuple{Number, Number}"><code>SatelliteToolbox.compute_ss_orbit_by_num_rev_per_day</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">compute_ss_orbit_by_num_rev_per_day(numRevPD::Number, e::Number)</code></pre><p>Compute the Sun-synchronous orbit given the number of revolutions per day <code>numRevPD</code> and the eccentricity <code>e</code>.</p><p><strong>Returns</strong></p><ul><li>The semi-major axis [m].</li><li>The inclination [rad].</li><li>The residues of the two functions.</li><li>A boolean variable that indicates if the numerical algorithm converged.</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaSpace/SatelliteToolbox.jl/blob/c7a891ae8cbd18d844cb2ba648927c3c6dfa564f/src/orbit/orbit_sun_sync_ground_reap.jl#L109-L122">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="SatelliteToolbox.compute_ss_orbit_by_semi_major_axis-Tuple{Number, Number}" href="#SatelliteToolbox.compute_ss_orbit_by_semi_major_axis-Tuple{Number, Number}"><code>SatelliteToolbox.compute_ss_orbit_by_semi_major_axis</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">compute_ss_orbit_by_semi_major_axis(a::Number, e::Number)</code></pre><p>Compute the Sun-synchronous orbit given the semi-major axis <code>a</code> [m] and the eccentricity <code>e</code>.</p><p><strong>Returns</strong></p><p>The inclination of the Sun-synchronous orbit [rad].</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaSpace/SatelliteToolbox.jl/blob/c7a891ae8cbd18d844cb2ba648927c3c6dfa564f/src/orbit/orbit_sun_sync.jl#L145-L155">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="SatelliteToolbox.conf_nrlmsise00" href="#SatelliteToolbox.conf_nrlmsise00"><code>SatelliteToolbox.conf_nrlmsise00</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">conf_nrlmsise00(year::Int, doy::Int, sec::Number, alt::Number, g_lat::Number, g_long::Number, lst::Number, f107A::Number, f107::Number, ap::[Number, AbstractVector], flags::NRLMSISE00_Flags = NRLMSISE00_Flags())</code></pre><p>Create the structure with the proper configuration to call the NRLMSISE-00 model.</p><p>Notice that the input variables have the same units of the original model.</p><p><strong>Args</strong></p><ul><li><code>year</code>: Year (currently ignored).</li><li><code>doy</code>: Day of year.</li><li><code>sec</code>: Seconds in day [UT].</li><li><code>alt</code>: Altitude [km].</li><li><code>g_lat</code>: Geodetic latitude [deg].</li><li><code>g_long</code>: Geodetic longitude [deg].</li><li><code>lst</code>: Local apparent solar time (hours).</li><li><code>f107A</code>: 81 day average of F10.7 flux (centered on day of year <code>doy</code>).</li><li><code>f107</code>: Daily F10.7 flux for previous day.</li><li><code>ap</code>: Magnetic index (daily) if it is a number. If it is an array, then see       <strong>Remarks</strong>.</li><li><code>flags</code>: (OPTIONAL) An instance of the structure <code>NRLMSISE00_Flags</code> with the           configuration flags for NRLMSISE00. If omitted, then the default           configurations will be used.</li></ul><p><strong>Returns</strong></p><p>An instance of the structure <code>NRLMSISE00_Structure</code>.</p><p><strong>Remarks</strong></p><p>If <code>ap</code> is a <code>Vector</code>, then it must be a vector with 7 dimensions as described below:</p><table><tr><th style="text-align: right">Index</th><th style="text-align: left">Description</th></tr><tr><td style="text-align: right">1</td><td style="text-align: left">Daily AP.</td></tr><tr><td style="text-align: right">2</td><td style="text-align: left">3 hour AP index for current time.</td></tr><tr><td style="text-align: right">3</td><td style="text-align: left">3 hour AP index for 3 hours before current time.</td></tr><tr><td style="text-align: right">4</td><td style="text-align: left">3 hour AP index for 6 hours before current time.</td></tr><tr><td style="text-align: right">5</td><td style="text-align: left">3 hour AP index for 9 hours before current time.</td></tr><tr><td style="text-align: right">6</td><td style="text-align: left">Average of eight 3 hour AP indices from 12 to 33 hours prior to current time.</td></tr><tr><td style="text-align: right">7</td><td style="text-align: left">Average of eight 3 hour AP indices from 36 to 57 hours prior to current time.</td></tr></table><p><strong>Notes on input variables</strong></p><p>UT, Local Time, and Longitude are used independently in the model and are not of equal importance for every situation. For the most physically realistic calculation these three variables should be consistent (<code>lst=sec/3600 + g_long/15</code>). The Equation of Time departures from the above formula for apparent local time can be included if available but are of minor importance.</p><p><code>f107</code> and <code>f107A</code> values used to generate the model correspond to the 10.7 cm radio flux at the actual distance of the Earth from the Sun rather than the radio flux at 1 AU. The following site provides both classes of values:</p><pre><code class="language-none">ftp://ftp.ngdc.noaa.gov/STP/SOLAR_DATA/SOLAR_RADIO/FLUX/</code></pre><p><code>f107</code>, <code>f107A</code>, and <code>ap</code> effects are neither large nor well established below 80 km and these parameters should be set to 150, 150, and 4 respectively.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaSpace/SatelliteToolbox.jl/blob/c7a891ae8cbd18d844cb2ba648927c3c6dfa564f/src/earth/atmospheric_models/nrlmsise00/nrlmsise00.jl#L211-L272">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="SatelliteToolbox.create_gravity_model_coefs-Tuple{ICGEM}" href="#SatelliteToolbox.create_gravity_model_coefs-Tuple{ICGEM}"><code>SatelliteToolbox.create_gravity_model_coefs</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">create_gravity_model_coefs(icgem::ICGEM)</code></pre><p>Return an instance of the structure <code>GravityModel_Coefs</code> based on the information obtained from an ICGEM file in <code>icgem</code> (see <code>parse_icgem</code>).</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaSpace/SatelliteToolbox.jl/blob/c7a891ae8cbd18d844cb2ba648927c3c6dfa564f/src/earth/gravity_models/gravity_model.jl#L26-L32">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="SatelliteToolbox.dargp" href="#SatelliteToolbox.dargp"><code>SatelliteToolbox.dargp</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">dargp(a::Number, e::Number, i::Number, pert::Symbol = :J2)
dargp(orb::Orbit, pert::Symbol = :J2)</code></pre><p>Compute the time-derivative of the argument of perigee [rad/s] of an orbit with semi-major axis <code>a</code> [m], eccentricity <code>e</code>, and inclination <code>i</code> [rad], using the perturbation terms specified by the symbol <code>pert</code>. The orbit can also be specified by <code>orb</code> (see <a href="#SatelliteToolbox.Orbit"><code>Orbit</code></a>).</p><p><code>pert</code> can be:</p><ul><li><code>:J0</code>: Consider a Keplerian orbit.</li><li><code>:J2</code>: Consider the perturbation terms up to J2.</li><li><code>:J4</code>: Consider the perturbation terms J2, J4, and J2².</li></ul><p>If <code>pert</code> is omitted, then it defaults to <code>:J2</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaSpace/SatelliteToolbox.jl/blob/c7a891ae8cbd18d844cb2ba648927c3c6dfa564f/src/orbit/general.jl#L288-L305">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="SatelliteToolbox.date_to_jd-Tuple{Dates.DateTime}" href="#SatelliteToolbox.date_to_jd-Tuple{Dates.DateTime}"><code>SatelliteToolbox.date_to_jd</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">date_to_jd(dateTime::DateTime)</code></pre><p>Convert the date and time <code>dateTime</code> to Julian Day.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaSpace/SatelliteToolbox.jl/blob/c7a891ae8cbd18d844cb2ba648927c3c6dfa564f/src/time/julian_day.jl#L117-L122">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="SatelliteToolbox.date_to_jd-Tuple{Dates.Date}" href="#SatelliteToolbox.date_to_jd-Tuple{Dates.Date}"><code>SatelliteToolbox.date_to_jd</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">date_to_jd(date::Date)</code></pre><p>Convert the date <code>date</code> to Julian Day.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaSpace/SatelliteToolbox.jl/blob/c7a891ae8cbd18d844cb2ba648927c3c6dfa564f/src/time/julian_day.jl#L106-L111">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="SatelliteToolbox.date_to_jd-Tuple{Integer, Integer, Integer, Integer, Integer, Number}" href="#SatelliteToolbox.date_to_jd-Tuple{Integer, Integer, Integer, Integer, Integer, Number}"><code>SatelliteToolbox.date_to_jd</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">date_to_jd(Y::Integer, M::Integer, D::Integer, h::Integer, m::Integer, s::Number)</code></pre><p>Convert a date represented using the Gregorian Calendar (Year = <code>y</code>, Month = <code>M</code> (1-12), Day = <code>D</code>, Hour = <code>h</code> (0-24), minute = <code>m</code>, and second = <code>s</code>) to Julian Day.</p><p><strong>Remarks</strong></p><p>The algorithm was obtained from [2] (Accessed on 2018-04-11).</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaSpace/SatelliteToolbox.jl/blob/c7a891ae8cbd18d844cb2ba648927c3c6dfa564f/src/time/julian_day.jl#L55-L66">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="SatelliteToolbox.deps_dpsi-Tuple{EOPData_IAU2000A, Number}" href="#SatelliteToolbox.deps_dpsi-Tuple{EOPData_IAU2000A, Number}"><code>SatelliteToolbox.deps_dpsi</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">deps_dpsi(eop_iau2000a::EOPData_IAU2000A, JD::Number)</code></pre><p>Returns the celestial pole offsets in obliquity (δϵ<em>2000) and longitude (δΨ</em>2000) [arcsec]. This function obtains those values by converting the celestial pole offsets with respect to the GCRS (<code>dX</code> and <code>dY</code>). These values are necessary in the equinox-based IAU-2006 theory.</p><p>The algorithm was obtained from [2, eq. 5.25] and [3, <code>DPSIDEPS2000_DXDY2000</code>].</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaSpace/SatelliteToolbox.jl/blob/c7a891ae8cbd18d844cb2ba648927c3c6dfa564f/src/transformations/eop.jl#L258-L268">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="SatelliteToolbox.dlegendre" href="#SatelliteToolbox.dlegendre"><code>SatelliteToolbox.dlegendre</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">dlegendre([N,] ϕ::Number, n_max::Integer, m_max::Integer = -1, ph_term::Bool = false)</code></pre><p>Compute the first-order derivative of the associated Legendre function <code>P_n,m[cos(ϕ)]</code> w.r.t. <code>ϕ</code> [rad]:</p><pre><code class="language-none">dP_n,m[cos(ϕ)]
--------------
      dϕ</code></pre><p>The maximum degree that will be computed is <code>n_max</code> and the maximum order is <code>m_max</code>. Notice that if <code>m_max</code> is higher than <code>n_max</code> or negative, than it is set to <code>n_max</code>.</p><p>The optional parameter <code>N</code> can be used to select the normalization. The following values are valid:</p><ul><li><code>Val(:full)</code>: Compute the fully normalized associated Legendre function (see               <code>legendre_fully_normalized</code>).</li><li><code>Val(:schmidt)</code>: Compute the Schmidt quasi-normalized associated Legendre                  function (see <code>legendre_schmidt_quasi_normalized</code>).</li><li><code>Val(:conv)</code>: Compute the conventional associated Legendre function (see               <code>dlegendre_conventional!</code>).</li></ul><p>If <code>N</code> is omitted, then the full normalization will be used (<code>Val(:full)</code>).</p><p>If <code>ph_term</code> is set to <code>true</code>, then the Condon-Shortley phase term <code>(-1)ᵐ</code> will be included. If <code>ph_term</code> is not present, then it defaults to <code>false</code>.</p><p><strong>Returns</strong></p><ul><li>A matrix with the first-order derivative of the Legendre associated functions</li></ul><p><code>P_n,m[cos(ϕ)]</code>.</p><ul><li>A matrix with the Legendre associated functions <code>P_n,m[cos(ϕ)]</code>.</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaSpace/SatelliteToolbox.jl/blob/c7a891ae8cbd18d844cb2ba648927c3c6dfa564f/src/misc/dlegendre.jl#L78-L113">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="SatelliteToolbox.dlegendre!" href="#SatelliteToolbox.dlegendre!"><code>SatelliteToolbox.dlegendre!</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">dlegendre!([N,] dP::AbstractMatrix, ϕ::Number, P::AbstractMatrix, ph_term::Bool = false, n_max::Integer = -1, m_max::Integer = -1)</code></pre><p>Compute the first-order derivative of the associated Legendre function <code>P_n,m[x]</code> w.r.t. <code>ϕ</code> [rad]:</p><pre><code class="language-none">dP_n,m[cos(ϕ)]
--------------
      dϕ</code></pre><p>The derivatives will be stored in the matrix <code>dP</code>. The maximum degree and order that will be computed are given by the parameters <code>n_max</code> and <code>m_max</code>. If they are negative, then the dimensions of matrix <code>dP</code> will be used.</p><p>This algorithm needs the matrix <code>P</code> with the associated Legendre function. This can be computed using the function <code>legendre</code>. Notice that this matrix must be computed using the same normalization (see <code>N</code>) as the one selected here.</p><p>The optional parameter <code>N</code> can be used to select the normalization. The following values are valid:</p><ul><li><code>Val(:full)</code>: Compute the fully normalized associated Legendre function (see               <code>dlegendre_fully_normalized!</code>).</li><li><code>Val(:schmidt)</code>: Compute the Schmidt quasi-normalized associated Legendre                  function (see <code>dlegendre_schmidt_quasi_normalized!</code>).</li><li><code>Val(:conv)</code>: Compute the conventional associated Legendre function (see               <code>dlegendre_conventional!</code>).</li></ul><p>If <code>N</code> is omitted, then the full normalization will be used (<code>Val(:full)</code>).</p><p>If <code>ph_term</code> is set to <code>true</code>, then the Condon-Shortley phase term <code>(-1)ᵐ</code> will be included. If <code>ph_term</code> is not present, then it defaults to <code>false</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaSpace/SatelliteToolbox.jl/blob/c7a891ae8cbd18d844cb2ba648927c3c6dfa564f/src/misc/dlegendre.jl#L28-L61">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="SatelliteToolbox.dlegendre_conventional!" href="#SatelliteToolbox.dlegendre_conventional!"><code>SatelliteToolbox.dlegendre_conventional!</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">dlegendre_conventional!(dP::AbstractMatrix, ϕ::Number, P::AbstractMatrix, ph_term::Bool = false, n_max::Integer = -1, m_max::Integer = -1)</code></pre><p>Compute the first-order derivative of the conventional associated Legendre function <code>P_n,m[cos(ϕ)]</code> w.r.t. <code>ϕ</code> [rad]:</p><pre><code class="language-none">dP_n,m[cos(ϕ)]
--------------
      dϕ</code></pre><p>The derivatives will be stored in the matrix <code>dP</code>. The maximum degree and order that will be computed are given by the parameters <code>n_max</code> and <code>m_max</code>. If they are negative, then the dimensions of matrix <code>dP</code> will be used.</p><p>This algorithm needs the matrix <code>P</code> with the conventional associated Legendre function. This can be computed using the function <code>legendre_conventional</code>.</p><p>If <code>ph_term</code> is set to <code>true</code>, then the Condon-Shortley phase term <code>(-1)ᵐ</code> will be included. If <code>ph_term</code> is not present, then it defaults to <code>false</code>.</p><p><strong>Remarks</strong></p><p>The user is responsible to pass a matrix <code>P</code> with the correct values. For example, if <code>ph_term</code> is <code>true</code>, then <code>P</code> must also be computed with <code>ph_term</code> set to <code>true</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaSpace/SatelliteToolbox.jl/blob/c7a891ae8cbd18d844cb2ba648927c3c6dfa564f/src/misc/dlegendre.jl#L397-L423">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="SatelliteToolbox.dlegendre_conventional-Union{Tuple{T}, Tuple{T, Integer}, Tuple{T, Integer, Integer}, Tuple{T, Integer, Integer, Bool}} where T&lt;:AbstractFloat" href="#SatelliteToolbox.dlegendre_conventional-Union{Tuple{T}, Tuple{T, Integer}, Tuple{T, Integer, Integer}, Tuple{T, Integer, Integer, Bool}} where T&lt;:AbstractFloat"><code>SatelliteToolbox.dlegendre_conventional</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">dlegendre_conventional(ϕ::Number, n_max::Integer, m_max::Integer = -1, ph_term::Bool = false)</code></pre><p>Compute the first-order derivative of the conventional associated Legendre function <code>P_n,m[cos(ϕ)]</code> w.r.t. <code>ϕ</code> [rad]:</p><pre><code class="language-none">dP_n,m[cos(ϕ)]
--------------
      dϕ</code></pre><p>The maximum degree that will be computed is <code>n_max</code> and the maximum order is <code>m_max</code>. Notice that if <code>m_max</code> is higher than <code>n_max</code> or negative, than it is set to <code>n_max</code>.</p><p>If <code>ph_term</code> is set to <code>true</code>, then the Condon-Shortley phase term <code>(-1)ᵐ</code> will be included. If <code>ph_term</code> is not present, then it defaults to <code>false</code>.</p><p><strong>Returns</strong></p><p>A matrix with the first-order derivative of the Legendre associated functions <code>P_n,m[cos(ϕ)]</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaSpace/SatelliteToolbox.jl/blob/c7a891ae8cbd18d844cb2ba648927c3c6dfa564f/src/misc/dlegendre.jl#L476-L498">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="SatelliteToolbox.dlegendre_fully_normalized!" href="#SatelliteToolbox.dlegendre_fully_normalized!"><code>SatelliteToolbox.dlegendre_fully_normalized!</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">dlegendre_fully_normalized!(dP::AbstractMatrix, ϕ::Number, P::AbstractMatrix, ph_term::Bool = false, n_max::Integer = -1, m_max::Integer = -1)</code></pre><p>Compute the first-order derivative of the fully normalized associated Legendre function <code>P_n,m[cos(ϕ)]</code> w.r.t. <code>ϕ</code> [rad]:</p><pre><code class="language-none">dP_n,m[cos(ϕ)]
--------------
      dϕ</code></pre><p>The derivatives will be stored in the matrix <code>dP</code>. The maximum degree and order that will be computed are given by the parameters <code>n_max</code> and <code>m_max</code>. If they are negative, then the dimensions of matrix <code>dP</code> will be used.</p><p>This algorithm needs the matrix <code>P</code> with the fully normalized associated Legendre function. This can be computed using the function <code>legendre_fully_normalized</code>.</p><p>If <code>ph_term</code> is set to <code>true</code>, then the Condon-Shortley phase term <code>(-1)ᵐ</code> will be included. If <code>ph_term</code> is not present, then it defaults to <code>false</code>.</p><p><strong>Remarks</strong></p><p>The user is responsible to pass a matrix <code>P</code> with the correct values. For example, if <code>ph_term</code> is <code>true</code>, then <code>P</code> must also be computed with <code>ph_term</code> set to <code>true</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaSpace/SatelliteToolbox.jl/blob/c7a891ae8cbd18d844cb2ba648927c3c6dfa564f/src/misc/dlegendre.jl#L133-L160">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="SatelliteToolbox.dlegendre_fully_normalized-Union{Tuple{T}, Tuple{T, Integer}, Tuple{T, Integer, Integer}, Tuple{T, Integer, Integer, Bool}} where T&lt;:AbstractFloat" href="#SatelliteToolbox.dlegendre_fully_normalized-Union{Tuple{T}, Tuple{T, Integer}, Tuple{T, Integer, Integer}, Tuple{T, Integer, Integer, Bool}} where T&lt;:AbstractFloat"><code>SatelliteToolbox.dlegendre_fully_normalized</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">dlegendre_fully_normalized(ϕ::T, n_max::Integer, m_max::Integer = -1, ph_term::Bool = false) where T&lt;:AbstractFloat</code></pre><p>Compute the first-order derivative of the Schmidt fully normalized associated Legendre function <code>P_n,m[cos(ϕ)]</code> w.r.t. <code>ϕ</code> [rad]:</p><pre><code class="language-none">dP_n,m[cos(ϕ)]
--------------
      dϕ</code></pre><p>The maximum degree that will be computed is <code>n_max</code> and the maximum order is <code>m_max</code>. Notice that if <code>m_max</code> is higher than <code>n_max</code> or negative, than it is set to <code>n_max</code>.</p><p>If <code>ph_term</code> is set to <code>true</code>, then the Condon-Shortley phase term <code>(-1)ᵐ</code> will be included. If <code>ph_term</code> is not present, then it defaults to <code>false</code>.</p><p><strong>Returns</strong></p><p>A matrix with the first-order derivative of the Legendre associated functions <code>P_n,m[cos(ϕ)]</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaSpace/SatelliteToolbox.jl/blob/c7a891ae8cbd18d844cb2ba648927c3c6dfa564f/src/misc/dlegendre.jl#L257-L279">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="SatelliteToolbox.dlegendre_schmidt_quasi_normalized!" href="#SatelliteToolbox.dlegendre_schmidt_quasi_normalized!"><code>SatelliteToolbox.dlegendre_schmidt_quasi_normalized!</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">dlegendre_schmidt_quasi_normalized!(dP::AbstractMatrix, ϕ::Number, P::AbstractMatrix, ph_term::Bool = false, n_max::Integer = -1, m_max::Integer = -1)</code></pre><p>Compute the first-order derivative of the Schmidt quasi-normalized associated Legendre function <code>P_n,m[cos(ϕ)]</code> w.r.t. <code>ϕ</code> [rad]:</p><pre><code class="language-none">dP_n,m[cos(ϕ)]
--------------
      dϕ</code></pre><p>The derivatives will be stored in the matrix <code>dP</code>. The maximum degree and order that will be computed are given by the parameters <code>n_max</code> and <code>m_max</code>. If they are negative, then the dimensions of matrix <code>dP</code> will be used.</p><p>This algorithm needs the matrix <code>P</code> with the Schmidt quasi-normalized associated Legendre function. This can be computed using the function <code>legendre_schmidt_quasi_normalized</code>.</p><p>If <code>ph_term</code> is set to <code>true</code>, then the Condon-Shortley phase term <code>(-1)ᵐ</code> will be included. If <code>ph_term</code> is not present, then it defaults to <code>false</code>.</p><p><strong>Remarks</strong></p><p>The user is responsible to pass a matrix <code>P</code> with the correct values. For example, if <code>ph_term</code> is <code>true</code>, then <code>P</code> must also be computed with <code>ph_term</code> set to <code>true</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaSpace/SatelliteToolbox.jl/blob/c7a891ae8cbd18d844cb2ba648927c3c6dfa564f/src/misc/dlegendre.jl#L308-L335">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="SatelliteToolbox.dlegendre_schmidt_quasi_normalized-Union{Tuple{T}, Tuple{T, Integer}, Tuple{T, Integer, Integer}, Tuple{T, Integer, Integer, Bool}} where T&lt;:AbstractFloat" href="#SatelliteToolbox.dlegendre_schmidt_quasi_normalized-Union{Tuple{T}, Tuple{T, Integer}, Tuple{T, Integer, Integer}, Tuple{T, Integer, Integer, Bool}} where T&lt;:AbstractFloat"><code>SatelliteToolbox.dlegendre_schmidt_quasi_normalized</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">dlegendre_schmidt_quasi_normalized(ϕ::T, n_max::Integer, m_max::Integer = -1, ph_term::Bool = false) where T&lt;:AbstractFloat</code></pre><p>Compute the first-order derivative of the Schmidt quasi-normalized associated Legendre function <code>P_n,m[cos(ϕ)]</code> w.r.t. <code>ϕ</code> [rad]:</p><pre><code class="language-none">dP_n,m[cos(ϕ)]
--------------
      dϕ</code></pre><p>The maximum degree that will be computed is <code>n_max</code> and the maximum order is <code>m_max</code>. Notice that if <code>m_max</code> is higher than <code>n_max</code> or negative, than it is set to <code>n_max</code>.</p><p>If <code>ph_term</code> is set to <code>true</code>, then the Condon-Shortley phase term <code>(-1)ᵐ</code> will be included. If <code>ph_term</code> is not present, then it defaults to <code>false</code>.</p><p><strong>Returns</strong></p><p>A matrix with the first-order derivative of the Legendre associated functions <code>P_n,m[cos(ϕ)]</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaSpace/SatelliteToolbox.jl/blob/c7a891ae8cbd18d844cb2ba648927c3c6dfa564f/src/misc/dlegendre.jl#L345-L367">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="SatelliteToolbox.draan" href="#SatelliteToolbox.draan"><code>SatelliteToolbox.draan</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">draan(a::Number, e::Number, i::Number, pert::Symbol = :J2)
draan(orb::Orbit, pert::Symbol = :J2)</code></pre><p>Compute the time-derivative of the right ascension of the ascending node [rad/s] of an orbit with semi-major axis <code>a</code> [m], eccentricity <code>e</code>, and inclination <code>i</code> [rad], using the perturbation terms specified by the symbol <code>pert</code>. The orbit can also be specified by <code>orb</code> (see <a href="#SatelliteToolbox.Orbit"><code>Orbit</code></a>).</p><p><code>pert</code> can be:</p><ul><li><code>:J0</code>: Consider a Keplerian orbit.</li><li><code>:J2</code>: Consider the perturbation terms up to J2.</li><li><code>:J4</code>: Consider the perturbation terms J2, J4, and J2².</li></ul><p>If <code>pert</code> is omitted, then it defaults to <code>:J2</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaSpace/SatelliteToolbox.jl/blob/c7a891ae8cbd18d844cb2ba648927c3c6dfa564f/src/orbit/general.jl#L354-L371">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="SatelliteToolbox.ecef_to_geodetic-Tuple{AbstractVector{T} where T}" href="#SatelliteToolbox.ecef_to_geodetic-Tuple{AbstractVector{T} where T}"><code>SatelliteToolbox.ecef_to_geodetic</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">ecef_to_geodetic(r_e::AbstractVector)</code></pre><p>Convert the vector <code>r_e</code> [m] represented in the Earth-Centered, Earth-Fixed (ECEF) reference frame into Geodetic coordinates (WGS-84).</p><p><strong>Returns</strong></p><ul><li>Latitude [rad].</li><li>Longitude [rad].</li><li>Altitude [m].</li></ul><p><strong>Remarks</strong></p><p>Based on algorithm in [3].</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaSpace/SatelliteToolbox.jl/blob/c7a891ae8cbd18d844cb2ba648927c3c6dfa564f/src/transformations/geodetic_geocentric.jl#L32-L48">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="SatelliteToolbox.eclipse_time_summary" href="#SatelliteToolbox.eclipse_time_summary"><code>SatelliteToolbox.eclipse_time_summary</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">eclipse_time_summary(JD₀::Number, a::Number, e::Number, i::Number, RAAN::Number, w::Number, Δd::Integer, relative::Bool = false, Δt₀::AbstractFloat = -1.0)</code></pre><p>Compute the eclipse time of an orbit with semi-major axis <code>a</code> [m], eccentricity <code>e</code>, inclination <code>i</code> [rad], initial right ascension of the ascending node <code>RAAN</code> [rad], and initial argument of perigee <code>w</code> [rad]. The orbit epoch, which is also the day in which the analysis will begin, is <code>JD₀</code> [Julian Day]. The analysis will be performed for each day during <code>Δd</code> days.</p><p>This function will compute the eclipse time of one orbit per day.</p><p>If the argument <code>relative</code> is <code>true</code>, then the computed times will be relative to the nodal period [%]. Otherwise, they will be computed in seconds. By default, <code>relative = false</code>.</p><p>The argument <code>Δt₀</code> can be used to select the time step in which the orbit will be propagated. Notice that this algorithm performs a numerical search to find the beginning of each section (sunlight, penumbra, and umbra) with millisecond precision. Thus, selecting a high number for <code>Δt₀</code> will make the analysis faster, but the accuracy is lost if a region time span is smalled than <code>Δt₀</code>. If this parameter is omitted or if it is negative, then the time step will be selected automatically to match a mean anomaly step of 5°.</p><p>All the analysis is performed using a J2 orbit propagator.</p><p><strong>Returns</strong></p><p>The following table:</p><pre><code class="language-none">    day | Sunlight Time | Penumbra Time | Umbra Time
   -----+---------------+---------------+------------</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaSpace/SatelliteToolbox.jl/blob/c7a891ae8cbd18d844cb2ba648927c3c6dfa564f/src/analysis/eclipse_time.jl#L20-L52">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="SatelliteToolbox.equation_of_time-Tuple{Number}" href="#SatelliteToolbox.equation_of_time-Tuple{Number}"><code>SatelliteToolbox.equation_of_time</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">equation_of_time(JD::Number)</code></pre><p>Compute the difference between the Sun apparent local time and the Sun mean local time [rad], which is called Equation of Time, at the Julian Day <code>JD</code>. The algorithm was adapted from [1, p. 178, 277-279].</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaSpace/SatelliteToolbox.jl/blob/c7a891ae8cbd18d844cb2ba648927c3c6dfa564f/src/sun/equation_of_time.jl#L18-L25">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="SatelliteToolbox.expatmosphere-Tuple{Number}" href="#SatelliteToolbox.expatmosphere-Tuple{Number}"><code>SatelliteToolbox.expatmosphere</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">expatmosphere(h::Number)</code></pre><p>Compute the atmospheric density [kg/m³] at the altitude <code>h</code> [m] (above the ellipsoid) using the exponential atmospheric model:</p><pre><code class="language-none">                ┌            ┐
                │    h - h₀  │
ρ(h) = ρ₀ ⋅ exp │ - ──────── │ ,
                │      H     │
                └            ┘</code></pre><p>in which <code>ρ₀</code>, <code>h₀</code>, and <code>H</code> are parameters obtained from tables that depend only on <code>h</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaSpace/SatelliteToolbox.jl/blob/c7a891ae8cbd18d844cb2ba648927c3c6dfa564f/src/earth/atmospheric_models/expatmosphere/expatmosphere.jl#L18-L33">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="SatelliteToolbox.f_to_E-Tuple{Number, Number}" href="#SatelliteToolbox.f_to_E-Tuple{Number, Number}"><code>SatelliteToolbox.f_to_E</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">f_to_E(e::Number,f::Number)</code></pre><p>Compute the eccentric anomaly (0,2π) [rad] given the eccentricity <code>e</code> and the true anomaly <code>f</code> [rad].</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaSpace/SatelliteToolbox.jl/blob/c7a891ae8cbd18d844cb2ba648927c3c6dfa564f/src/orbit/anomalies.jl#L104-L110">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="SatelliteToolbox.f_to_M-Tuple{Number, Number}" href="#SatelliteToolbox.f_to_M-Tuple{Number, Number}"><code>SatelliteToolbox.f_to_M</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">f_to_M(e::Number, f::Number)</code></pre><p>Compute the mean anomaly (0,2π) [rad] given the eccentricity <code>e</code> and the true anomaly <code>f</code> [rad].</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaSpace/SatelliteToolbox.jl/blob/c7a891ae8cbd18d844cb2ba648927c3c6dfa564f/src/orbit/anomalies.jl#L117-L123">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="SatelliteToolbox.find_crossing-Tuple{Function, Number, Number, Any, Any, Vararg{Any, N} where N}" href="#SatelliteToolbox.find_crossing-Tuple{Function, Number, Number, Any, Any, Vararg{Any, N} where N}"><code>SatelliteToolbox.find_crossing</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">find_crossing(f::Function, t₀::Number, t₁::Number, s₀, s₁; Δ = 1e-3, max = 100)</code></pre><p>Return the crossing time <code>tc</code> in which the function <code>f(t)</code> goes from the state <code>s₀</code> to the state <code>s₁</code>. It is assumed that <code>f(t₀) = s₀</code> and <code>f(t₁) = s₁</code>.</p><p>If the computed interval is smalled than <code>Δ</code> or if the number of iterations is higher than <code>max</code>, then the algorithm stops.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaSpace/SatelliteToolbox.jl/blob/c7a891ae8cbd18d844cb2ba648927c3c6dfa564f/src/misc/crossing.jl#L9-L18">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="SatelliteToolbox.geocentric_to_geodetic-Tuple{Number, Number}" href="#SatelliteToolbox.geocentric_to_geodetic-Tuple{Number, Number}"><code>SatelliteToolbox.geocentric_to_geodetic</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">geocentric_to_geodetic(ϕ_gc::Number, r::Number)</code></pre><p>Compute the geodetic latitude and altitude (WGS-84) from the geocentric latitude <code>ϕ_gc</code> (-π/2, π/2) [rad] and radius <code>r</code> [m]. Notice that the longitude is the same in both geocentric and geodetic coordinates.</p><p><strong>Returns</strong></p><ul><li>Geodetic latitude [rad].</li><li>Altitude above the reference ellipsoid (WGS-84) [m].</li></ul><p><strong>Remarks</strong></p><p>Based on algorithm in [5].</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaSpace/SatelliteToolbox.jl/blob/c7a891ae8cbd18d844cb2ba648927c3c6dfa564f/src/transformations/geodetic_geocentric.jl#L109-L125">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="SatelliteToolbox.geodetic_to_ecef-Tuple{Number, Number, Number}" href="#SatelliteToolbox.geodetic_to_ecef-Tuple{Number, Number, Number}"><code>SatelliteToolbox.geodetic_to_ecef</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">geodetic_to_ecef(lat::Number, lon::Number, h::Number)</code></pre><p>Convert the latitude <code>lat</code> [rad], longitude <code>lon</code> [rad], and altitude <code>h</code> [m] (WGS-84) into a vector represented on the Earth-Centered, Earth-Fixed (ECEF) reference frame.</p><p><strong>Remarks</strong></p><p>Based on algorithm in [3].</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaSpace/SatelliteToolbox.jl/blob/c7a891ae8cbd18d844cb2ba648927c3c6dfa564f/src/transformations/geodetic_geocentric.jl#L81-L92">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="SatelliteToolbox.geodetic_to_geocentric-Tuple{Number, Number}" href="#SatelliteToolbox.geodetic_to_geocentric-Tuple{Number, Number}"><code>SatelliteToolbox.geodetic_to_geocentric</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">geodetic_to_geocentric(ϕ_gd::Number, h::Number)</code></pre><p>Compute the geocentric latitude and radius from the geodetic latitude <code>ϕ_gd</code> (-π/2, π/2) [rad] and height above the reference ellipsoid <code>h</code> [m] (WGS-84). Notice that the longitude is the same in both geocentric and geodetic coordinates.</p><p><strong>Returns</strong></p><ul><li>Geocentric latitude [rad].</li><li>Radius from the center of the Earth [m].</li></ul><p><strong>Remarks</strong></p><p>Based on algorithm in [4, p. 3].</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaSpace/SatelliteToolbox.jl/blob/c7a891ae8cbd18d844cb2ba648927c3c6dfa564f/src/transformations/geodetic_geocentric.jl#L173-L190">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="SatelliteToolbox.geomag_dipole" href="#SatelliteToolbox.geomag_dipole"><code>SatelliteToolbox.geomag_dipole</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">geomag_dipole(r_e::AbstractVector, pole_lat::Number, pole_lon::Number, m::Number)</code></pre><p>Compute the geomagnetic field [nT] using the simplified dipole model at position <code>r_e</code> (ECEF reference frame). This function considers that the latitude of the South magnetic pole (which lies in the North hemisphere) is <code>pole_lat</code> [rad] and the longitude is <code>pole_lon</code> [rad]. Furthermore, the dipole moment is considered to be <code>m</code> [A.m²].</p><pre><code class="language-none">geomag_dipole(r_e::AbstractVector, year::Number = 2019)</code></pre><p>Compute the geomagnetic field [nT] using the simplified dipole model at position <code>r_e</code> (ECEF reference frame). This function uses the year <code>year</code> to obtain the position of the South magnetic pole (which lies in the North hemisphere) and the dipole moment. If <code>year</code> is omitted, then it will be considered as 2019.</p><p><strong>Remarks</strong></p><p>In both functions, the output vector will be represented in the ECEF reference frame.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaSpace/SatelliteToolbox.jl/blob/c7a891ae8cbd18d844cb2ba648927c3c6dfa564f/src/earth/geomagnetic_field_models/dipole/geomag_dipole.jl#L17-L38">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="SatelliteToolbox.get_Ap-Tuple{Number}" href="#SatelliteToolbox.get_Ap-Tuple{Number}"><code>SatelliteToolbox.get_Ap</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">get_Ap(JD::Number; mean::Tuple{Int} = (), daily = false)</code></pre><p>Return the Ap index.</p><p>If <code>mean</code> is a tuple of two integers <code>(hi, hf)</code>, then the average between <code>hi</code> and <code>hf</code> previous hours will be computed.</p><p>If <code>mean</code> is empty and <code>daily</code> is <code>true</code>, then the day average will be computed.</p><p>If <code>mean</code> keyword is empty, and <code>daily</code> keyword is <code>false</code>, then the Ap at Julian day <code>JD</code> will be computed.</p><p>By default, <code>mean</code> is empty and <code>daily</code> is <code>false</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaSpace/SatelliteToolbox.jl/blob/c7a891ae8cbd18d844cb2ba648927c3c6dfa564f/src/earth/space_indices/wdcfiles.jl#L72-L87">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="SatelliteToolbox.get_DstΔTc-Tuple{Number}" href="#SatelliteToolbox.get_DstΔTc-Tuple{Number}"><code>SatelliteToolbox.get_DstΔTc</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">get_DstΔTc(JD::Number)</code></pre><p>Get the value of the index <code>DstΔTc</code> at Julian Day <code>JD</code>.</p><p>This function requires the initialization of the variable <code>_dtcfile_data</code>. Otherwise, an exception will be raised. To initialize it, run <code>init_space_indices()</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaSpace/SatelliteToolbox.jl/blob/c7a891ae8cbd18d844cb2ba648927c3c6dfa564f/src/earth/space_indices/dtcfile.jl#L60-L69">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="SatelliteToolbox.get_F10-Tuple{Number}" href="#SatelliteToolbox.get_F10-Tuple{Number}"><code>SatelliteToolbox.get_F10</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">get_F10(JD::Number)</code></pre><p>Get the value of the index <code>F10</code> at Julian Day <code>JD</code>.</p><p>This function requires the initialization of the variable <code>_solfsmy_data</code>. Otherwise, an exception will be raised. To initialize it, run <code>init_space_indices()</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaSpace/SatelliteToolbox.jl/blob/c7a891ae8cbd18d844cb2ba648927c3c6dfa564f/src/earth/space_indices/solfsmy.jl#L78-L87">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="SatelliteToolbox.get_F81a-Tuple{Number}" href="#SatelliteToolbox.get_F81a-Tuple{Number}"><code>SatelliteToolbox.get_F81a</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">get_F81a(JD::Number)</code></pre><p>Get the value of the index <code>F81a</code> at Julian Day <code>JD</code>.</p><p>This function requires the initialization of the variable <code>_solfsmy_data</code>. Otherwise, an exception will be raised. To initialize it, run <code>init_space_indices()</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaSpace/SatelliteToolbox.jl/blob/c7a891ae8cbd18d844cb2ba648927c3c6dfa564f/src/earth/space_indices/solfsmy.jl#L78-L87">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="SatelliteToolbox.get_Kp-Tuple{Number}" href="#SatelliteToolbox.get_Kp-Tuple{Number}"><code>SatelliteToolbox.get_Kp</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">get_Kp(JD::Number)</code></pre><p>Return the Kp index at Julian Day <code>JD</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaSpace/SatelliteToolbox.jl/blob/c7a891ae8cbd18d844cb2ba648927c3c6dfa564f/src/earth/space_indices/wdcfiles.jl#L57-L62">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="SatelliteToolbox.get_M" href="#SatelliteToolbox.get_M"><code>SatelliteToolbox.get_M</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">get_M(orb)</code></pre><p>Return the mean anomaly of the representation <code>orb</code> [rad].</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaSpace/SatelliteToolbox.jl/blob/c7a891ae8cbd18d844cb2ba648927c3c6dfa564f/src/orbit/representations/api.jl#L88-L93">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="SatelliteToolbox.get_M10-Tuple{Number}" href="#SatelliteToolbox.get_M10-Tuple{Number}"><code>SatelliteToolbox.get_M10</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">get_M10(JD::Number)</code></pre><p>Get the value of the index <code>M10</code> at Julian Day <code>JD</code>.</p><p>This function requires the initialization of the variable <code>_solfsmy_data</code>. Otherwise, an exception will be raised. To initialize it, run <code>init_space_indices()</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaSpace/SatelliteToolbox.jl/blob/c7a891ae8cbd18d844cb2ba648927c3c6dfa564f/src/earth/space_indices/solfsmy.jl#L78-L87">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="SatelliteToolbox.get_M81a-Tuple{Number}" href="#SatelliteToolbox.get_M81a-Tuple{Number}"><code>SatelliteToolbox.get_M81a</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">get_M81a(JD::Number)</code></pre><p>Get the value of the index <code>M81a</code> at Julian Day <code>JD</code>.</p><p>This function requires the initialization of the variable <code>_solfsmy_data</code>. Otherwise, an exception will be raised. To initialize it, run <code>init_space_indices()</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaSpace/SatelliteToolbox.jl/blob/c7a891ae8cbd18d844cb2ba648927c3c6dfa564f/src/earth/space_indices/solfsmy.jl#L78-L87">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="SatelliteToolbox.get_S10-Tuple{Number}" href="#SatelliteToolbox.get_S10-Tuple{Number}"><code>SatelliteToolbox.get_S10</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">get_S10(JD::Number)</code></pre><p>Get the value of the index <code>S10</code> at Julian Day <code>JD</code>.</p><p>This function requires the initialization of the variable <code>_solfsmy_data</code>. Otherwise, an exception will be raised. To initialize it, run <code>init_space_indices()</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaSpace/SatelliteToolbox.jl/blob/c7a891ae8cbd18d844cb2ba648927c3c6dfa564f/src/earth/space_indices/solfsmy.jl#L78-L87">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="SatelliteToolbox.get_S81a-Tuple{Number}" href="#SatelliteToolbox.get_S81a-Tuple{Number}"><code>SatelliteToolbox.get_S81a</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">get_S81a(JD::Number)</code></pre><p>Get the value of the index <code>S81a</code> at Julian Day <code>JD</code>.</p><p>This function requires the initialization of the variable <code>_solfsmy_data</code>. Otherwise, an exception will be raised. To initialize it, run <code>init_space_indices()</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaSpace/SatelliteToolbox.jl/blob/c7a891ae8cbd18d844cb2ba648927c3c6dfa564f/src/earth/space_indices/solfsmy.jl#L78-L87">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="SatelliteToolbox.get_Y10-Tuple{Number}" href="#SatelliteToolbox.get_Y10-Tuple{Number}"><code>SatelliteToolbox.get_Y10</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">get_Y10(JD::Number)</code></pre><p>Get the value of the index <code>Y10</code> at Julian Day <code>JD</code>.</p><p>This function requires the initialization of the variable <code>_solfsmy_data</code>. Otherwise, an exception will be raised. To initialize it, run <code>init_space_indices()</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaSpace/SatelliteToolbox.jl/blob/c7a891ae8cbd18d844cb2ba648927c3c6dfa564f/src/earth/space_indices/solfsmy.jl#L78-L87">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="SatelliteToolbox.get_Y81a-Tuple{Number}" href="#SatelliteToolbox.get_Y81a-Tuple{Number}"><code>SatelliteToolbox.get_Y81a</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">get_Y81a(JD::Number)</code></pre><p>Get the value of the index <code>Y81a</code> at Julian Day <code>JD</code>.</p><p>This function requires the initialization of the variable <code>_solfsmy_data</code>. Otherwise, an exception will be raised. To initialize it, run <code>init_space_indices()</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaSpace/SatelliteToolbox.jl/blob/c7a891ae8cbd18d844cb2ba648927c3c6dfa564f/src/earth/space_indices/solfsmy.jl#L78-L87">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="SatelliteToolbox.get_a" href="#SatelliteToolbox.get_a"><code>SatelliteToolbox.get_a</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">get_a(orb)</code></pre><p>Return the semi-major axis of the orbit representation <code>orb</code> [m].</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaSpace/SatelliteToolbox.jl/blob/c7a891ae8cbd18d844cb2ba648927c3c6dfa564f/src/orbit/representations/api.jl#L21-L26">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="SatelliteToolbox.get_argp-Tuple{Any}" href="#SatelliteToolbox.get_argp-Tuple{Any}"><code>SatelliteToolbox.get_argp</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">get_argp(orb)</code></pre><p>Return the argument of periapsis of the representation <code>orb</code> [rad].</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaSpace/SatelliteToolbox.jl/blob/c7a891ae8cbd18d844cb2ba648927c3c6dfa564f/src/orbit/representations/api.jl#L80-L85">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="SatelliteToolbox.get_e" href="#SatelliteToolbox.get_e"><code>SatelliteToolbox.get_e</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">get_e(orb)</code></pre><p>Return the eccentricity of the orbit representation <code>orb</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaSpace/SatelliteToolbox.jl/blob/c7a891ae8cbd18d844cb2ba648927c3c6dfa564f/src/orbit/representations/api.jl#L29-L34">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="SatelliteToolbox.get_epoch" href="#SatelliteToolbox.get_epoch"><code>SatelliteToolbox.get_epoch</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">get_epoch(orbp)</code></pre><p>Return the epoch of the propagator <code>orbp</code> [JD].</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaSpace/SatelliteToolbox.jl/blob/c7a891ae8cbd18d844cb2ba648927c3c6dfa564f/src/orbit/propagators/api/api.jl#L22-L27">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="SatelliteToolbox.get_epoch-Tuple{Any}" href="#SatelliteToolbox.get_epoch-Tuple{Any}"><code>SatelliteToolbox.get_epoch</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">get_epoch(orb)</code></pre><p>Return the epoch of the orbit representation <code>orb</code> [m].</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaSpace/SatelliteToolbox.jl/blob/c7a891ae8cbd18d844cb2ba648927c3c6dfa564f/src/orbit/representations/api.jl#L13-L18">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="SatelliteToolbox.get_f" href="#SatelliteToolbox.get_f"><code>SatelliteToolbox.get_f</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">get_f(orb)</code></pre><p>Return the true anomaly of the representation <code>orb</code> [rad].</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaSpace/SatelliteToolbox.jl/blob/c7a891ae8cbd18d844cb2ba648927c3c6dfa564f/src/orbit/representations/api.jl#L63-L68">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="SatelliteToolbox.get_i" href="#SatelliteToolbox.get_i"><code>SatelliteToolbox.get_i</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">get_i(orb)</code></pre><p>Return the inclination of the orbit representation <code>orb</code> [rad].</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaSpace/SatelliteToolbox.jl/blob/c7a891ae8cbd18d844cb2ba648927c3c6dfa564f/src/orbit/representations/api.jl#L38-L43">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="SatelliteToolbox.get_iers_eop" href="#SatelliteToolbox.get_iers_eop"><code>SatelliteToolbox.get_iers_eop</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">get_iers_eop(data_type::Symbol = :IAU1980; force_download = false)</code></pre><p>Download and parse the IERS EOP C04 data. The data type is specified by <code>data_type</code> symbol. Supported values are:</p><ul><li><code>IAU1980</code>: Get IERS EOP C04 IAU1980 data.</li><li><code>IAU2000A</code>: Get IERS EOP C04 IAU2000A data.</li></ul><p>If <code>data_type</code> is omitted, then it defaults to <code>IAU1980</code>.</p><p>The files are downloaded using the <code>RemoteFile</code> package with daily updates. Hence, if one desires to force a download before the scheduled time, then set the keyword <code>force_download</code> to <code>true</code>.</p><p><strong>Returns</strong></p><p>A structure (<code>EOPData_IAU1980</code> or <code>EOPData_IAU2000A</code>, depending on <code>data_type</code>) with the interpolations of the EOP parameters. Notice that the interpolation indexing is set to the Julian Day.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaSpace/SatelliteToolbox.jl/blob/c7a891ae8cbd18d844cb2ba648927c3c6dfa564f/src/transformations/eop.jl#L45-L66">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="SatelliteToolbox.get_iers_eop_iau_1980" href="#SatelliteToolbox.get_iers_eop_iau_1980"><code>SatelliteToolbox.get_iers_eop_iau_1980</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">get_iers_eop_iau_1980(url::String = &quot;https://datacenter.iers.org/data/latestVersion/223_EOP_C04_14.62-NOW.IAU1980223.txt&quot;)</code></pre><p>Get the IERS EOP C04 IAU1980 data from the URL <code>url</code>. If <code>url</code> is omitted, then it defaults to https://datacenter.iers.org/data/latestVersion/223<em>EOP</em>C04_14.62-NOW.IAU1980223.txt</p><p>The file is downloaded using the <code>RemoteFile</code> package with daily updates. Hence, if one desires to force a download before the scheduled time, then set the keyword <code>force_download</code> to <code>true</code>.</p><p><strong>Returns</strong></p><p>The structure <code>EOPData_IAU1980</code> with the interpolations of the EOP parameters. Notice that the interpolation indexing is set to the Julian Day.</p><p><strong>Remarks</strong></p><p>For every field in <code>EOPData_IAU1980</code> to interpolation between two points in the grid is linear. If extrapolation is needed, then if will use the nearest value (flat extrapolation).</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaSpace/SatelliteToolbox.jl/blob/c7a891ae8cbd18d844cb2ba648927c3c6dfa564f/src/transformations/eop.jl#L77-L98">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="SatelliteToolbox.get_iers_eop_iau_2000A" href="#SatelliteToolbox.get_iers_eop_iau_2000A"><code>SatelliteToolbox.get_iers_eop_iau_2000A</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">get_iers_eop_iau_2000A(url::String = &quot;https://datacenter.iers.org/data/latestVersion/224_EOP_C04_14.62-NOW.IAU2000A224.txt&quot;; force_download = false)</code></pre><p>Get the IERS EOP C04 IAU2000A data from the URL <code>url</code>. If <code>url</code> is omitted, then it defaults to https://datacenter.iers.org/data/latestVersion/224<em>EOP</em>C04_14.62-NOW.IAU2000A224.txt</p><p>The file is downloaded using the <code>RemoteFile</code> package with daily updates. Hence, if one desires to force a download before the scheduled time, then set the keyword <code>force_download</code> to <code>true</code>.</p><p><strong>Returns</strong></p><p>The structure <code>EOPData_IAU2000A</code> with the interpolations of the EOP parameters. Notice that the interpolation indexing is set to the Julian Day.</p><p><strong>Remarks</strong></p><p>For every field in <code>EOPData_IAU2000A</code> to interpolation between two points in the grid is linear. If extrapolation is needed, then if will use the nearest value (flat extrapolation).</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaSpace/SatelliteToolbox.jl/blob/c7a891ae8cbd18d844cb2ba648927c3c6dfa564f/src/transformations/eop.jl#L115-L136">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="SatelliteToolbox.get_mean_elements-Tuple{OrbitPropagator}" href="#SatelliteToolbox.get_mean_elements-Tuple{OrbitPropagator}"><code>SatelliteToolbox.get_mean_elements</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">get_mean_elements(orbp)</code></pre><p>Return the mean elements of the latest propagation performed by <code>orbp</code>. This is an optinal function in the API. It will return <code>nothing</code> if the propagator does not support it.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaSpace/SatelliteToolbox.jl/blob/c7a891ae8cbd18d844cb2ba648927c3c6dfa564f/src/orbit/propagators/api/api.jl#L30-L37">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="SatelliteToolbox.get_r" href="#SatelliteToolbox.get_r"><code>SatelliteToolbox.get_r</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">get_r(orb)</code></pre><p>Return the position vector of the representation <code>orb</code> [m].</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaSpace/SatelliteToolbox.jl/blob/c7a891ae8cbd18d844cb2ba648927c3c6dfa564f/src/orbit/representations/api.jl#L96-L101">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="SatelliteToolbox.get_raan-Tuple{Any}" href="#SatelliteToolbox.get_raan-Tuple{Any}"><code>SatelliteToolbox.get_raan</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">get_raan(orb)</code></pre><p>Return the right ascention of the ascending node (RAAN) of the orbit representation <code>orb</code> [rad].</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaSpace/SatelliteToolbox.jl/blob/c7a891ae8cbd18d844cb2ba648927c3c6dfa564f/src/orbit/representations/api.jl#L71-L77">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="SatelliteToolbox.get_rv" href="#SatelliteToolbox.get_rv"><code>SatelliteToolbox.get_rv</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">get_rv(orb)</code></pre><p>Return the position and velocity vector of the representation <code>orb</code> [m].</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaSpace/SatelliteToolbox.jl/blob/c7a891ae8cbd18d844cb2ba648927c3c6dfa564f/src/orbit/representations/api.jl#L112-L117">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="SatelliteToolbox.get_space_index-Tuple{Val{:F10}, Number}" href="#SatelliteToolbox.get_space_index-Tuple{Val{:F10}, Number}"><code>SatelliteToolbox.get_space_index</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">get_space_index(T, JD::Number; ...)</code></pre><p>Return the space index <code>T</code> at the day <code>JD</code> [Julian Day]. <code>T</code> can be:</p><p><strong>Daily 10.7-cm solar flux</strong></p><p>The daily 10.7-cm solar flux can be obtained using:</p><ul><li><code>F10()</code>: 10.7-cm adjusted solar flux [10⁻²² W/(M² Hz)].</li><li><code>F10adj()</code>: 10.7-cm adjusted solar flux [10⁻²² W/(M² Hz)].</li><li><code>F10obs()</code>: 10.7-cm observed solar flux [10⁻²² W/(M² Hz)].</li></ul><p>These indices require <code>fluxtable</code> (see <code>init_space_indices</code>).</p><p><strong>Daily average 10.7-cm solar flux</strong></p><p>The daily average 10.7-cm solar flux, centered at <code>JD</code>, can be obtained using:</p><ul><li><code>F10M()</code>: 10.7-cm adjusted solar flux [10⁻²² W/(M² Hz)].</li><li><code>F10Madj()</code>: 10.7-cm adjusted solar flux [10⁻²² W/(M² Hz)].</li><li><code>F10Mobs()</code>: 10.7-cm observed solar flux [10⁻²² W/(M² Hz)].</li></ul><p>In this case, the keyword <code>window::Int</code> can be passed to select the size of the window. By default, it is selected as 81.</p><p>These indices require <code>fluxtable</code> (see <code>init_space_indices</code>).</p><p><strong>Daily Kp and Ap</strong></p><ul><li><code>Kp()</code>: Kp index (daily mean).</li><li><code>Kp_vect()</code>: A vector containing the Kp index for the following hours of the              day: 0-3h, 3-6h, 6-9h, 9-12h, 12-15h, 15-18h, 18-20h, 20-23h.</li><li><code>Ap()</code>: Ap index (daily mean).</li><li><code>Ap_vect()</code>: A vector containing the Ap index for the following hours of the              day: 0-3h, 3-6h, 6-9h, 9-12h, 12-15h, 15-18h, 18-20h, 20-23h.</li></ul><p>These indices require <code>wdcfiles</code> (see <code>init_space_indices</code>).</p><p><strong>Daily S10, M10, and Y10</strong></p><ul><li><code>S10()</code>: EUV index (26-34 nm) scaled to F10.7.</li><li><code>M10()</code>: MG2 index scaled to F10.7.</li><li><code>Y10()</code>: Solar X-ray &amp; Lya index scaled to F10.7.</li></ul><p>These indices require <code>solfsmy</code> (see <code>init_space_indices</code>).</p><p><strong>81-day centered average of S10, M10, and Y10.</strong></p><ul><li><code>S81a</code>: EUV 81-day averaged centered index.</li><li><code>M81a</code>: MG2 81-day averaged centered index.</li><li><code>Y81a</code>: Solar X-ray &amp; Lya 81-day averaged centered index.</li></ul><p>These indices require <code>solfsmy</code> (see <code>init_space_indices</code>).</p><p><strong>Exospheric temperature variation due to Dst</strong></p><ul><li><code>DstΔTc</code>: Exospheric temperature variation due to <code>Dst</code> [K].</li></ul><p>This index requires <code>dtcfile</code> (see <code>init_space_indices</code>).</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaSpace/SatelliteToolbox.jl/blob/c7a891ae8cbd18d844cb2ba648927c3c6dfa564f/src/earth/space_indices/space_indices.jl#L44-L105">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="SatelliteToolbox.get_v" href="#SatelliteToolbox.get_v"><code>SatelliteToolbox.get_v</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">get_r(orb)</code></pre><p>Return the velocity vector of the representation <code>orb</code> [m].</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaSpace/SatelliteToolbox.jl/blob/c7a891ae8cbd18d844cb2ba648927c3c6dfa564f/src/orbit/representations/api.jl#L104-L109">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="SatelliteToolbox.get_Δat-Tuple{Number}" href="#SatelliteToolbox.get_Δat-Tuple{Number}"><code>SatelliteToolbox.get_Δat</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">get_Δat(JD::Number)</code></pre><p>Get the accumulated leap seconds (ΔAT) [s] between UTC and International Atomic Time (TAI) in the given <code>JD</code>. This function search for ΔAT in the array <code>ΔAT_Data</code>.</p><p><strong>Remarks</strong></p><p>If <code>JD</code> is before <code>ΔAT_Data[1,1]</code>, then 10 will be returned. <strong>Notice that this can lead to errors.</strong></p><p>If <code>JD</code> is after <code>ΔAT_Data[end,1]</code>, then <code>ΔAT_Data[end,2]</code> will be returned, because it is not possible yet to predict when leap seconds will be added.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaSpace/SatelliteToolbox.jl/blob/c7a891ae8cbd18d844cb2ba648927c3c6dfa564f/src/time/time.jl#L63-L78">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="SatelliteToolbox.get_Ω" href="#SatelliteToolbox.get_Ω"><code>SatelliteToolbox.get_Ω</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">get_Ω(orb)</code></pre><p>Return the right ascention of the ascending node (RAAN) of the orbit representation <code>orb</code> [rad].</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaSpace/SatelliteToolbox.jl/blob/c7a891ae8cbd18d844cb2ba648927c3c6dfa564f/src/orbit/representations/api.jl#L46-L52">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="SatelliteToolbox.get_ω" href="#SatelliteToolbox.get_ω"><code>SatelliteToolbox.get_ω</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">get_ω(orb)</code></pre><p>Return the argument of periapsis of the representation <code>orb</code> [rad].</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaSpace/SatelliteToolbox.jl/blob/c7a891ae8cbd18d844cb2ba648927c3c6dfa564f/src/orbit/representations/api.jl#L55-L60">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="SatelliteToolbox.ground_station_accesses-Tuple{Any, Tuple, Vararg{Any, N} where N}" href="#SatelliteToolbox.ground_station_accesses-Tuple{Any, Tuple, Vararg{Any, N} where N}"><code>SatelliteToolbox.ground_station_accesses</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">ground_station_accesses(orbp, vrs_e,     Δt, ECI, ECEF, vargs...; kwargs...)
ground_station_accesses(orbp, [(WGS84)], Δt, ECI, ECEF, vargs...; kwargs...)</code></pre><p>Compute the accesses of a satellite with orbit propagator <code>orbp</code> (see <code>init_orbit_propagator</code>) to the ground stations defined in the vector <code>vrs_e</code>. The analysis interval begins in the propagator epoch and lasts <code>Δt</code> [s].</p><p>The ground stations can be specified by an array of 3×1 vectors describing the ground stations position in an ECEF frame <code>vrs_e</code> or by an array of tuples containing the WGS84 position of each ground station <code>[(WGS84)]</code>:</p><pre><code class="language-none">(latitude [rad], longitude [rad], altitude [m])</code></pre><p><strong>Args</strong></p><ul><li><code>ECI</code>: Earth-Centered Inertial frame in which the state vector of the        propagator is represented.</li><li><code>ECEF</code>: Earth-Centered, Earth-fixed frame to be used for the analysis. It         must be the same frame used to compute the ground station position         vector.</li><li><code>vargs...</code>: list of additional arguments to be passed to the function             <code>r_eci_to_ecef</code> when converting the ECI frame to the ECEF.</li></ul><p><strong>Keywords</strong></p><ul><li><code>θ</code>: Minimum elevation angle for communication between the satellite and the      ground stations [rad]. (<strong>Default</strong> = 10ᵒ)</li><li><code>reduction</code>: A function that receives a boolean vector with the visibility              between the satellite and each ground station. It must return a              boolean value indicating if the access must be computed or not.              This is useful to merge access time between two or more stations.              (<strong>Default</strong> = <code>v-&gt;|(v...)</code> <em>i.e.</em> compute the access if at least              one ground station is visible)</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaSpace/SatelliteToolbox.jl/blob/c7a891ae8cbd18d844cb2ba648927c3c6dfa564f/src/analysis/ground_stations.jl#L14-L49">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="SatelliteToolbox.ground_station_gaps-Tuple{Any, Vararg{Any, N} where N}" href="#SatelliteToolbox.ground_station_gaps-Tuple{Any, Vararg{Any, N} where N}"><code>SatelliteToolbox.ground_station_gaps</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">ground_station_gaps(args...; kwargs...)</code></pre><p>Compute the gaps between the accesses of ground stations. The arguments and keywords are the same as the ones used in the function <code>ground_station_accesses</code>.</p><p>Notice that the gap analysis starts in the orbit propagator epoch and ends in the instant defined by the argument <code>Δt</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaSpace/SatelliteToolbox.jl/blob/c7a891ae8cbd18d844cb2ba648927c3c6dfa564f/src/analysis/ground_stations.jl#L139-L149">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="SatelliteToolbox.ground_station_visible-Tuple{AbstractVector{T} where T, AbstractVector{T} where T, Number}" href="#SatelliteToolbox.ground_station_visible-Tuple{AbstractVector{T} where T, AbstractVector{T} where T, Number}"><code>SatelliteToolbox.ground_station_visible</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">ground_station_visible(r_e::AbstractVector, rs_e::AbstractVector, θ::Number)</code></pre><p>Check if the satellite with position vector <code>r_e</code> (ECEF) is inside the visibility circle of a ground station with position vector <code>rs_e</code> (ECEF) and a minimum elevation angle of <code>θ</code> [rad].</p><p>Notice that <code>r_e</code> and <code>rs_e</code> must be represented in the same ECEF frame, and must have the same unit.</p><p>Returns <code>true</code> if the satellite is inside the visibility circle, or <code>false</code> otherwise.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaSpace/SatelliteToolbox.jl/blob/c7a891ae8cbd18d844cb2ba648927c3c6dfa564f/src/analysis/ground_stations.jl#L373-L386">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="SatelliteToolbox.ground_station_visible-Tuple{AbstractVector{T} where T, Number, Number, Number, Number}" href="#SatelliteToolbox.ground_station_visible-Tuple{AbstractVector{T} where T, Number, Number, Number, Number}"><code>SatelliteToolbox.ground_station_visible</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">ground_station_visible(r_e::AbstractVector, lat_s::Number, lon_s::Number, h_s::Number, θ::Number)</code></pre><p>Check if the satellite with position vector <code>r_e</code> (ECEF) is inside the visibility circle of a ground station with latitude <code>lat_s</code> [rad], longitude <code>lon_s</code> [rad], altitude <code>h_s</code> (WGS-84), and a minimum elevation angle of <code>θ</code> [rad].</p><p>Notice that the units of <code>r_e</code> and <code>h_s</code> must be the same.</p><p>Returns <code>true</code> if the satellite is inside the visibility circle, or <code>false</code> otherwise.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaSpace/SatelliteToolbox.jl/blob/c7a891ae8cbd18d844cb2ba648927c3c6dfa564f/src/analysis/ground_stations.jl#L397-L410">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="SatelliteToolbox.ground_trace-Tuple{OrbitPropagator, Number}" href="#SatelliteToolbox.ground_trace-Tuple{OrbitPropagator, Number}"><code>SatelliteToolbox.ground_trace</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">ground_trace(orbp::OrbitPropagator, Δt::Number; kwargs...)</code></pre><p>Compute the ground trace of the object with orbit defined by <code>orbp</code> by propagating the orbit by <code>Δt</code> [s] from the orbit epoch.</p><p>By default, it considers that the orbit elements on the propagator are represented in the True Equator, Mean Equinox (TEME) reference frame and the ground trace will be computed in the Pseudo-Earth Fixed (PEF) reference frame. Hence, no EOP data is needed. However, this can be changed by the keywords presented as follows.</p><p><strong>Keywords</strong></p><ul><li><code>eop_data</code>: EOP data that will be used to convert the ECI reference frame to             the ECEF reference frame. If <code>nothing</code>, then it will not be used             (see <code>r_eci_to_ecef</code>). (<strong>Default</strong> = <code>nothing</code>)</li><li><code>ECI</code>: ECI frame in which the orbit elements in <code>orbp</code> are represented.        (<strong>Default</strong> = <code>TEME()</code>)</li><li><code>ECEF</code>: ECEF frame that will be used to compute the ground trace.         (<strong>Default</strong> = <code>PEF()</code>)</li><li><code>dt</code>: Time interval between two samples [s]. (<strong>Default</strong> = 10.0)</li></ul><p><strong>Returns</strong></p><p>A vector of tuples with the pairs <code>(latitude,longitude)</code> of the ground trace.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaSpace/SatelliteToolbox.jl/blob/c7a891ae8cbd18d844cb2ba648927c3c6dfa564f/src/analysis/ground_trace.jl#L11-L38">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="SatelliteToolbox.gtd7-Union{Tuple{NRLMSISE00_Structure{T}}, Tuple{T}} where T&lt;:Number" href="#SatelliteToolbox.gtd7-Union{Tuple{NRLMSISE00_Structure{T}}, Tuple{T}} where T&lt;:Number"><code>SatelliteToolbox.gtd7</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">gtd7(nrlmsise00d::NRLMSISE00_Structure{T}) where T&lt;:Number</code></pre><p><strong>NRLMSISE-00</strong></p><p>Neutral Atmosphere Empirical Model from the surface to lower exosphere.</p><p>This routine computes the NRLMSISE-00 outputs (see <code>NRLMSISE00_Output</code>) using the configurations in the structure <code>nrlmsise00</code> (see <code>NRLMSISE00_Structure</code>).</p><p><strong>Args</strong></p><ul><li><code>nrlmsise00d</code>: An instance of <code>NRLMSISE00_Structure</code>.</li></ul><p><strong>Returns</strong></p><p>An instance of structure <code>NRLMSISE00_Output</code> with the outputs.</p><p>In this case, the total mass <code>den_Total</code> (see <code>NRLMSISE00_Output</code>) is the sum of the mass densities of the species <code>He</code>, <code>O</code>, <code>N₂</code>, <code>O₂</code>, <code>Ar</code>, <code>H</code>, and <code>N</code>, but <strong>does not</strong> include anomalous oxygen.</p><p><strong>Remarks</strong></p><ol><li>The densities of <code>O</code>, <code>H</code>, and <code>N</code> are set to <code>0</code> below <code>72.5 km</code>.</li><li>The exospheric temperature <code>T_exo</code> is set to global average for altitudes below <code>120 km</code>. The <code>120 km</code> gradient is left at global average value for altitudes below <code>72.5 km</code>.</li><li>Anomalous oxygen is defined as hot atomic oxygen or ionized oxygen that can become appreciable at high altitudes (<code>&gt; 500 km</code>) for some ranges of inputs, thereby affection drag on satellites and debris. We group these species under the term <strong>Anomalous Oxygen</strong>, since their individual variations are not presently separable with the drag data used to define this model component.</li></ol></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaSpace/SatelliteToolbox.jl/blob/c7a891ae8cbd18d844cb2ba648927c3c6dfa564f/src/earth/atmospheric_models/nrlmsise00/nrlmsise00.jl#L422-L456">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="SatelliteToolbox.gtd7d-Union{Tuple{NRLMSISE00_Structure{T}}, Tuple{T}} where T&lt;:Number" href="#SatelliteToolbox.gtd7d-Union{Tuple{NRLMSISE00_Structure{T}}, Tuple{T}} where T&lt;:Number"><code>SatelliteToolbox.gtd7d</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">gtd7d(nrlmsise00d::NRLMSISE00_Structure{T}) where T&lt;:Number</code></pre><p><strong>NRLMSISE-00</strong></p><p>Neutral Atmosphere Empirical Model from the surface to lower exosphere.</p><p>This routine computes the NRLMSISE-00 outputs (see <code>NRLMSISE00_Output</code>) using the configurations in the structure <code>nrlmsise00</code> (see <code>NRLMSISE00_Structure</code>).</p><p><strong>Args</strong></p><ul><li><code>nrlmsise00d</code>: An instance of <code>NRLMSISE00_Structure</code>.</li></ul><p><strong>Returns</strong></p><p>An instance of structure <code>NRLMSISE00_Output</code> with the outputs.</p><p>In this case, the total mass <code>den_Total</code> (see <code>NRLMSISE00_Output</code>) is the effective total mass density for drag and is the sum of the mass densities of all species in this model <strong>including</strong> the anomalous oxygen.</p><p><strong>Remarks</strong></p><ol><li>The densities of <code>O</code>, <code>H</code>, and <code>N</code> are set to <code>0</code> below <code>72.5 km</code>.</li><li>The exospheric temperature <code>T_exo</code> is set to global average for altitudes below <code>120 km</code>. The <code>120 km</code> gradient is left at global average value for altitudes below <code>72.5 km</code>.</li><li>Anomalous oxygen is defined as hot atomic oxygen or ionized oxygen that can become appreciable at high altitudes (<code>&gt; 500 km</code>) for some ranges of inputs, thereby affection drag on satellites and debris. We group these species under the term <strong>Anomalous Oxygen</strong>, since their individual variations are not presently separable with the drag data used to define this model component.</li></ol></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaSpace/SatelliteToolbox.jl/blob/c7a891ae8cbd18d844cb2ba648927c3c6dfa564f/src/earth/atmospheric_models/nrlmsise00/nrlmsise00.jl#L635-L669">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="SatelliteToolbox.gts7-Union{Tuple{NRLMSISE00_Structure{T}}, Tuple{T}} where T&lt;:Number" href="#SatelliteToolbox.gts7-Union{Tuple{NRLMSISE00_Structure{T}}, Tuple{T}} where T&lt;:Number"><code>SatelliteToolbox.gts7</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">gts7(nrlmsise00d::NRLMSISE00_Structure{T}) where T&lt;:Number</code></pre><p>Thermospheric portion of NRLMSISE-00. This function should not be called to compute NRLMSISE-00. Use <code>gtd7</code> or <code>gtd7d</code> instead.</p><p><strong>Args</strong></p><ul><li><code>nrlmsise00d</code>: An instance of <code>NRLMSISE00_Structure</code>.</li></ul><p><strong>Returns</strong></p><p>An instance of structure <code>NRLMSISE00_Structure</code> with the outputs.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaSpace/SatelliteToolbox.jl/blob/c7a891ae8cbd18d844cb2ba648927c3c6dfa564f/src/earth/atmospheric_models/nrlmsise00/nrlmsise00_priv.jl#L741-L755">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="SatelliteToolbox.igrf-NTuple{4, Number}" href="#SatelliteToolbox.igrf-NTuple{4, Number}"><code>SatelliteToolbox.igrf</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">igrf(date::Number, [r,h]::Number, λ::Number, Ω::Number, T[, P, dP]; show_warns = true)</code></pre><p><strong>IGRF Model</strong></p><p><em>Current version: v13</em></p><p>Compute the geomagnetic field vector [nT] at the date <code>date</code> [Year A.D.] and position (<code>r</code>, <code>λ</code>, <code>Ω</code>).</p><p>The position representation is defined by <code>T</code>. If <code>T</code> is <code>Val(:geocentric)</code>, then the input must be <strong>geocentric</strong> coordinates:</p><ol><li>Distance from the Earth center <code>r</code> [m];</li><li>Geocentric latitude <code>λ</code> (-π/2, +π/2) [rad]; and</li><li>Geocentric longitude <code>Ω</code> (-π, +π) [rad].</li></ol><p>If <code>T</code> is <code>Val(:geodetic)</code>, then the input must be <strong>geodetic</strong> coordinates:</p><p>1 Altitude above the reference ellipsoid <code>h</code> (WGS-84) [m];</p><ol><li>Geodetic latitude <code>λ</code> (-π/2, +π/2) [rad]; and</li><li>Geodetic longitude <code>Ω</code> (-π, +π) [rad].</li></ol><p>If <code>T</code> is omitted, then it defaults to <code>Val(:geocentric)</code>.</p><p>Notice that the output vector will be represented in the same reference system selected by the parameter <code>T</code> (geocentric or geodetic). The Y-axis of the output reference system always points East. In case of <strong>geocentric coordinates</strong>, the Z-axis points toward the center of Earth and the X-axis completes a right-handed coordinate system. In case of <strong>geodetic coordinates</strong>, the X-axis is tangent to the ellipsoid at the selected location and points toward North, whereas the Z-axis completes a right-hand coordinate system.</p><p>The optional arguments <code>P</code> and <code>dP</code> must be two matrices with at least 14x14 real numbers. If they are present, then they will be used to store the Legendre coefficients and their derivatives. In this case, no allocation will be performed when computing the magnetic field. If they are not present, then 2 allocations will happen to create them.</p><p><strong>Keywords</strong></p><ul><li><code>show_warns</code>: Show warnings about the data (<strong>Default</strong> = <code>true</code>).</li></ul><p><strong>Remarks</strong></p><p>The <code>date</code> must be greater or equal to 1900 and less than or equal 2030. Notice that a warning message is printed for dates greater than 2025.</p><p><strong>Disclaimer</strong></p><p>This function is an independent implementation of the IGRF model. It contains a more readable code than the original one in FORTRAN, because it uses features available in Julia language.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaSpace/SatelliteToolbox.jl/blob/c7a891ae8cbd18d844cb2ba648927c3c6dfa564f/src/earth/geomagnetic_field_models/igrf/igrf.jl#L112-L166">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="SatelliteToolbox.igrf12syn-Tuple{Int64, Number, Int64, Number, Number, Number}" href="#SatelliteToolbox.igrf12syn-Tuple{Int64, Number, Int64, Number, Number, Number}"><code>SatelliteToolbox.igrf12syn</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">igrf12syn(isv::Int, date::Number, itype::Int, alt::Number, colat::Number, elong::Number; show_warns = true)</code></pre><p>This is a Julia implementation of the official IGRF source code, which was written in Fortran [2]. The input and output variables are exactly the same as the ones described in the function <code>igrf12syn</code> in [2].</p><p><strong>Args</strong></p><ul><li><code>isv</code>: <code>0</code> if main-field values are required, <code>1</code> if secular variation values        are required.</li><li><code>date</code>: Year A.D.</li><li><code>itype</code>: <code>1</code> if geodetic (spheroid), <code>2</code> if geocentric (sphere).</li><li><code>alt</code>: Height above sea level [km] if <code>itype = 1</code>, or distance from the center of        Earth [km] if <code>itype = 2</code> (must be &gt; 3485 km).</li><li><code>colat</code>: Colatitude (0 - 180) [˚].</li><li><code>elong</code>: East-Longitude (0 - 360) [˚].</li></ul><p><strong>Keywords</strong></p><ul><li><code>show_warns</code>: Show warnings about the data (<strong>Default</strong> = <code>true</code>).</li></ul><p><strong>Returns</strong></p><ul><li>The north component [nT] if <code>isv = 0</code>, or [nT/year] if <code>isv = 1</code>.</li><li>The east component [nT] if <code>isv = 0</code>, or [nT/year] if <code>isv = 1</code>.</li><li>The vertical component [nT] if <code>isv = 0</code>, or [nT/year] if <code>isv = 1</code>.</li><li>The total intensity if <code>isv = 0</code>, or rubbish if <code>isv = 1</code>.</li></ul><p><strong>Remarks</strong></p><ul><li>The <code>date</code> must be greater or equal to 1900 and less than or equal 2025. Notice that a warning message is printed for dates grated than 2020.</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaSpace/SatelliteToolbox.jl/blob/c7a891ae8cbd18d844cb2ba648927c3c6dfa564f/src/earth/geomagnetic_field_models/igrf/igrf12/igrf12syn.jl#L18-L52">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="SatelliteToolbox.igrf13syn-Tuple{Int64, Number, Int64, Number, Number, Number}" href="#SatelliteToolbox.igrf13syn-Tuple{Int64, Number, Int64, Number, Number, Number}"><code>SatelliteToolbox.igrf13syn</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">igrf13syn(isv::Int, date::Number, itype::Int, alt::Number, colat::Number, elong::Number; show_warns = true)</code></pre><p>This is a Julia implementation of the official IGRF source code, which was written in Fortran [2]. The input and output variables are exactly the same as the ones described in the function <code>igrf13syn</code> in [2].</p><p><strong>Args</strong></p><ul><li><code>isv</code>: <code>0</code> if main-field values are required, <code>1</code> if secular variation values        are required.</li><li><code>date</code>: Year A.D.</li><li><code>itype</code>: <code>1</code> if geodetic (spheroid), <code>2</code> if geocentric (sphere).</li><li><code>alt</code>: Height above sea level [km] if <code>itype = 1</code>, or distance from the center of        Earth [km] if <code>itype = 2</code> (must be &gt; 3485 km).</li><li><code>colat</code>: Colatitude (0 - 180) [˚].</li><li><code>elong</code>: East-Longitude (0 - 360) [˚].</li></ul><p><strong>Keywords</strong></p><ul><li><code>show_warns</code>: Show warnings about the data (<strong>Default</strong> = <code>true</code>).</li></ul><p><strong>Returns</strong></p><ul><li>The north component [nT] if <code>isv = 0</code>, or [nT/year] if <code>isv = 1</code>.</li><li>The east component [nT] if <code>isv = 0</code>, or [nT/year] if <code>isv = 1</code>.</li><li>The vertical component [nT] if <code>isv = 0</code>, or [nT/year] if <code>isv = 1</code>.</li><li>The total intensity if <code>isv = 0</code>, or rubbish if <code>isv = 1</code>.</li></ul><p><strong>Remarks</strong></p><ul><li>The <code>date</code> must be greater or equal to 1900 and less than or equal 2030. Notice that a warning message is printed for dates grated than 2025.</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaSpace/SatelliteToolbox.jl/blob/c7a891ae8cbd18d844cb2ba648927c3c6dfa564f/src/earth/geomagnetic_field_models/igrf/igrf13/igrf13syn.jl#L20-L54">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="SatelliteToolbox.igrfd-NTuple{4, Number}" href="#SatelliteToolbox.igrfd-NTuple{4, Number}"><code>SatelliteToolbox.igrfd</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">igrfd(date::Number, [r,h]::Number, λ::Number, Ω::Number, T[, P, dP]; show_warns = true)</code></pre><p><strong>IGRF Model</strong></p><p><em>Current version: v13</em></p><p>Compute the geomagnetic field vector [nT] at the date <code>date</code> [Year A.D.] and position (<code>r</code>, <code>λ</code>, <code>Ω</code>).</p><p>The position representation is defined by <code>T</code>. If <code>T</code> is <code>Val(:geocentric)</code>, then the input must be <strong>geocentric</strong> coordinates:</p><ol><li>Distance from the Earth center <code>r</code> [m];</li><li>Geocentric latitude <code>λ</code> (-90°, +90°); and</li><li>Geocentric longitude <code>Ω</code> (-180°, +180°).</li></ol><p>If <code>T</code> is <code>Val(:geodetic)</code>, then the input must be <strong>geodetic</strong> coordinates:</p><p>1 Altitude above the reference ellipsoid <code>h</code> (WGS-84) [m];</p><ol><li>Geodetic latitude <code>λ</code> (-90°, +90°); and</li><li>Geodetic longitude <code>Ω</code> (-180°, +180°).</li></ol><p>If <code>T</code> is omitted, then it defaults to <code>Val(:geocentric)</code>.</p><p>Notice that the output vector will be represented in the same reference system selected by the parameter <code>T</code> (geocentric or geodetic). The Y-axis of the output reference system always points East. In case of <strong>geocentric coordinates</strong>, the Z-axis points toward the center of Earth and the X-axis completes a right-handed coordinate system. In case of <strong>geodetic coordinates</strong>, the X-axis is tangent to the ellipsoid at the selected location and points toward North, whereas the Z-axis completes a right-hand coordinate system.</p><p>The optional arguments <code>P</code> and <code>dP</code> must be two matrices with at least 14x14 real numbers. If they are present, then they will be used to store the Legendre coefficients and their derivatives. In this case, no allocation will be performed when computing the magnetic field. If they are not present, then 2 allocations will happen to create them.</p><p><strong>Keywords</strong></p><ul><li><code>show_warns</code>: Show warnings about the data (<strong>Default</strong> = <code>true</code>).</li></ul><p><strong>Remarks</strong></p><p>The <code>date</code> must be greater or equal to 1900 and less than or equal 2030. Notice that a warning message is printed for dates greater than 2025.</p><p><strong>Disclaimer</strong></p><p>This function is an independent implementation of the IGRF model. It contains a more readable code than the original one in FORTRAN, because it uses features available in Julia language.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaSpace/SatelliteToolbox.jl/blob/c7a891ae8cbd18d844cb2ba648927c3c6dfa564f/src/earth/geomagnetic_field_models/igrf/igrf.jl#L23-L77">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="SatelliteToolbox.init_orbit_propagator" href="#SatelliteToolbox.init_orbit_propagator"><code>SatelliteToolbox.init_orbit_propagator</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">init_orbit_propagator(T, args...; kwargs...)</code></pre><p>Initialize the orbit propagator of type <code>T</code>. The arguments <code>args</code> and keywords <code>kwargs</code> depends of the propagator type.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaSpace/SatelliteToolbox.jl/blob/c7a891ae8cbd18d844cb2ba648927c3c6dfa564f/src/orbit/propagators/api/api.jl#L13-L19">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="SatelliteToolbox.init_orbit_propagator-Union{Tuple{T}, Tuple{Val{:J2osc}, Number, Number, Number, Number, Number, Number, Number}, Tuple{Val{:J2osc}, Number, Number, Number, Number, Number, Number, Number, Number}, Tuple{Val{:J2osc}, Number, Number, Number, Number, Number, Number, Number, Number, Number}} where T" href="#SatelliteToolbox.init_orbit_propagator-Union{Tuple{T}, Tuple{Val{:J2osc}, Number, Number, Number, Number, Number, Number, Number}, Tuple{Val{:J2osc}, Number, Number, Number, Number, Number, Number, Number, Number}, Tuple{Val{:J2osc}, Number, Number, Number, Number, Number, Number, Number, Number, Number}} where T"><code>SatelliteToolbox.init_orbit_propagator</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">init_orbit_propagator(Val(:J2osc), epoch::Number, a_0::Number, e_0::Number, i_0::Number, Ω_0::Number, ω_0::Number, f_0::Number, dn_o2::Number = 0, ddn_o6::Number = 0; j2_gc::J2_GravCte{T} = j2_gc_egm08) where T
init_orbit_propagator(Val(:J2osc), orb_0::Orbit, dn_o2::Number = 0, ddn_o6::Number = 0; j2_gc::J2_GravCte = j2_gc_egm08)</code></pre><p>Initialize the J2 osculating orbit propagator.</p><p><strong>Args</strong></p><ul><li><code>epoch</code>: Initial orbit epoch [Julian Day].</li><li><code>a_0</code>: Initial mean semi-major axis [m].</li><li><code>e_0</code>: Initial mean eccentricity.</li><li><code>i_0</code>: Initial mean inclination [rad].</li><li><code>Ω_0</code>: Initial mean right ascension of the ascending node [rad].</li><li><code>ω_0</code>: Initial mean argument of perigee [rad].</li><li><code>f_0</code>: Initial mean true anomaly [rad].</li><li><code>dn_o2</code>: (OPTIONAL) First time derivative of mean motion divided by 2          [rad/s²] (<strong>Default</strong> = 0).</li><li><code>ddn_o6</code>: (OPTIONAL) Second time derivative of mean motion divided by 6           [rad/s³] (<strong>Default</strong> = 0).</li><li><code>orb_0</code>: Instance of the structure <code>KeplerianElements</code> with the initial mean          orbital elements [SI].</li></ul><p><strong>Keywords</strong></p><ul><li><code>j2_gc</code>: (OPTIONAL) J2 orbit propagator gravitational constants          (<strong>Default</strong> = <code>j2_gc_egm08</code>).</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaSpace/SatelliteToolbox.jl/blob/c7a891ae8cbd18d844cb2ba648927c3c6dfa564f/src/orbit/propagators/api/j2osc.jl#L25-L52">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="SatelliteToolbox.init_orbit_propagator-Union{Tuple{T}, Tuple{Val{:J2}, Number, Number, Number, Number, Number, Number, Number}, Tuple{Val{:J2}, Number, Number, Number, Number, Number, Number, Number, Number}, Tuple{Val{:J2}, Number, Number, Number, Number, Number, Number, Number, Number, Number}} where T" href="#SatelliteToolbox.init_orbit_propagator-Union{Tuple{T}, Tuple{Val{:J2}, Number, Number, Number, Number, Number, Number, Number}, Tuple{Val{:J2}, Number, Number, Number, Number, Number, Number, Number, Number}, Tuple{Val{:J2}, Number, Number, Number, Number, Number, Number, Number, Number, Number}} where T"><code>SatelliteToolbox.init_orbit_propagator</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">init_orbit_propagator(Val(:J2), epoch::Number, a_0::Number, e_0::Number, i_0::Number, Ω_0::Number, ω_0::Number, f_0::Number, dn_o2::Number = 0, ddn_o6::Number = 0; j2_gc::J2_GravCte{T} = j2_gc_egm08) where T
init_orbit_propagator(Val(:J2), orb_0::Orbit, dn_o2::Number = 0, ddn_o6::Number = 0; j2_gc::J2_GravCte = j2_gc_egm08)</code></pre><p>Initialize the J2 orbit propagator.</p><p><strong>Args</strong></p><ul><li><code>epoch</code>: Initial orbit epoch [Julian Day].</li><li><code>a_0</code>: Initial mean semi-major axis [m].</li><li><code>e_0</code>: Initial mean eccentricity.</li><li><code>i_0</code>: Initial mean inclination [rad].</li><li><code>Ω_0</code>: Initial mean right ascension of the ascending node [rad].</li><li><code>ω_0</code>: Initial mean argument of perigee [rad].</li><li><code>f_0</code>: Initial mean true anomaly [rad].</li><li><code>dn_o2</code>: (OPTIONAL) First time derivative of mean motion divided by 2          [rad/s²] (<strong>Default</strong> = 0).</li><li><code>ddn_o6</code>: (OPTIONAL) Second time derivative of mean motion divided by 6           [rad/s³] (<strong>Default</strong> = 0).</li><li><code>orb_0</code>: Instance of the structure <code>KeplerianElements</code> with the initial mean          orbital elements [SI].</li></ul><p><strong>Keywords</strong></p><ul><li><code>j2_gc</code>: (OPTIONAL) J2 orbit propagator gravitational constants          (<strong>Default</strong> = <code>j2_gc_egm08</code>).</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaSpace/SatelliteToolbox.jl/blob/c7a891ae8cbd18d844cb2ba648927c3c6dfa564f/src/orbit/propagators/api/j2.jl#L25-L52">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="SatelliteToolbox.init_orbit_propagator-Union{Tuple{T}, Tuple{Val{:J4}, Number, Number, Number, Number, Number, Number, Number}, Tuple{Val{:J4}, Number, Number, Number, Number, Number, Number, Number, Number}, Tuple{Val{:J4}, Number, Number, Number, Number, Number, Number, Number, Number, Number}} where T" href="#SatelliteToolbox.init_orbit_propagator-Union{Tuple{T}, Tuple{Val{:J4}, Number, Number, Number, Number, Number, Number, Number}, Tuple{Val{:J4}, Number, Number, Number, Number, Number, Number, Number, Number}, Tuple{Val{:J4}, Number, Number, Number, Number, Number, Number, Number, Number, Number}} where T"><code>SatelliteToolbox.init_orbit_propagator</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">init_orbit_propagator(Val(:J4), epoch::Number, a_0::Number, e_0::Number, i_0::Number, Ω_0::Number, ω_0::Number, f_0::Number, dn_o2::Number = 0, ddn_o6::Number = 0; j4_gc::J4_GravCte{T} = j4_gc_egm08) where T
init_orbit_propagator(Val(:J4), orb_0::Orbit, dn_o2::Number = 0, ddn_o6::Number = 0; j4_gc::J4_GravCte = j4_gc_egm08)</code></pre><p>Initialize the J4 orbit propagator.</p><p><strong>Args</strong></p><ul><li><code>epoch</code>: Initial orbit epoch [Julian Day].</li><li><code>a_0</code>: Initial mean semi-major axis [m].</li><li><code>e_0</code>: Initial mean eccentricity.</li><li><code>i_0</code>: Initial mean inclination [rad].</li><li><code>Ω_0</code>: Initial mean right ascension of the ascending node [rad].</li><li><code>ω_0</code>: Initial mean argument of perigee [rad].</li><li><code>f_0</code>: Initial mean true anomaly [rad].</li><li><code>dn_o2</code>: (OPTIONAL) First time derivative of mean motion divided by 2          [rad/s²] (<strong>Default</strong> = 0).</li><li><code>ddn_o6</code>: (OPTIONAL) Second time derivative of mean motion divided by 6           [rad/s³] (<strong>Default</strong> = 0).</li><li><code>orb_0</code>: Instance of the structure <code>KeplerianElements</code> with the initial mean          orbital elements [SI].</li></ul><p><strong>Keywords</strong></p><ul><li><code>j4_gc</code>: (OPTIONAL) J4 orbit propagator gravitational constants          (<strong>Default</strong> = <code>j4_gc_egm08</code>).</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaSpace/SatelliteToolbox.jl/blob/c7a891ae8cbd18d844cb2ba648927c3c6dfa564f/src/orbit/propagators/api/j4.jl#L25-L52">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="SatelliteToolbox.init_orbit_propagator-Union{Tuple{T}, Tuple{Val{:sgp4}, TLE}} where T" href="#SatelliteToolbox.init_orbit_propagator-Union{Tuple{T}, Tuple{Val{:sgp4}, TLE}} where T"><code>SatelliteToolbox.init_orbit_propagator</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">init_orbit_propagator(Val(:sgp4), tle::TLE, sgp4_gc::SGP4_GravCte{T} = sgp4_gc_wgs84) where T</code></pre><p>Initialize the SGP4 orbit propagator using the TLE <code>tle</code>.</p><p><strong>Keywords</strong></p><ul><li><code>sgp4_gc</code>: (OPTIONAL) Gravitational constants. (<strong>Default</strong> = <code>sgp4_gc_wgs84</code>)</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaSpace/SatelliteToolbox.jl/blob/c7a891ae8cbd18d844cb2ba648927c3c6dfa564f/src/orbit/propagators/api/sgp4.jl#L25-L34">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="SatelliteToolbox.init_orbit_propagator-Union{Tuple{T}, Tuple{Val{:twobody}, Number, Number, Number, Number, Number, Number, Number}} where T" href="#SatelliteToolbox.init_orbit_propagator-Union{Tuple{T}, Tuple{Val{:twobody}, Number, Number, Number, Number, Number, Number, Number}} where T"><code>SatelliteToolbox.init_orbit_propagator</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">init_orbit_propagator(::Val{:twobody}, epoch::Number, a_0::Number, e_0::Number, i_0::Number, Ω_0::Number, ω_0::Number, f_0::Number; μ::T = m0) where T</code></pre><p>Initialize the two body orbit propagator.</p><p><strong>Args</strong></p><ul><li><code>epoch</code>: Initial orbit epoch [Julian Day].</li><li><code>a_0</code>: Initial mean semi-major axis [m].</li><li><code>e_0</code>: Initial mean eccentricity.</li><li><code>i_0</code>: Initial mean inclination [rad].</li><li><code>Ω_0</code>: Initial mean right ascension of the ascending node [rad].</li><li><code>ω_0</code>: Initial mean argument of perigee [rad].</li><li><code>f_0</code>: Initial mean true anomaly [rad].</li><li><code>orb_0</code>: Instance of the structure <code>KeplerianElements</code> with the initial mean          orbital elements [SI].</li></ul><p><strong>Keywords</strong></p><ul><li><code>μ</code>: (OPTIONAL) Standard gravitational parameter of the central body      [m^3/s^2] (<strong>Default</strong> = <code>m0</code>).</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaSpace/SatelliteToolbox.jl/blob/c7a891ae8cbd18d844cb2ba648927c3c6dfa564f/src/orbit/propagators/api/twobody.jl#L25-L47">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="SatelliteToolbox.init_space_indices-Tuple{}" href="#SatelliteToolbox.init_space_indices-Tuple{}"><code>SatelliteToolbox.init_space_indices</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">init_space_indices(...)</code></pre><p>Initialize all space indices. The files that will be initialized must be indicated by the array of symbols passed to the keyword argument <code>enabled_files</code>. If this is <code>nothing</code>, which is the default, then all files will be initialized. The symbol related to each file is described next.</p><p>Notice that the initialization process can be changed by a set of keywords as described next.</p><p><strong>DTCFILE</strong></p><p><strong>Symbol</strong>: <code>:dtcfile</code></p><p>This file contains the exospheric temperature variation caused by the Dst index. This is used for the JB2008 atmospheric model.</p><p><strong>Keywords</strong></p><ul><li><code>dtcfile_path</code>: Path for the file <code>DTCFILE.TXT</code>. If <code>nothing</code>, then it will be                 downloaded. (<strong>Default</strong> = <code>nothing</code>)</li><li><code>dtcfile_force_download</code>: If <code>true</code>, then the file will always be downloaded                           if the path is not specified. (<strong>Default</strong> =                           <code>false</code>).</li></ul><p><strong>fluxtable</strong></p><p><strong>Symbol</strong>: <code>:fluxtable</code></p><p>This file contains the F10.7 flux data in different formats.</p><p><strong>Keywords</strong></p><ul><li><code>fluxtable_path</code>: Path for the file <code>fluxtable.txt</code>. If <code>nothing</code>, then it                   will be downloaded. (<strong>Default</strong> = <code>nothing</code>)</li><li><code>fluxtable_force_download</code>: If <code>true</code>, then the file will always be downloaded                             if the path is not specified.                             (<strong>Default</strong> = <code>false</code>).</li></ul><p><strong>SOLFSMY</strong></p><p><strong>Symbol</strong>: <code>:solfsmy</code></p><p>This files contains the indices necessary for the JB2008 atmospheric model.</p><p><strong>Keywords</strong></p><ul><li><code>solfsmy_path</code>: Path for the file <code>SOLFSMY.TXT</code>. If <code>nothing</code>, then it will be                 downloaded. (<strong>Default</strong> = <code>nothing</code>)</li><li><code>solfsmy_force_download</code>: If <code>true</code>, then the file will always be downloaded                           if the path is not specified. (<strong>Default</strong> =                           <code>false</code>).</li></ul><p><strong>WDC Files</strong></p><p><strong>Symbol</strong>: <code>:wdcfiles</code></p><p>This set of files contain the Kp and Ap indices.</p><p><strong>Keywords</strong></p><ul><li><code>wdcfiles_path</code>: Path for the directory with the WDC files. If <code>nothing</code>, then                  they will be downloaded. (<strong>Default</strong> = <code>nothing</code>)</li><li><code>wdcfiles_force_download</code>: If <code>true</code>, then the files will always be downloaded                           if the path is not specified. (<strong>Default</strong> =                           <code>false</code>).</li><li><code>wdcfiles_oldest_year</code>: Oldest year in which the WDC file will be obtained.                         (<strong>Default</strong> = past 3 years).</li><li><code>wdcfiles_newest_year</code>: Newest year in which the WDC file will be obtained. If                         it is <code>nothing</code>, then it defaults to the current year.                         (<strong>Default</strong> = <code>nothing</code>).</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaSpace/SatelliteToolbox.jl/blob/c7a891ae8cbd18d844cb2ba648927c3c6dfa564f/src/earth/space_indices/space_indices.jl#L185-L258">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="SatelliteToolbox.is_leap_year-Tuple{Integer}" href="#SatelliteToolbox.is_leap_year-Tuple{Integer}"><code>SatelliteToolbox.is_leap_year</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">is_leap_year(year::Integer)</code></pre><p>Check if the year <code>year</code> is a leap year. It returns <code>true</code> if <code>year</code> is a leap year, or <code>false</code> otherwise.</p><p><strong>Remarks</strong></p><p>This algorithm was based on [3].</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaSpace/SatelliteToolbox.jl/blob/c7a891ae8cbd18d844cb2ba648927c3c6dfa564f/src/time/time.jl#L175-L185">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="SatelliteToolbox.j2!-Union{Tuple{T}, Tuple{J2_Structure{T}, Number}} where T" href="#SatelliteToolbox.j2!-Union{Tuple{T}, Tuple{J2_Structure{T}, Number}} where T"><code>SatelliteToolbox.j2!</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">j2!(j2d::J2_Structure{T}, t::Number) where T</code></pre><p>Propagate the orbit defined in <code>j2d</code> (see <code>J2_Structure</code>) until the time <code>t</code> [s]. Notice that the values in <code>j2d</code> will be modified.</p><p><strong>Returns</strong></p><ul><li>The position vector represented in the inertial frame at time <code>t</code> [m].</li><li>The velocity vector represented in the inertial frame at time <code>t</code> [m/s]</li></ul><p><strong>Remarks</strong></p><p>The inertial frame in which the output is represented depends on which frame it was used to generate the orbit parameters. Notice that the perturbation theory requires an inertial frame with true equator.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaSpace/SatelliteToolbox.jl/blob/c7a891ae8cbd18d844cb2ba648927c3c6dfa564f/src/orbit/propagators/j2.jl#L180-L197">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="SatelliteToolbox.j2000_to_gmst-Tuple{Number}" href="#SatelliteToolbox.j2000_to_gmst-Tuple{Number}"><code>SatelliteToolbox.j2000_to_gmst</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">j2000_to_gmst(J2000_UT1::Number)</code></pre><p>Compute the Greenwich Mean Sideral Time (GMST) [rad] given the instant <code>J2000_UT1</code> in J2000.0 reference [UT1].</p><p><strong>Remarks</strong></p><p>Based on algorithm in <a href="http://www.navipedia.net/index.php/CEP_to_ITRF">2</a>, accessed at 2015-12-01.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaSpace/SatelliteToolbox.jl/blob/c7a891ae8cbd18d844cb2ba648927c3c6dfa564f/src/transformations/gmst.jl#L20-L31">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="SatelliteToolbox.j2_init-Union{Tuple{T}, NTuple{7, Number}, NTuple{8, Number}, NTuple{9, Number}} where T" href="#SatelliteToolbox.j2_init-Union{Tuple{T}, NTuple{7, Number}, NTuple{8, Number}, NTuple{9, Number}} where T"><code>SatelliteToolbox.j2_init</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">j2_init(epoch::Number, a_0::Number, e_0::Number, i_0::Number, Ω_0::Number, ω_0::Number, f_0::Number, dn_o2::Number = 0, ddn_o6::Number = 0; j2_gc::J2_GravCte{T} = j2_gc_egm08 ) where T</code></pre><p>Initialize the data structure of J2 orbit propagator algorithm.</p><p><strong>Args</strong></p><ul><li><code>epoch</code>: Epoch of the initial mean orbital elements [Julian Day].</li><li><code>a_0</code>: Initial mean semi-major axis [m].</li><li><code>e_0</code>: Initial mean eccentricity.</li><li><code>i_0</code>: Initial mean inclination [rad].</li><li><code>Ω_0</code>: Initial mean right ascension of the ascending node [rad].</li><li><code>ω_0</code>: Initial mean argument of perigee [rad].</li><li><code>f_0</code>: Initial mean true anomaly [rad].</li><li><code>dn_o2</code>: First time derivative of the mean motion divided by two [rad/s^2].</li><li><code>ddn_o6</code>: Second time derivative of the mean motion divided by six [rad/s^3].</li></ul><p><strong>Keywords</strong></p><ul><li><code>j2_gc</code>: J2 orbit propagator gravitational constants (see <code>J2_GravCte</code>).          (<strong>Default</strong> = <code>j2_gc_egm08</code>)</li></ul><p><strong>Returns</strong></p><p>The structure <code>J2_Structure</code> with the initialized parameters.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaSpace/SatelliteToolbox.jl/blob/c7a891ae8cbd18d844cb2ba648927c3c6dfa564f/src/orbit/propagators/j2.jl#L92-L118">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="SatelliteToolbox.j2osc!-Union{Tuple{T}, Tuple{SatelliteToolbox.J2osc_Structure{T}, Number}} where T" href="#SatelliteToolbox.j2osc!-Union{Tuple{T}, Tuple{SatelliteToolbox.J2osc_Structure{T}, Number}} where T"><code>SatelliteToolbox.j2osc!</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">j2osc!(j2d::J2osc_Structure{T}, t::Number) where T</code></pre><p>Propagate the orbit defined in <code>j2oscd</code> (see <code>J2osc_Structure</code>) until the time <code>t</code> [s]. Notice that the values in <code>j2oscd</code> will be modified.</p><p><strong>Returns</strong></p><ul><li>The position vector represented in the inertial frame at time <code>t</code> [m].</li><li>The velocity vector represented in the inertial frame at time <code>t</code> [m/s]</li></ul><p><strong>Remarks</strong></p><p>The inertial frame in which the output is represented depends on which frame it was used to generate the orbit parameters. Notice, however, that the perturbation theory requires an inertial frame with true equator.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaSpace/SatelliteToolbox.jl/blob/c7a891ae8cbd18d844cb2ba648927c3c6dfa564f/src/orbit/propagators/j2osc.jl#L75-L92">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="SatelliteToolbox.j2osc_init-Union{Tuple{T}, NTuple{9, Number}} where T" href="#SatelliteToolbox.j2osc_init-Union{Tuple{T}, NTuple{9, Number}} where T"><code>SatelliteToolbox.j2osc_init</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">j2osc_init(epoch::Number, a_0::Number, e_0::Number, i_0::Number, Ω_0::Number, ω_0::Number, f_0::Number, dn_o2::Number, ddn_o6::Number; j2_gc::J2_GravCte{T} = j2_gc_egm08) where T</code></pre><p>Initialize the data structure of J2 osculating orbit propagator algorithm.</p><p><strong>Args</strong></p><ul><li><code>epoch</code>: Epoch of the orbital elements [Julian Day].</li><li><code>a_0</code>: Initial semi-major axis [m].</li><li><code>e_0</code>: Initial eccentricity.</li><li><code>i_0</code>: Initial inclination [rad].</li><li><code>Ω_0</code>: Initial right ascension of the ascending node [rad].</li><li><code>ω_0</code>: Initial argument of perigee [rad].</li><li><code>f_0</code>: Initial true anomaly [rad].</li><li><code>dn_o2</code>: First time derivative of the mean motion divided by two [rad/s^2].</li><li><code>ddn_o6</code>: Second time derivative of the mean motion divided by six [rad/s^3].</li></ul><p><strong>Keywords</strong></p><ul><li><code>j2_gc</code>: J2 orbit propagator gravitational constants (see <code>J2_GravCte</code>).          (<strong>Default</strong> = <code>j2_gc_egm08</code>)</li></ul><p><strong>Returns</strong></p><p>The structure <code>J2osc_Structure</code> with the initialized parameters.</p><p><strong>Remarks</strong></p><p>The inputs are the mean orbital elements.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaSpace/SatelliteToolbox.jl/blob/c7a891ae8cbd18d844cb2ba648927c3c6dfa564f/src/orbit/propagators/j2osc.jl#L28-L58">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="SatelliteToolbox.j4!-Union{Tuple{T}, Tuple{J4_Structure{T}, Number}} where T" href="#SatelliteToolbox.j4!-Union{Tuple{T}, Tuple{J4_Structure{T}, Number}} where T"><code>SatelliteToolbox.j4!</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">j4!(j4d::J4_Structure{T}, t::Number) where T</code></pre><p>Propagate the orbit defined in <code>j4d</code> (see <code>J4_Structure</code>) until the time <code>t</code> [s]. Notice that the values in <code>j4d</code> will be modified.</p><p><strong>Returns</strong></p><ul><li>The position vector represented in the inertial frame at time <code>t</code> [m].</li><li>The velocity vector represented in the inertial frame at time <code>t</code> [m/s]</li></ul><p><strong>Remarks</strong></p><p>The inertial frame in which the output is represented depends on which frame it was used to generate the orbit parameters. Notice that the perturbation theory requires an inertial frame with true equator.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaSpace/SatelliteToolbox.jl/blob/c7a891ae8cbd18d844cb2ba648927c3c6dfa564f/src/orbit/propagators/j4.jl#L181-L198">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="SatelliteToolbox.j4_init-Union{Tuple{T}, NTuple{7, Number}, NTuple{8, Number}, NTuple{9, Number}} where T" href="#SatelliteToolbox.j4_init-Union{Tuple{T}, NTuple{7, Number}, NTuple{8, Number}, NTuple{9, Number}} where T"><code>SatelliteToolbox.j4_init</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">j4_init(epoch::Number, a_0::Number, e_0::Number, i_0::Number, Ω_0::Number, ω_0::Number, f_0::Number, dn_o2::Number = 0, ddn_o6::Number = 0; j4_gc::J4_GravCte{T} = j4_gc_egm08) where T</code></pre><p>Initialize the data structure of J4 orbit propagator algorithm.</p><p><strong>Args</strong></p><ul><li><code>epoch</code>: Epoch of the initial mean orbital elements [Julian Day].</li><li><code>a_0</code>: Initial mean semi-major axis [m].</li><li><code>e_0</code>: Initial mean eccentricity.</li><li><code>i_0</code>: Initial mean inclination [rad].</li><li><code>Ω_0</code>: Initial mean right ascension of the ascending node [rad].</li><li><code>ω_0</code>: Initial mean argument of perigee [rad].</li><li><code>f_0</code>: Initial mean true anomaly [rad].</li><li><code>dn_o2</code>: First time derivative of the mean motion divided by two [rad/s^2].</li><li><code>ddn_o6</code>: Second time derivative of the mean motion divided by six [rad/s^3].</li></ul><p><strong>Keywords</strong></p><ul><li><code>j4_gc</code>: J4 orbit propagator gravitational constants (see <code>J4_GravCte</code>).          (<strong>Default</strong> = <code>j4_gc_egm08</code>)</li></ul><p><strong>Returns</strong></p><p>The structure <code>J4_Structure</code> with the initialized parameters.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaSpace/SatelliteToolbox.jl/blob/c7a891ae8cbd18d844cb2ba648927c3c6dfa564f/src/orbit/propagators/j4.jl#L77-L103">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="SatelliteToolbox.jb2008-NTuple{4, Number}" href="#SatelliteToolbox.jb2008-NTuple{4, Number}"><code>SatelliteToolbox.jb2008</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">jb2008(JD::Number, glat::Number, glon::Number, h::Number)
jb2008(JD::Number, glat::Number, glon::Number, h::Number, F10::Number, F10ₐ::Number, S10::Number, S10ₐ::Number, M10::Number, M10ₐ::Number, Y10::Number, Y10ₐ::Number, DstΔTc::Number)</code></pre><p>Compute the atmospheric density using the Jacchia-Bowman 2008 (JB2008) model.</p><p>If the space indices are not provided (first call), then they will be obtained from the online database. In this case, the function <code>init_space_indices()</code> must be called first and the function will throw an exception if the selected <code>JD</code> is outside of the available data.</p><p>This model is a product of the <strong>Space Environment Technologies</strong>, more information can be seen in the websites:</p><p>http://sol.spacenvironment.net/jb2006/</p><p>http://sol.spacenvironment.net/jb2008/</p><p><strong>Args</strong></p><ul><li><p><code>JD</code>: Julian day.</p></li><li><p><code>glat</code>: Geocentric latitude [rad].</p></li><li><p><code>glon</code>: Geocentric longitude [rad].</p></li><li><p><code>h</code>: Altitude [m].</p></li><li><p><code>F10</code>: 10.7-cm solar flux [10⁻²² W/(M² Hz)] (Tabular time 1 day earlier).</p></li><li><p><code>F10ₐ</code>: 10.7-cm averaged solar flux, 81-day centered on input time (Tabular         time 1 day earlier).</p></li><li><p><code>S10</code>: EUV index (26-34 nm) scaled to F10.7 (Tabular time 1 day earlier).</p></li><li><p><code>S10ₐ</code>: EUV 81-day averaged centered index (Tabular time 1 day earlier).</p></li><li><p><code>M10</code>: MG2 index scaled to F10.7 (Tabular time 2 days earlier).</p></li><li><p><code>M10ₐ</code>: MG2 81-day averaged centered index (Tabular time 2 days earlier).</p></li><li><p><code>Y10</code>: Solar X-ray &amp; Lya index scaled to F10.7 (Tabular time 5 days earlier).</p></li><li><p><code>Y10ₐ</code>: Solar X-ray &amp; Lya 81-day averaged centered index (Tabular time 5 days         earlier).</p></li><li><p><code>DstΔTc</code>: Temperature variation related to the Dst.</p></li></ul><p><strong>Returns</strong></p><p>An instance of the structure <code>JB2008_Output</code> with the computed values.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaSpace/SatelliteToolbox.jl/blob/c7a891ae8cbd18d844cb2ba648927c3c6dfa564f/src/earth/atmospheric_models/jb2008/jb2008.jl#L39-L80">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="SatelliteToolbox.jd_to_date-Tuple{Number}" href="#SatelliteToolbox.jd_to_date-Tuple{Number}"><code>SatelliteToolbox.jd_to_date</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">jd_to_date([T,] JD::Number)</code></pre><p>Convert a date represented in Julian Day <code>JD</code> to Gregorian Calendar. The optional parameter <code>T</code> defines the return type. If <code>T</code> is omitted, then it defaults to <code>Int</code>.</p><p><strong>Returns</strong></p><p>If <code>T</code> is omitted or <code>Int</code>, then a tuple with the following data will be returned:</p><ul><li>Year.</li><li>Month (<code>1</code> =&gt; <strong>January</strong>, <code>2</code> =&gt; <strong>February</strong>, ...).</li><li>Day.</li><li>Hour (0 - 24).</li><li>Minute (0 - 59).</li><li>Second (0 - 59).</li></ul><p>Notice that if <code>T</code> is <code>Int</code>, then the seconds field will be Integer. Otherwise, it will be floating point.</p><p>If <code>T</code> is <code>Date</code>, then it will return the Julia structure <code>Date</code>. Notice that the hours, minutes, and seconds will be neglected because the structure <code>Date</code> does not handle them.</p><p>If <code>T</code> is <code>DateTime</code>, then it will return the Julia structure <code>DateTime</code>.</p><p><strong>Remarks</strong></p><p>The algorithm was obtained from [2] (Accessed on 2018-04-11). In [2], there is the following warning:</p><blockquote><p>Note: This method will not give dates accurately on the Gregorian Proleptic Calendar, i.e., the calendar you get by extending the Gregorian calendar backwards to years earlier than 1582. using the Gregorian leap year rules. In particular, the method fails if Y&lt;400.</p></blockquote></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaSpace/SatelliteToolbox.jl/blob/c7a891ae8cbd18d844cb2ba648927c3c6dfa564f/src/time/julian_day.jl#L132-L170">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="SatelliteToolbox.jd_to_gmst-Tuple{Number}" href="#SatelliteToolbox.jd_to_gmst-Tuple{Number}"><code>SatelliteToolbox.jd_to_gmst</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">jd_to_gmst(JD_UT1::Number)</code></pre><p>Compute the Greenwich Mean Sideral Time (GMST) [rad] for the Julian Day <code>JD_UT1</code> [UT1].</p><p><strong>Remarks</strong></p><p>Based on algorithm in [1, pp. 188].</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaSpace/SatelliteToolbox.jl/blob/c7a891ae8cbd18d844cb2ba648927c3c6dfa564f/src/transformations/gmst.jl#L52-L62">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="SatelliteToolbox.jd_tt_to_utc-Tuple{Number, Number}" href="#SatelliteToolbox.jd_tt_to_utc-Tuple{Number, Number}"><code>SatelliteToolbox.jd_tt_to_utc</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">jd_tt_to_utc(JD_TT::Number, ΔAT::Number = 37)</code></pre><p>Convert the Julian Day in TT <code>JD_TT</code> (Terrestrial Time) to the Julian Day in UTC (Terrestrial Time) using the accumulated difference <code>ΔAT</code> between UTC and the International Atomic Time (TAI). If no value is provided, then the leap seconds will be obtained from the table <code>ΔAT_Data</code>. <strong>Notice that, in this case, if a date previous to 1973 is provided, then a fixed value of 10 will be used, leading to wrong computations.</strong></p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaSpace/SatelliteToolbox.jl/blob/c7a891ae8cbd18d844cb2ba648927c3c6dfa564f/src/time/time.jl#L157-L167">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="SatelliteToolbox.jd_ut1_to_utc-Tuple{Number, Number}" href="#SatelliteToolbox.jd_ut1_to_utc-Tuple{Number, Number}"><code>SatelliteToolbox.jd_ut1_to_utc</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">jd_ut1_to_utc(JD_UT1::Number, ΔUT1::Number)</code></pre><p>Convert the Julian Day in UT1 <code>JD_UT1</code> to the Julian Day in UTC using the accumulated difference <code>ΔUT1</code>, which is provided by IERS EOP Data.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaSpace/SatelliteToolbox.jl/blob/c7a891ae8cbd18d844cb2ba648927c3c6dfa564f/src/time/time.jl#L106-L112">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="SatelliteToolbox.jd_ut1_to_utc-Tuple{Number, Union{EOPData_IAU1980, EOPData_IAU2000A}}" href="#SatelliteToolbox.jd_ut1_to_utc-Tuple{Number, Union{EOPData_IAU1980, EOPData_IAU2000A}}"><code>SatelliteToolbox.jd_ut1_to_utc</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">jd_utc_to_ut1(JD_UTC::Number, eop::Union{EOPData_IAU1980,EOPData_IAU2000A})</code></pre><p>Convert the Julian Day in UT1 <code>JD_UT1</code> to the Julian Day in UTC using the accumulated difference given by the EOP Data <code>eop</code> (see <code>get_iers_eop</code>). Notice that the accumulated difference will be interpolated.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaSpace/SatelliteToolbox.jl/blob/c7a891ae8cbd18d844cb2ba648927c3c6dfa564f/src/time/time.jl#L127-L134">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="SatelliteToolbox.jd_utc_to_tt-Tuple{Number, Number}" href="#SatelliteToolbox.jd_utc_to_tt-Tuple{Number, Number}"><code>SatelliteToolbox.jd_utc_to_tt</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">jd_utc_to_tt(JD_UTC::Number [, ΔAT::Number])</code></pre><p>Convert the Julian Day in UTC <code>JD_UTC</code> to the Julian Day in TT (Terrestrial Time) using the accumulated difference <code>ΔAT</code> between UTC and the International Atomic Time (TAI). If no value is provided, then the leap seconds will be obtained from the table <code>ΔAT_Data</code>. <strong>Notice that, in this case, if a date previous to 1973 is provided, then a fixed value of 10 will be used, leading to wrong computations.</strong></p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaSpace/SatelliteToolbox.jl/blob/c7a891ae8cbd18d844cb2ba648927c3c6dfa564f/src/time/time.jl#L139-L149">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="SatelliteToolbox.jd_utc_to_ut1-Tuple{Number, Number}" href="#SatelliteToolbox.jd_utc_to_ut1-Tuple{Number, Number}"><code>SatelliteToolbox.jd_utc_to_ut1</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">jd_utc_to_ut1(JD_UTC::Number, ΔUT1::Number)</code></pre><p>Convert the Julian Day in UTC <code>JD_UTC</code> to the Julian Day in UT1 using the accumulated difference <code>ΔUT1</code>, which is provided by IERS EOP Data.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaSpace/SatelliteToolbox.jl/blob/c7a891ae8cbd18d844cb2ba648927c3c6dfa564f/src/time/time.jl#L97-L103">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="SatelliteToolbox.jd_utc_to_ut1-Tuple{Number, Union{EOPData_IAU1980, EOPData_IAU2000A}}" href="#SatelliteToolbox.jd_utc_to_ut1-Tuple{Number, Union{EOPData_IAU1980, EOPData_IAU2000A}}"><code>SatelliteToolbox.jd_utc_to_ut1</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">jd_utc_to_ut1(JD_UTC::Number, eop::Union{EOPData_IAU1980,EOPData_IAU2000A})</code></pre><p>Convert the Julian Day in UTC <code>JD_UTC</code> to the Julian Day in UT1 using the accumulated difference given by the EOP Data <code>eop</code> (see <code>get_iers_eop</code>). Notice that the accumulated difference will be interpolated.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaSpace/SatelliteToolbox.jl/blob/c7a891ae8cbd18d844cb2ba648927c3c6dfa564f/src/time/time.jl#L115-L122">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="SatelliteToolbox.jr1971-NTuple{7, Number}" href="#SatelliteToolbox.jr1971-NTuple{7, Number}"><code>SatelliteToolbox.jr1971</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">jr1971(JD::Number, glat::Number, glon::Number, h::Number, F10::Number, F10ₐ::Number, Kp::Number)</code></pre><p>Compute the atmospheric density using the Jacchia-Roberts 1971 model.</p><p><strong>Args</strong></p><ul><li><code>JD</code>: Julian day.</li><li><code>glat</code>: Geodetic latitude [rad].</li><li><code>glon</code>: Geodetic longitude [rad].</li><li><code>h</code>: Altitude [m].</li><li><code>F10</code>: 10.7-cm solar flux [10⁻²² W/(M² Hz)].</li><li><code>F10ₐ</code>: 10.7-cm averaged solar flux, 81-day centered on input time.</li><li><code>Kp</code>: Kp geomagnetic index (with a delay of 3 hours).</li></ul><p><strong>Returns</strong></p><p>An instance of the structure <code>JR1971_Output</code> with the computed values.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaSpace/SatelliteToolbox.jl/blob/c7a891ae8cbd18d844cb2ba648927c3c6dfa564f/src/earth/atmospheric_models/jr1971/jr1971.jl#L32-L51">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="SatelliteToolbox.kepler_to_rv-NTuple{6, Number}" href="#SatelliteToolbox.kepler_to_rv-NTuple{6, Number}"><code>SatelliteToolbox.kepler_to_rv</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">kepler_to_rv(a::Number, e::Number, i::Number, Ω::Number, ω::Number, f::Number)
kepler_to_rv(k::KeplerianElements)</code></pre><p>Convert the Keplerian elements (<code>a</code>, <code>e</code>, <code>i</code>, <code>Ω</code>, <code>ω</code>, and <code>f</code>) to a Cartesian representation (position vector <code>r</code> and velocity vector <code>v</code>). The Keplerian elements can also be passed inside an instance of the <code>KeplerianElements</code> structure.</p><p><strong>Args</strong></p><ul><li><code>a</code>: Semi-major axis [m].</li><li><code>e</code>: Eccentricity.</li><li><code>i</code>: Inclination [rad].</li><li><code>Ω</code>: Right ascension of the ascending node [rad].</li><li><code>ω</code>: Argument of perigee [rad].</li><li><code>f</code>: True anomaly [rad].</li></ul><p><strong>Returns</strong></p><ul><li>The position vector represented in the inertial reference frame [m].</li><li>The velocity vector represented in the inertial reference frame [m].</li></ul><p><strong>References</strong></p><p>This algorithm was adapted from [1] and [3, p. 37-38].</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaSpace/SatelliteToolbox.jl/blob/c7a891ae8cbd18d844cb2ba648927c3c6dfa564f/src/orbit/representations/rv.jl#L31-L58">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="SatelliteToolbox.kepler_to_sv-Union{Tuple{KeplerianElements{T}}, Tuple{T}} where T" href="#SatelliteToolbox.kepler_to_sv-Union{Tuple{KeplerianElements{T}}, Tuple{T}} where T"><code>SatelliteToolbox.kepler_to_sv</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">kepler_to_sv(k::KeplerianElements)</code></pre><p>Convert the Keplerian elements <code>k</code> to a state vector.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaSpace/SatelliteToolbox.jl/blob/c7a891ae8cbd18d844cb2ba648927c3c6dfa564f/src/orbit/representations/keplerian_elements.jl#L32-L37">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="SatelliteToolbox.legendre" href="#SatelliteToolbox.legendre"><code>SatelliteToolbox.legendre</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">legendre([N,] ϕ::Number, n_max::Integer, m_max::Integer = -1, ph_term::Bool = false)</code></pre><p>Compute the associated Legendre function <code>P_n,m[cos(ϕ)]</code>. The maximum degree that will be computed is <code>n_max</code> and the maximum order is <code>m_max</code>. Notice that if <code>m_max</code> is higher than <code>n_max</code> or negative, than it is set to <code>n_max</code>.</p><p>The optional parameter <code>N</code> can be used to select the normalization. The following values are valid:</p><ul><li><code>Val(:full)</code>: Compute the fully normalized associated Legendre function (see <code>legendre_fully_normalized</code>).</li><li><code>Val(:schmidt)</code>: Compute the Schmidt quasi-normalized associated Legendre function (see <code>legendre_schmidt_quasi_normalized</code>).</li><li><code>Val(:conv)</code>: Compute the conventional associated Legendre function (see <code>legendre_conventional</code>).</li></ul><p>If <code>N</code> is omitted, then the full normalization will be used (<code>Val(:full)</code>).</p><p>If <code>ph_term</code> is set to <code>true</code>, then the Condon-Shortley phase term <code>(-1)ᵐ</code> will be included. If <code>ph_term</code> is not present, then it defaults to <code>false</code>.</p><p><strong>Returns</strong></p><p>A matrix with the Legendre associated functions <code>P_n,m[cos(ϕ)]</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaSpace/SatelliteToolbox.jl/blob/c7a891ae8cbd18d844cb2ba648927c3c6dfa564f/src/misc/legendre.jl#L76-L102">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="SatelliteToolbox.legendre!" href="#SatelliteToolbox.legendre!"><code>SatelliteToolbox.legendre!</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">legendre!([N,] P::AbstractMatrix, ϕ::Number, ph_term::Bool = false, n_max::Integer = -1, m_max::Integer = -1)</code></pre><p>Compute the associated Legendre function <code>P_n,m[cos(ϕ)]</code>. The maximum degree and order that will be computed are given by the parameters <code>n_max</code> and <code>m_max</code>. If they are negative, then the dimensions of matrix <code>P</code> will be used.</p><p>The result will be stored at matrix <code>P</code>.</p><p>The optional parameter <code>N</code> can be used to select the normalization. The following values are valid:</p><ul><li><code>Val(:full)</code>: Compute the fully normalized associated Legendre function (see <code>legendre_fully_normalized!</code>).</li><li><code>Val(:schmidt)</code>: Compute the Schmidt quasi-normalized associated Legendre function (see <code>legendre_schmidt_quasi_normalized!</code>).</li><li><code>Val(:conv)</code>: Compute the conventional associated Legendre function (see <code>legendre_conventional!</code>).</li></ul><p>If <code>N</code> is omitted, then the full normalization will be used.</p><p>If <code>ph_term</code> is set to <code>true</code>, then the Condon-Shortley phase term <code>(-1)ᵐ</code> will be included. If <code>ph_term</code> is not present, then it defaults to <code>false</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaSpace/SatelliteToolbox.jl/blob/c7a891ae8cbd18d844cb2ba648927c3c6dfa564f/src/misc/legendre.jl#L35-L59">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="SatelliteToolbox.legendre_conventional!" href="#SatelliteToolbox.legendre_conventional!"><code>SatelliteToolbox.legendre_conventional!</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">legendre_conventional!(P::AbstractMatrix, ϕ::Number, ph_term::Bool = false, n_max::Integer = -1, m_max::Integer = -1)</code></pre><p>Compute the conventional associated Legendre function <code>P_n,m[cos(ϕ)]</code>. The maximum degree and order that will be computed are given by the parameters <code>n_max</code> and <code>m_max</code>. If they are negative, then the dimensions of matrix <code>P</code> will be used:</p><pre><code class="language-none">maximum degree -&gt; number of rows
maximum order  -&gt; number of columns</code></pre><p>The result will be stored at matrix <code>P</code>.</p><p>If <code>ph_term</code> is set to <code>true</code>, then the Condon-Shortley phase term <code>(-1)ᵐ</code> will be included. If <code>ph_term</code> is not present, then it defaults to <code>false</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaSpace/SatelliteToolbox.jl/blob/c7a891ae8cbd18d844cb2ba648927c3c6dfa564f/src/misc/legendre.jl#L399-L415">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="SatelliteToolbox.legendre_conventional-Union{Tuple{T}, Tuple{T, Integer}, Tuple{T, Integer, Integer}, Tuple{T, Integer, Integer, Bool}} where T&lt;:AbstractFloat" href="#SatelliteToolbox.legendre_conventional-Union{Tuple{T}, Tuple{T, Integer}, Tuple{T, Integer, Integer}, Tuple{T, Integer, Integer, Bool}} where T&lt;:AbstractFloat"><code>SatelliteToolbox.legendre_conventional</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">legendre_conventional(ϕ::T, n_max::Integer, m_max::Integer = -1, ph_term::Bool = false) where T&lt;:AbstractFloat</code></pre><p>Compute the conventional associated Legendre function <code>P_n,m[cos(ϕ)]</code>. The maximum degree that will be computed is <code>n_max</code> and the maximum order is <code>m_max</code>. Notice that if <code>m_max</code> is higher than <code>n_max</code> or negative, than it is set to <code>n_max</code>.</p><p>If <code>ph_term</code> is set to <code>true</code>, then the Condon-Shortley phase term <code>(-1)ᵐ</code> will be included. If <code>ph_term</code> is not present, then it defaults to <code>false</code>.</p><p><strong>Returns</strong></p><p>A matrix with the Legendre associated functions <code>P_n,m[cos(ϕ)]</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaSpace/SatelliteToolbox.jl/blob/c7a891ae8cbd18d844cb2ba648927c3c6dfa564f/src/misc/legendre.jl#L472-L487">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="SatelliteToolbox.legendre_fully_normalized!" href="#SatelliteToolbox.legendre_fully_normalized!"><code>SatelliteToolbox.legendre_fully_normalized!</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">legendre_fully_normalized!(P::AbstractMatrix, ϕ::Number, ph_term::Bool = false, n_max::Integer = -1, m_max::Integer = -1)</code></pre><p>Compute the fully normalized associated Legendre function <code>P_n,m[cos(ϕ)]</code>. The maximum degree and order that will be computed are given by the parameters <code>n_max</code> and <code>m_max</code>. If they are negative, then the dimensions of matrix <code>P</code> will be used:</p><pre><code class="language-none">maximum degree -&gt; number of rows
maximum order  -&gt; number of columns</code></pre><p>The result will be stored at matrix <code>P</code>.</p><p>If <code>ph_term</code> is set to <code>true</code>, then the Condon-Shortley phase term <code>(-1)ᵐ</code> will be included. If <code>ph_term</code> is not present, then it defaults to <code>false</code>.</p><p><strong>Remarks</strong></p><p>This algorithm was based on [1]. Our definition of fully normalized associated Legendre function can be seen in [2, p. 546]. The conversion is obtained by:</p><pre><code class="language-none">             _                     -
            |  (n-m)! . k . (2n+1)  |      k = 1 if m  = 0
K_n,m = sqrt| --------------------- |,     k = 2 if m != 0
            |         (n+m)!        |
             -                     -
_
P_n,m = P_n,m * K_n,m,

      _
where P_n,m is the fully normalized Legendre associated function.</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaSpace/SatelliteToolbox.jl/blob/c7a891ae8cbd18d844cb2ba648927c3c6dfa564f/src/misc/legendre.jl#L122-L154">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="SatelliteToolbox.legendre_fully_normalized-Union{Tuple{T}, Tuple{T, Integer}, Tuple{T, Integer, Integer}, Tuple{T, Integer, Integer, Bool}} where T&lt;:AbstractFloat" href="#SatelliteToolbox.legendre_fully_normalized-Union{Tuple{T}, Tuple{T, Integer}, Tuple{T, Integer, Integer}, Tuple{T, Integer, Integer, Bool}} where T&lt;:AbstractFloat"><code>SatelliteToolbox.legendre_fully_normalized</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">legendre_fully_normalized(ϕ::T, n_max::Integer, m_max::Integer = -1, ph_term::Bool = false) where T&lt;:AbstractFloat</code></pre><p>Compute the fully normalized associated Legendre function <code>P_n,m[cos(ϕ)]</code>. The maximum degree that will be computed is <code>n_max</code> and the maximum order is <code>m_max</code>. Notice that if <code>m_max</code> is higher than <code>n_max</code> or negative, than it is set to <code>n_max</code>.</p><p>If <code>ph_term</code> is set to <code>true</code>, then the Condon-Shortley phase term <code>(-1)ᵐ</code> will be included. If <code>ph_term</code> is not present, then it defaults to <code>false</code>.</p><p><strong>Returns</strong></p><p>A matrix with the Legendre associated functions <code>P_n,m[cos(ϕ)]</code>.</p><p><strong>Remarks</strong></p><p>This algorithm was based on [1]. Our definition of fully normalized associated Legendre function can be seen in [2, p. 546]. The conversion is obtained by:</p><pre><code class="language-none">             _                     -
            |  (n-m)! . k . (2n+1)  |      k = 1 if m  = 0
K_n,m = sqrt| --------------------- |,     k = 2 if m != 0
            |         (n+m)!        |
             -                     -
_
P_n,m = P_n,m * K_n,m,

      _
where P_n,m is the fully normalized Legendre associated function.</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaSpace/SatelliteToolbox.jl/blob/c7a891ae8cbd18d844cb2ba648927c3c6dfa564f/src/misc/legendre.jl#L211-L242">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="SatelliteToolbox.legendre_schmidt_quasi_normalized!" href="#SatelliteToolbox.legendre_schmidt_quasi_normalized!"><code>SatelliteToolbox.legendre_schmidt_quasi_normalized!</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">legendre_schmidt_quasi_normalized!(P::AbstractMatrix, ϕ::Number, ph_term::Bool = false, n_max::Integer = -1, m_max::Integer = -1)</code></pre><p>Compute the Schmidt quasi-normalized associated Legendre function <code>P_n,m[cos(ϕ)]</code> [3,4]. The maximum degree and order that will be computed are given by the parameters <code>n_max</code> and <code>m_max</code>. If they are negative, then the dimensions of matrix <code>P</code> will be used:</p><pre><code class="language-none">maximum degree -&gt; number of rows
maximum order  -&gt; number of columns</code></pre><p>The result will be stored at matrix <code>P</code>.</p><p>If <code>ph_term</code> is set to <code>true</code>, then the Condon-Shortley phase term <code>(-1)ᵐ</code> will be included. If <code>ph_term</code> is not present, then it defaults to <code>false</code>.</p><p><strong>Remarks</strong></p><p>This algorithm was based on [3,4]. The conversion is obtained by:</p><pre><code class="language-none">             _           -
            |     (n-m)!  |    k = 1 if m  = 0
K_n,m = sqrt| k. -------- |,   k = 2 if m != 0
            |     (n+m)!  |
             -           -

=
P_n,m = P_n,m * K_n,m,

      =
where P_n,m is the quasi-normalized normalized Legendre associated function.</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaSpace/SatelliteToolbox.jl/blob/c7a891ae8cbd18d844cb2ba648927c3c6dfa564f/src/misc/legendre.jl#L259-L291">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="SatelliteToolbox.legendre_schmidt_quasi_normalized-Union{Tuple{T}, Tuple{T, Integer}, Tuple{T, Integer, Integer}, Tuple{T, Integer, Integer, Bool}} where T&lt;:AbstractFloat" href="#SatelliteToolbox.legendre_schmidt_quasi_normalized-Union{Tuple{T}, Tuple{T, Integer}, Tuple{T, Integer, Integer}, Tuple{T, Integer, Integer, Bool}} where T&lt;:AbstractFloat"><code>SatelliteToolbox.legendre_schmidt_quasi_normalized</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">legendre_schmidt_quasi_normalized(ϕ::T, n_max::Integer, m_max::Integer = -1, ph_term::Bool = false) where T&lt;:AbstractFloat</code></pre><p>Compute the Schmidt quasi-normalized associated Legendre function <code>P_n,m[cos(ϕ)]</code>. The maximum degree that will be computed is <code>n_max</code> and the maximum order is <code>m_max</code>. Notice that if <code>m_max</code> is higher than <code>n_max</code> or negative, than it is set to <code>n_max</code>.</p><p>If <code>ph_term</code> is set to <code>true</code>, then the Condon-Shortley phase term <code>(-1)ᵐ</code> will be included. If <code>ph_term</code> is not present, then it defaults to <code>false</code>.</p><p><strong>Returns</strong></p><p>A matrix with the Legendre associated functions <code>P_n,m[cos(ϕ)]</code>.</p><p><strong>Remarks</strong></p><p>This algorithm was based on [3,4]. The conversion is obtained by:</p><pre><code class="language-none">             _           -
            |     (n-m)!  |    k = 1 if m  = 0
K_n,m = sqrt| k. -------- |,   k = 2 if m != 0
            |     (n+m)!  |
             -           -

=
P_n,m = P_n,m * K_n,m,

      =
where P_n,m is the quasi-normalized normalized Legendre associated function.</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaSpace/SatelliteToolbox.jl/blob/c7a891ae8cbd18d844cb2ba648927c3c6dfa564f/src/misc/legendre.jl#L350-L381">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="SatelliteToolbox.list_ground_station_accesses-Tuple" href="#SatelliteToolbox.list_ground_station_accesses-Tuple"><code>SatelliteToolbox.list_ground_station_accesses</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">list_ground_station_accesses(io, vargs...; kwargs...)</code></pre><p>Print the ground station accesses to the io <code>io</code>. The arguments <code>vargs...</code> and keywords <code>kwargs...</code> are those of the function <code>ground_station_accesses</code>.</p><p>Additionally, the following keywords can be used to modify the behavior of this function:</p><ul><li><code>format</code>: If <code>:pretty</code>, then a formatted table will be printed. If <code>:csv</code>,           then the access data will be printed using the CSV format.           (<strong>Default</strong> = <code>:pretty</code>)</li><li><code>time_scale</code>: Select the time scale of the access duration (<code>:s</code> for seconds,               <code>:m</code> for minutes, and <code>:h</code> for hours). (<strong>Default</strong> = <code>:m</code>)</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaSpace/SatelliteToolbox.jl/blob/c7a891ae8cbd18d844cb2ba648927c3c6dfa564f/src/analysis/ground_stations.jl#L186-L201">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="SatelliteToolbox.list_ground_station_gaps-Tuple" href="#SatelliteToolbox.list_ground_station_gaps-Tuple"><code>SatelliteToolbox.list_ground_station_gaps</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">list_ground_station_gaps(io, vargs...; kwargs...)</code></pre><p>Print the ground station gaps to the io <code>io</code>. The arguments <code>vargs...</code> and keywords <code>kwargs...</code> are those of the function <code>ground_station_gaps</code>.</p><p>Additionally, the following keywords can be used to modify the behavior of this function:</p><ul><li><code>format</code>: If <code>:pretty</code>, then a formatted table will be printed. If <code>:csv</code>,           then the access data will be printed using the CSV format.           (<strong>Default</strong> = <code>:pretty</code>)</li><li><code>time_scale</code>: Select the time scale of the access duration (<code>:s</code> for seconds,               <code>:m</code> for minutes, and <code>:h</code> for hours). (<strong>Default</strong> = <code>:m</code>)</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaSpace/SatelliteToolbox.jl/blob/c7a891ae8cbd18d844cb2ba648927c3c6dfa564f/src/analysis/ground_stations.jl#L280-L295">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="SatelliteToolbox.list_ss_orbits_by_rep_period" href="#SatelliteToolbox.list_ss_orbits_by_rep_period"><code>SatelliteToolbox.list_ss_orbits_by_rep_period</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">list_ss_orbits_by_rep_period(minRep::Int, maxRep::Int, minAlt::Number=-1.0, maxAlt::Number=-1.0, e::Number=0.0)</code></pre><p>Compute a list of repeating Sun-synchronous orbits.</p><p><strong>Args</strong></p><ul><li><code>minRep</code>: Minimum repetition time of the orbit [days].</li><li><code>maxRep</code>: Maximum repetition time of the orbit [days].</li><li><code>minAlt</code>: Minimum altitude of the orbits on the list [m].</li><li><code>maxAlt</code>: Minimum altitude of the orbits on the list [m].</li><li><code>e</code>: Eccentricity.</li></ul><p><strong>Returns</strong></p><p>A matrix containing the orbits found with the following format:</p><pre><code class="language-none">Semi-major axis [m] | Altitude [m] | Inclination [rad] | Period [s] | Int | Num | Den
--------------------|--------------|-------------------|------------|-----|-----|-----</code></pre><p>in which the period is Int + Num/Den.</p><p><strong>Remarks</strong></p><p>If <code>minAlt</code> or <code>maxAlt</code> is &lt; 0.0, then the altitude will not be checked when a orbit is added to the list.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaSpace/SatelliteToolbox.jl/blob/c7a891ae8cbd18d844cb2ba648927c3c6dfa564f/src/orbit/orbit_sun_sync_ground_reap.jl#L127-L154">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="SatelliteToolbox.load_gravity_model-Tuple{Val{:egm96}}" href="#SatelliteToolbox.load_gravity_model-Tuple{Val{:egm96}}"><code>SatelliteToolbox.load_gravity_model</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">load_gravity_model(T)</code></pre><p>Load an embedded gravity model coefficients <code>T</code> and return an instance of the structure <code>GravityModel_Coefs</code> with the parsed values.</p><p>The current supported values for <code>T</code> are:</p><table><tr><th style="text-align: center"><code>T</code></th><th style="text-align: left">Model Name</th><th style="text-align: left">Maximum Degree</th></tr><tr><td style="text-align: center"><code>EGM96()</code></td><td style="text-align: left">Earth Gravitational Model 1996</td><td style="text-align: left">360</td></tr><tr><td style="text-align: center"><code>JGM2()</code></td><td style="text-align: left">Joint Earth Gravity Model 2</td><td style="text-align: left">70</td></tr><tr><td style="text-align: center"><code>JGM3()</code></td><td style="text-align: left">Joint Earth Gravity Model 3</td><td style="text-align: left">70</td></tr><tr><td style="text-align: center">–––––-</td><td style="text-align: left">––––––––––––––––</td><td style="text-align: left">––––––––</td></tr></table><p>For other models, you can downlad the <code>gfc</code> file at</p><pre><code class="language-none">http://icgem.gfz-potsdam.de/home</code></pre><p>and load it using the functions <code>parse_icgem</code> and <code>create_gravity_model_coefs</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaSpace/SatelliteToolbox.jl/blob/c7a891ae8cbd18d844cb2ba648927c3c6dfa564f/src/earth/gravity_models/embedded_gravity_models.jl#L22-L43">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="SatelliteToolbox.luni_solar_args_iau2006-Tuple{Number}" href="#SatelliteToolbox.luni_solar_args_iau2006-Tuple{Number}"><code>SatelliteToolbox.luni_solar_args_iau2006</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">luni_solar_args_iau2006(JD_TT::Number)</code></pre><p>Compute the fundamental arguments related to the luni-solar effect for the IAU-2006 theory [1, p. 211].</p><p>The returned values are in [rad].</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaSpace/SatelliteToolbox.jl/blob/c7a891ae8cbd18d844cb2ba648927c3c6dfa564f/src/transformations/iau2006/fundamental_args.jl#L20-L28">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="SatelliteToolbox.mean_obliquity_iau2006-Tuple{Number}" href="#SatelliteToolbox.mean_obliquity_iau2006-Tuple{Number}"><code>SatelliteToolbox.mean_obliquity_iau2006</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">mean_obliquity_iau2006(JD_TT::Number)</code></pre><p>Compute the mean obliquity of the ecliptic [rad] using the equinox-based IAU-2006 theory in the Julian day <code>JD_TT</code> [Terrestiral Time].</p><p>The algorithm was obtained in [3].</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaSpace/SatelliteToolbox.jl/blob/c7a891ae8cbd18d844cb2ba648927c3c6dfa564f/src/transformations/iau2006/nutation_eo.jl#L29-L37">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="SatelliteToolbox.minimum_half_FOV_grss-Tuple{Real, Real, Real, Integer}" href="#SatelliteToolbox.minimum_half_FOV_grss-Tuple{Real, Real, Real, Integer}"><code>SatelliteToolbox.minimum_half_FOV_grss</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">minimum_half_FOV_grss(h::Real, T::Real, i::Real, To::Integer)</code></pre><p>Compute the minimum half FOV of a ground repeating Sun-synchronous (GRSS) orbit to cover the entire Equator within the revisit interval.</p><p><strong>Args</strong></p><ul><li><code>h</code>: Orbit altitude in the Equator [m].</li><li><code>T</code>: Orbit period [s].</li><li><code>i</code>: Inclination [rad].</li><li><code>To</code>: Orbit cycle [days].</li></ul><p><strong>Returns</strong></p><p>The minimum half FOV [rad].</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaSpace/SatelliteToolbox.jl/blob/c7a891ae8cbd18d844cb2ba648927c3c6dfa564f/src/analysis/payload_optical_analysis.jl#L11-L28">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="SatelliteToolbox.minimum_half_FOV_grss-Tuple{Real, Real, Real, Real, Integer}" href="#SatelliteToolbox.minimum_half_FOV_grss-Tuple{Real, Real, Real, Real, Integer}"><code>SatelliteToolbox.minimum_half_FOV_grss</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">minimum_half_FOV_grss(h::Real, a::Real, e::Real, i::Real, To::Integer)</code></pre><p>Compute the minimum half FOV of a ground repeating Sun-synchronous (GRSS) orbit to cover the entire Equator within the revisit interval.</p><p><strong>Args</strong></p><ul><li><code>h</code>: Orbit altitude in the Equator [m].</li><li><code>a</code>: Semi-major axis [m].</li><li><code>e</code>: Eccentricity.</li><li><code>i</code>: Inclination [rad].</li><li><code>To</code>: Orbit cycle [days].</li></ul><p><strong>Returns</strong></p><p>The minimum half FOV [rad].</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaSpace/SatelliteToolbox.jl/blob/c7a891ae8cbd18d844cb2ba648927c3c6dfa564f/src/analysis/payload_optical_analysis.jl#L33-L51">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="SatelliteToolbox.minimum_swath_grss-Tuple{Real, Real, Integer}" href="#SatelliteToolbox.minimum_swath_grss-Tuple{Real, Real, Integer}"><code>SatelliteToolbox.minimum_swath_grss</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">minimum_swath_grss(T::Real, i::Real, To::Integer)</code></pre><p>Compute the minimum swath of a ground repeating Sun-synchronous (GRSS) orbit to cover the entire Equator within the revisit interval.</p><p><strong>Args</strong></p><ul><li><code>T</code>: Orbit period [s].</li><li><code>i</code>: Inclination [rad].</li><li><code>To</code>: Orbit cycle [days].</li></ul><p><strong>Returns</strong></p><p>The minimum swath [m].</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaSpace/SatelliteToolbox.jl/blob/c7a891ae8cbd18d844cb2ba648927c3c6dfa564f/src/analysis/payload_optical_analysis.jl#L56-L72">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="SatelliteToolbox.minimum_swath_grss-Tuple{Real, Real, Real, Integer}" href="#SatelliteToolbox.minimum_swath_grss-Tuple{Real, Real, Real, Integer}"><code>SatelliteToolbox.minimum_swath_grss</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">minimum_swath_grss(a::Real, e::Real, i::Real, To::Integer)</code></pre><p>Compute the minimum swath of a ground repeating Sun-synchronous (GRSS) orbit to cover the entire Equator within the revisit interval.</p><p><strong>Args</strong></p><ul><li><code>a</code>: Semi-major axis [m].</li><li><code>e</code>: Eccentricity.</li><li><code>i</code>: Inclination [rad].</li><li><code>To</code>: Orbit cycle [days].</li></ul><p><strong>Returns</strong></p><p>The minimum swath [m].</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaSpace/SatelliteToolbox.jl/blob/c7a891ae8cbd18d844cb2ba648927c3c6dfa564f/src/analysis/payload_optical_analysis.jl#L77-L94">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="SatelliteToolbox.moon_position_i-Tuple{Number}" href="#SatelliteToolbox.moon_position_i-Tuple{Number}"><code>SatelliteToolbox.moon_position_i</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">moon_position_i(JD_TDB::Number[, model])</code></pre><p>Compute the Moon position represented in the IAU-76/FK5 MOD (mean-equator, mean-equinox of date) at the Julian Day <code>JD_TDB</code> (Barycentric Dynamical Time).</p><p>The <code>model</code> must be <code>Val(:Meeus)</code> or <code>Val(:Vallado)</code>. <code>Val(:Meeus)</code> uses the algorithm in [2, p. 337] that provides an accuracy of 10&quot; in the longitude and 4&quot; in the latitude (the reference does not mention the timespan). <code>Val(:fast)</code> uses the algorithm in [1, p. 288] that is 10x faster than <code>Val(:Meeus)</code> but can lead to errors of 0.3° in longitude and 0.2° in latitude.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaSpace/SatelliteToolbox.jl/blob/c7a891ae8cbd18d844cb2ba648927c3c6dfa564f/src/moon/moon_position.jl#L23-L35">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="SatelliteToolbox.nrlmsise00-NTuple{4, Number}" href="#SatelliteToolbox.nrlmsise00-NTuple{4, Number}"><code>SatelliteToolbox.nrlmsise00</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">nrlmsise00(JD::Number, alt::Number, g_lat::Number, g_long::Number [, f107A::Number, f107::Number, ap::Union{Number,AbstractVector}]; output_si::Bool = true, dversion::Bool = true)</code></pre><p><strong>NRLMSISE-00</strong></p><p>Neutral Atmosphere Empirical Model from the surface to lower exosphere.</p><p>This routine computes the NRLMSISE-00 outputs (see <code>NRLMSISE00_Output</code>) using the configurations in the structure <code>nrlmsise00</code> (see <code>NRLMSISE00_Structure</code>).</p><p>Notice that the NRLMSISE-00 will be run using the default flags (see <code>NRLMSISE00_DEFAULT_FLAGS</code>). The user can only change the value of <code>flags[:output_m_kg]</code> using the keyword <code>output_si</code> to select whether the output must be converted to SI units. If more control is needed, then the user must manually call the function <code>conf_nrlmsise00</code> and then call <code>gtd7</code> or <code>gtd7d</code> with the desired flags.</p><p>If the space indices <code>f107A</code>, <code>f107</code>, and <code>ap</code> are missing, then they will be obtained from the online databases (see <code>init_space_indices()</code>).</p><p><strong>Args</strong></p><ul><li><code>JD</code>: Julian Day [UTC].</li><li><code>alt</code>: Altitude [m].</li><li><code>g_lat</code>: Geodetic latitude [rad].</li><li><code>g_long</code>: Geodetic longitude [rad].</li><li><code>f107A</code>: 81 day average of F10.7 flux (centered on day of year <code>JD</code>).</li><li><code>f107</code>: Daily F10.7 flux for previous day.</li><li><code>ap</code>: Magnetic index (daily) if it is a number. If it is an array, then see       <strong>Remarks</strong>.</li></ul><p><strong>Keywords</strong></p><ul><li><code>output_si</code>: (OPTIONAL) If <code>true</code>, then the output units will be [m⁻³] for              species number density and [kg/m⁻³] for the total density.              Otherwise, the units will be [cm⁻³] and [g/cm⁻³], respectively.</li><li><code>dversion</code>: (OPTIONAL) If <code>true</code>, run <code>gtd7d</code>. Otherwise, run <code>gtd7</code> (see             <strong>Remarks</strong>).</li></ul><p><strong>Returns</strong></p><p>An instance of the structure <code>NRLMSISE00_Output</code>. The result in variable <code>den_Total</code> depends on the value of <code>dversion</code> (see <strong>Remarks</strong>, <strong>Notes on input variables</strong>).</p><p><strong>Remarks</strong></p><ol><li>The densities of <code>O</code>, <code>H</code>, and <code>N</code> are set to <code>0</code> below <code>72.5 km</code>.</li><li>The exospheric temperature <code>T_exo</code> is set to global average for altitudes below <code>120 km</code>. The <code>120 km</code> gradient is left at global average value for altitudes below <code>72.5 km</code>.</li><li>Anomalous oxygen is defined as hot atomic oxygen or ionized oxygen that can become appreciable at high altitudes (<code>&gt; 500 km</code>) for some ranges of inputs, thereby affection drag on satellites and debris. We group these species under the term <strong>Anomalous Oxygen</strong>, since their individual variations are not presently separable with the drag data used to define this model component.</li></ol><p><strong>AP</strong></p><p>If <code>ap</code> is a <code>Vector</code>, then it must be a vector with 7 dimensions as described below:</p><table><tr><th style="text-align: right">Index</th><th style="text-align: left">Description</th></tr><tr><td style="text-align: right">1</td><td style="text-align: left">Daily AP.</td></tr><tr><td style="text-align: right">2</td><td style="text-align: left">3 hour AP index for current time.</td></tr><tr><td style="text-align: right">3</td><td style="text-align: left">3 hour AP index for 3 hours before current time.</td></tr><tr><td style="text-align: right">4</td><td style="text-align: left">3 hour AP index for 6 hours before current time.</td></tr><tr><td style="text-align: right">5</td><td style="text-align: left">3 hour AP index for 9 hours before current time.</td></tr><tr><td style="text-align: right">6</td><td style="text-align: left">Average of eight 3 hour AP indices from 12 to 33 hours prior to current time.</td></tr><tr><td style="text-align: right">7</td><td style="text-align: left">Average of eight 3 hour AP indices from 36 to 57 hours prior to current time.</td></tr></table><p><strong>Notes on input variables</strong></p><p><code>f107</code> and <code>f107A</code> values used to generate the model correspond to the 10.7 cm radio flux at the actual distance of the Earth from the Sun rather than the radio flux at 1 AU. The following site provides both classes of values:</p><pre><code class="language-none">ftp://ftp.ngdc.noaa.gov/STP/SOLAR_DATA/SOLAR_RADIO/FLUX/</code></pre><p><code>f107</code>, <code>f107A</code>, and <code>ap</code> effects are neither large nor well established below 80 km and these parameters should be set to 150, 150, and 4 respectively.</p><p>If <code>dversion</code> is <code>true</code>, then the total mass <code>den_Total</code> (see <code>NRLMSISE00_Output</code>) is the sum of the mass densities of the species <code>He</code>, <code>O</code>, <code>N₂</code>, <code>O₂</code>, <code>Ar</code>, <code>H</code>, and <code>N</code>, but <strong>does not</strong> include anomalous oxygen.</p><p>If <code>dversion</code> is <code>false</code>, then total mass <code>den_Total</code> (see <code>NRLMSISE00_Output</code>) is the effective total mass density for drag and is the sum of the mass densities of all species in this model <strong>including</strong> the anomalous oxygen.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaSpace/SatelliteToolbox.jl/blob/c7a891ae8cbd18d844cb2ba648927c3c6dfa564f/src/earth/atmospheric_models/nrlmsise00/nrlmsise00.jl#L56-L147">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="SatelliteToolbox.nutation_eo_iau2006" href="#SatelliteToolbox.nutation_eo_iau2006"><code>SatelliteToolbox.nutation_eo_iau2006</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">nutation_eo_iau2006(JD_TT::Number)</code></pre><p>Compute the nutation parameters and the Equation of Origins (EO) at the Julian Day <code>JD_TT</code> [TT] using the equinox-based 2006 IAU Theory of Nutation. Notice that one can provide corrections for the nutation in obliquity (<code>δΔϵ_2000</code>) [rad] and in longitude (<code>δΔψ_2000</code>) [rad] that are usually obtained from IERS EOP Data (see <code>get_iers_eop</code>).</p><p><strong>Returns</strong></p><ul><li>The mean obliquity of the ecliptic [rad].</li><li>The nutation in obliquity of the ecliptic [rad].</li><li>The nutation in longitude [rad].</li><li>The Equation of Origins (EO) [rad].</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaSpace/SatelliteToolbox.jl/blob/c7a891ae8cbd18d844cb2ba648927c3c6dfa564f/src/transformations/iau2006/nutation_eo.jl#L69-L85">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="SatelliteToolbox.nutation_fk5" href="#SatelliteToolbox.nutation_fk5"><code>SatelliteToolbox.nutation_fk5</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">nutation_fk5(JD_TT::Number, n_max::Number = 106, nut_coefs_1980::Matrix = nut_coefs_1980)</code></pre><p>Compute the nutation parameters at the Julian Day <code>JD_TT</code> [Terrestrial Time] using the 1980 IAU Theory of Nutation. The coefficients are <code>nut_coefs_1980</code> that must be a matrix in which each line has the following syntax [1, p. 1043]:</p><pre><code class="language-none">an1  an2  an3  an4  an5  Ai  Bi  Ci  Di</code></pre><p>where the units of <code>Ai</code> and <code>Ci</code> are [0.0001&quot;] and the units of <code>Bi</code> and <code>Di</code> are [0.0001&quot;/JC]. The user can also specify the number of coefficients <code>n_max</code> that will be used when computing the nutation. If <code>n_max</code> is omitted, the it defaults to 106.</p><p><strong>Returns</strong></p><ul><li>The mean obliquity of the ecliptic [rad].</li><li>The nutation in obliquity of the ecliptic [rad].</li><li>The nutation in longitude [rad].</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaSpace/SatelliteToolbox.jl/blob/c7a891ae8cbd18d844cb2ba648927c3c6dfa564f/src/transformations/fk5/nutation.jl#L162-L182">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="SatelliteToolbox.orbsv-Union{Tuple{T4}, Tuple{T3}, Tuple{T2}, Tuple{T1}, Tuple{T1, AbstractVector{T2}, AbstractVector{T3}}, Tuple{T1, AbstractVector{T2}, AbstractVector{T3}, AbstractVector{T4}}} where {T1&lt;:Number, T2&lt;:Number, T3&lt;:Number, T4&lt;:Number}" href="#SatelliteToolbox.orbsv-Union{Tuple{T4}, Tuple{T3}, Tuple{T2}, Tuple{T1}, Tuple{T1, AbstractVector{T2}, AbstractVector{T3}}, Tuple{T1, AbstractVector{T2}, AbstractVector{T3}, AbstractVector{T4}}} where {T1&lt;:Number, T2&lt;:Number, T3&lt;:Number, T4&lt;:Number}"><code>SatelliteToolbox.orbsv</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">orbsv(t::T1, r::AbstractVector{T2}, v::AbstractVector{T3} = [0,0,0], a::AbstractVector{T4} = [0,0,0]) where {T1&lt;:Number, T2&lt;:Number, T3&lt;:Number, T4&lt;:Number}
orbsv(t::T1, vec::AbstractVector{T2}) where {T1&lt;:Number, T2&lt;:Number}</code></pre><p>Create a new satellite state vector (see <code>OrbitStateVector</code>) using the position <code>r</code>, velocity <code>v</code>, and acceleration <code>a</code>. It is also possible to pass a vector <code>vec</code> with the information concatenated.</p><div class="admonition is-info"><header class="admonition-header">Info</header><div class="admonition-body"><p>The vectors <code>r</code>, <code>v</code>, and <code>a</code> must have at least 3 elements. In the case more elements are available, they will be neglected. On the other hand, the vector <code>v</code> must have 6 or 9 dimensions, indicating <code>[r;v]</code>, or <code>[r;v;a]</code>.</p></div></div></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaSpace/SatelliteToolbox.jl/blob/c7a891ae8cbd18d844cb2ba648927c3c6dfa564f/src/orbit/representations/state_vector.jl#L45-L59">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="SatelliteToolbox.parse_icgem-Tuple{AbstractString}" href="#SatelliteToolbox.parse_icgem-Tuple{AbstractString}"><code>SatelliteToolbox.parse_icgem</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">parse_icgem(filename::AbstractString)</code></pre><p>Parse the ICGEM file <code>filename</code> and return an instance of the structure <code>ICGEM</code> with the parsed data.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaSpace/SatelliteToolbox.jl/blob/c7a891ae8cbd18d844cb2ba648927c3c6dfa564f/src/misc/icgem.jl#L60-L66">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="SatelliteToolbox.period" href="#SatelliteToolbox.period"><code>SatelliteToolbox.period</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">period(a::Number, e::Number, i::Number, pert::Symbol = :J2)</code></pre><p>Compute the period [s] of an object in an orbit with semi-major axis <code>a</code> [m], eccentricity <code>e</code>, and inclination <code>i</code> [rad], using the perturbation terms specified by the symbol <code>pert</code>. The orbit can also be specified by <code>orb</code> (see <a href="#SatelliteToolbox.Orbit"><code>Orbit</code></a>).</p><p>pert` can be:</p><ul><li><code>:J0</code>: Consider a Keplerian orbit.</li><li><code>:J2</code>: Consider the perturbation terms up to J2.</li><li><code>:J4</code>: Consider the perturbation terms J2, J4, and J2².</li></ul><p>If <code>pert</code> is omitted, then it defaults to <code>:J2</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaSpace/SatelliteToolbox.jl/blob/c7a891ae8cbd18d844cb2ba648927c3c6dfa564f/src/orbit/general.jl#L417-L433">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="SatelliteToolbox.planetary_args_iau2006-Tuple{Number}" href="#SatelliteToolbox.planetary_args_iau2006-Tuple{Number}"><code>SatelliteToolbox.planetary_args_iau2006</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">planetary_args_iau2006(JD_TT::Number)</code></pre><p>Compute the fundamental arguments related to the planetary effects for the IAU-2006 theory [1, p. 211].</p><p>The returned values are in [rad].</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaSpace/SatelliteToolbox.jl/blob/c7a891ae8cbd18d844cb2ba648927c3c6dfa564f/src/transformations/iau2006/fundamental_args.jl#L61-L69">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="SatelliteToolbox.precession_fk5-Tuple{Number}" href="#SatelliteToolbox.precession_fk5-Tuple{Number}"><code>SatelliteToolbox.precession_fk5</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">precession_fk5(JD_TT::Number)</code></pre><p>Compute the angles related to the precession movement in the Julian Day <code>JD_TT</code> [Terrestrial Time] using the theory IAU-76/FK5.</p><p><strong>Returns</strong></p><p>The angles (ζ, Θ, z) as described in [1, p. 226-228].</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaSpace/SatelliteToolbox.jl/blob/c7a891ae8cbd18d844cb2ba648927c3c6dfa564f/src/transformations/fk5/precession.jl#L22-L32">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="SatelliteToolbox.precession_iau2006-Tuple{Number}" href="#SatelliteToolbox.precession_iau2006-Tuple{Number}"><code>SatelliteToolbox.precession_iau2006</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">precession_iau2006(JD_TT::Number)</code></pre><p>Compute the precession angles [rad] according to equinox-based IAU-2006 theory in the Julia day <code>JD_TT</code> [Terrestrial Time].</p><p>This algorithm was obtained from [3, p. 49].</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaSpace/SatelliteToolbox.jl/blob/c7a891ae8cbd18d844cb2ba648927c3c6dfa564f/src/transformations/iau2006/precession.jl#L27-L35">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="SatelliteToolbox.propagate!" href="#SatelliteToolbox.propagate!"><code>SatelliteToolbox.propagate!</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">propagate!(orbp::OrbitPropagator{T}, t::Number) where T
propagate!(orbp::OrbitPropagator{T}, t::AbstractVector) where T</code></pre><p>If <code>t</code> is a number, then propagate <code>orbp</code> by <code>t</code> [s] from the orbit epoch. Otherwise, if <code>t</code> is an array, then propagate the orbit in <code>orbp</code> using the time instants defined in the vector <code>t</code> [s].</p><p>In both cases, the orbit propagator algorithm is the one related to the structure <code>orbp</code>.</p><p><strong>Returns</strong></p><ul><li>The position vector represented in inertial frame in each time instant [m].</li><li>The velocity vector represented in inertial frame in each time instant [m].</li></ul><p>If <code>t</code> is an array, then those values will be an array containing the information related to each epoch in <code>t</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaSpace/SatelliteToolbox.jl/blob/c7a891ae8cbd18d844cb2ba648927c3c6dfa564f/src/orbit/propagators/api/api.jl#L40-L59">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="SatelliteToolbox.propagate_to_epoch!-Union{Tuple{T}, Tuple{OrbitPropagator, Union{Number, AbstractVector{T} where T}}} where T" href="#SatelliteToolbox.propagate_to_epoch!-Union{Tuple{T}, Tuple{OrbitPropagator, Union{Number, AbstractVector{T} where T}}} where T"><code>SatelliteToolbox.propagate_to_epoch!</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">propagate_to_epoch!(orbp::OrbitPropagator{T}, JD::Number) where T
propagate_to_epoch!(orbp::OrbitPropagator{T}, JD::AbstractVector) where T</code></pre><p>If <code>t</code> is a number, then propagate <code>orbp</code> until the epoch <code>JD</code> [Julian Day]. Otherwise, if <code>JD</code> is an array, then propagate the orbit in <code>orbp</code> using the epochs defined in the vector <code>t</code> [Julian Day].</p><p>In both cases, the orbit propagator algorithm is the one related to the structure <code>orbp</code>.</p><p><strong>Returns</strong></p><ul><li>The position vector represented in inertial frame in each time instant [m].</li><li>The velocity vector represented in inertial frame in each time instant [m].</li></ul><p>If <code>JD</code> is an array, then those values will be an array containing the information related to each epoch in <code>JD</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaSpace/SatelliteToolbox.jl/blob/c7a891ae8cbd18d844cb2ba648927c3c6dfa564f/src/orbit/propagators/api/api.jl#L79-L98">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="SatelliteToolbox.r_cirs_to_gcrf_iau2006" href="#SatelliteToolbox.r_cirs_to_gcrf_iau2006"><code>SatelliteToolbox.r_cirs_to_gcrf_iau2006</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">r_cirs_to_gcrf_iau2006([T::Type,] JD_TT::Number, dX::Number = 0, dY::Number = 0)</code></pre><p>Compute the rotation that aligns the Celestial Intermediate Reference System (CIRS) with the Geocentric Celestial Reference Frame (GCRF) at the Julian Day <code>JD_TT</code> [TT] and considering the IERS EOP Data <code>dX</code> [rad] and <code>dY</code> [rad] (see <code>get_iers_eop</code>). This algorithm uses the IAU-2006 theory.</p><p>The IERS EOP Data <code>dX</code> and <code>dY</code> accounts for the free-core nutation and time dependent effects of the Celestial Intermediate Pole (CIP) position with respect to the GCRF.</p><p>The rotation type is described by the optional variable <code>T</code>. If it is <code>DCM</code>, then a DCM will be returned. Otherwise, if it is <code>Quaternion</code>, then a Quaternion will be returned. In case this parameter is omitted, then it falls back to <code>DCM</code>.</p><p><strong>Returns</strong></p><p>The rotation that aligns the CIRS frame with the GCRF frame. The rotation representation is selected by the optional parameter <code>T</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaSpace/SatelliteToolbox.jl/blob/c7a891ae8cbd18d844cb2ba648927c3c6dfa564f/src/transformations/iau2006/iau2006_cio.jl#L255-L277">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="SatelliteToolbox.r_cirs_to_tirs_iau2006-Tuple{Number}" href="#SatelliteToolbox.r_cirs_to_tirs_iau2006-Tuple{Number}"><code>SatelliteToolbox.r_cirs_to_tirs_iau2006</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">r_cirs_to_tirs_iau2006([T::Type,] JD_UT1::Number)</code></pre><p>Compute the rotation that aligns the Celestial Intermediate Reference System (CIRS) with the Terrestrial Intermediate Reference System (TIRS) at the Julian Day <code>JD_UT1</code> [UT1]. This algorithm uses the IAU-2006 theory.</p><p>The rotation type is described by the optional variable <code>T</code>. If it is <code>DCM</code>, then a DCM will be returned. Otherwise, if it is <code>Quaternion</code>, then a Quaternion will be returned. In case this parameter is omitted, then it falls back to <code>DCM</code>.</p><p><strong>Returns</strong></p><p>The rotation that aligns the CIRS frame with the TIRS frame. The rotation representation is selected by the optional parameter <code>T</code>.</p><p><strong>Remarks</strong></p><p>The reference frames TIRS and CIRS are separated by a rotation about the Z-axis of the Earth Rotation Angle, which is the angle between the Conventional International Origin (CIO) and the Terrestrial Intermediate Origin (TIO) [1]. The latter is a reference meridian on Earth that is located about 100m away from Greenwich meridian along the equator of the Celestial Intermediate Pole (CIP) [1].</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaSpace/SatelliteToolbox.jl/blob/c7a891ae8cbd18d844cb2ba648927c3c6dfa564f/src/transformations/iau2006/iau2006_cio.jl#L211-L237">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="SatelliteToolbox.r_ecef_to_ecef-Tuple{Union{Val{:ITRF}, Val{:PEF}}, Union{Val{:ITRF}, Val{:PEF}}, Number, EOPData_IAU1980}" href="#SatelliteToolbox.r_ecef_to_ecef-Tuple{Union{Val{:ITRF}, Val{:PEF}}, Union{Val{:ITRF}, Val{:PEF}}, Number, EOPData_IAU1980}"><code>SatelliteToolbox.r_ecef_to_ecef</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">r_ecef_to_ecef([T,] ECEFo, ECEFf, JD_UTC::Number, eop_data)</code></pre><p>Compute the rotation from an Earth-Centered, Earth-Fixed (<code>ECEF</code>) reference frame to another ECEF reference frame at the Julian Day [UTC] <code>JD_UTC</code>. The rotation description that will be used is given by <code>T</code>, which can be <code>DCM</code> or <code>Quaternion</code>. The origin ECEF frame is selected by the input <code>ECEFo</code> and the destination ECEF frame is selected by the input <code>ECEFf</code>. The model used to compute the rotation is specified by the selection of the origin and destination frames. Currently, there are two models supported: IAU-76/FK5 and IAU-2006 with 2010 conventions (CIO approach only).</p><p><strong>Rotation description</strong></p><p>The rotations that aligns the origin ECEF frame with the destination ECEF frame can be described by Direction Cosine Matrices or Quaternions. This is selected by the parameter <code>T</code>.</p><p>The possible values are:</p><ul><li><code>DCM</code>: The rotation will be described by a Direction Cosine Matrix.</li><li><code>Quaternion</code>: The rotation will be described by a Quaternion.</li></ul><p>If no value is specified, then it falls back to <code>DCM</code>.</p><p><strong>Conversion model</strong></p><p>The model that will be used to compute the rotation is automatically inferred given the selection of the origin and destination frames. <strong>Notice that mixing IAU-76/FK5 and IAU-2006/2010 frames is not supported yet.</strong></p><p><strong>ECEF Frame</strong></p><p>The supported ECEF frames for both origin <code>ECEFo</code> and destination <code>ECEFf</code> are:</p><ul><li><code>ITRF()</code>: ECEF will be selected as the International Terrestrial Reference           Frame (ITRF).</li><li><code>PEF()</code>: ECEF will be selected as the Pseudo-Earth Fixed (PEF) reference          frame.</li><li><code>TIRS()</code>: ECEF will be selected as the Terrestrial Intermediate Reference           System (TIRS).</li></ul><p><strong>EOP Data</strong></p><p>The conversion between the supported ECEF frames <strong>always</strong> depends on EOP Data (see <code>get_iers_eop</code> and <code>read_iers_eop</code>). If IAU-76/FK5 model is used, then the type of <code>eop_data</code> must be <code>EOPData_IAU1980</code>. Otherwise, if IAU-2006/2010 model is used, then the type of <code>eop_data</code> must be <code>EOPData_IAU2000A</code>.</p><p><strong>Returns</strong></p><p>The rotation description represented by <code>T</code> that rotates the ECEF reference frame into alignment with the ECI reference frame.</p><p><strong>Examples</strong></p><pre><code class="language-julia-repl">julia&gt; eop_IAU1980 = get_iers_eop(:IAU1980);

julia&gt; r_ecef_to_ecef(PEF(), ITRF(), date_to_jd(1986,6,19,21,35,0), eop_IAU1980)
3×3 StaticArrays.SArray{Tuple{3,3},Float64,2,9}:
  1.0          0.0         4.35684e-7
  0.0          1.0         1.44762e-6
 -4.35684e-7  -1.44762e-6  1.0

julia&gt; r_ecef_to_ecef(Quaternion, PEF(), ITRF(), date_to_jd(1986,6,19,21,35,0), eop_IAU1980)
Quaternion{Float64}:
  + 0.9999999999997147 - 7.236343481310813e-7.i + 2.1765518308012794e-7.j + 0.0.k

julia&gt; eop_IAU2000A = get_iers_eop(:IAU2000A);

julia&gt; r_ecef_to_ecef(TIRS(), ITRF(), date_to_jd(1986,6,19,21,35,0), eop_IAU2000A)
3×3 StaticArrays.SArray{Tuple{3,3},Float64,2,9}:
  1.0          3.08408e-11  -4.3531e-7
 -3.14708e-11  1.0          -1.44727e-6
  4.3531e-7    1.44727e-6    1.0

julia&gt; r_ecef_to_ecef(Quaternion, TIRS(), ITRF(), date_to_jd(1986,6,19,21,35,0), eop_IAU2000A)
Quaternion{Float64}:
  + 0.9999999999997146 - 7.236343481345639e-7.i + 2.176551830689726e-7.j + 1.5577911634233308e-11.k</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaSpace/SatelliteToolbox.jl/blob/c7a891ae8cbd18d844cb2ba648927c3c6dfa564f/src/transformations/ecef_to_ecef.jl#L21-L102">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="SatelliteToolbox.r_ecef_to_eci-Tuple{Union{Val{:ITRF}, Val{:PEF}}, Union{Val{:GCRF}, Val{:J2000}, Val{:TOD}, Val{:MOD}, Val{:TEME}}, Number, EOPData_IAU1980}" href="#SatelliteToolbox.r_ecef_to_eci-Tuple{Union{Val{:ITRF}, Val{:PEF}}, Union{Val{:GCRF}, Val{:J2000}, Val{:TOD}, Val{:MOD}, Val{:TEME}}, Number, EOPData_IAU1980}"><code>SatelliteToolbox.r_ecef_to_eci</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">r_ecef_to_eci([T,] ECEF, ECI, JD_UTC::Number [, eop_data])</code></pre><p>Compute the rotation from an Earth-Centered, Earth-Fixed (<code>ECEF</code>) reference frame to an Earth-Centered Inertial (<code>ECI</code>) reference frame at the Julian Day [UTC] <code>JD_UTC</code>. The rotation description that will be used is given by <code>T</code>, which can be <code>DCM</code> or <code>Quaternion</code>. The ECEF frame is selected by the input <code>ECEF</code> and the <code>ECI</code> frame is selected by the input <code>ECI</code>. The possible values are listed below. The model used to compute the rotation is specified by the selection of the origin and destination frames. Currently, there are two models supported: IAU-76/FK5 and IAU-2006 with 2010 conventions (CIO and equinox approaches).</p><p><strong>Rotation description</strong></p><p>The rotations that aligns the ECEF with ECI can be described by Direction Cosine Matrices or Quaternions. This is selected by the parameter <code>T</code>. The possible values are:</p><ul><li><code>DCM</code>: The rotation will be described by a Direction Cosine Matrix.</li><li><code>Quaternion</code>: The rotation will be described by a Quaternion.</li></ul><p>If no value is specified, then it falls back to <code>DCM</code>.</p><p><strong>Conversion model</strong></p><p>The model that will be used to compute the rotation is automatically inferred given the selection of the origin and destination frames. <strong>Notice that mixing IAU-76/FK5 and IAU-2006/2010 frames is not supported yet.</strong></p><p><strong>ECEF Frame</strong></p><p>The ECEF frame is selected by the parameter <code>ECEF</code>. The possible values are:</p><ul><li><code>ITRF()</code>: ECEF will be selected as the International Terrestrial Reference           Frame (ITRF).</li><li><code>PEF()</code>: ECEF will be selected as the Pseudo-Earth Fixed (PEF) reference          frame.</li><li><code>TIRS()</code>: ECEF will be selected as the Terrestrial Intermediate Reference           System (TIRS).</li></ul><p><strong>ECI Frame</strong></p><p>The ECI frame is selected by the parameter <code>ECI</code>. The possible values are:</p><ul><li><code>TEME()</code>: ECI will be selected as the True Equator Mean Equinox (TEME)           reference frame.</li><li><code>TOD()</code>: ECI will be selected as the True of Date (TOD).</li><li><code>MOD()</code>: ECI will be selected as the Mean of Date (MOD).</li><li><code>J2000()</code>: ECI will be selected as the J2000 reference frame.</li><li><code>GCRF()</code>: ECI will be selected as the Geocentric Celestial Reference Frame           (GCRF).</li><li><code>CIRS()</code>: ECI will be selected as the Celestial Intermediate Reference System           (CIRS).</li><li><code>ERS()</code>: ECI will be selected as the Earth Reference System (ERS).</li><li><code>MOD06()</code>: ECI will be selected as the Mean of Date (MOD) according to the            definition in IAU-2006/2010 theory.</li><li><code>MJ2000()</code>: ECI will be selected as the J2000 mean equatorial frame (MJ2000).</li></ul><div class="admonition is-info"><header class="admonition-header">Note</header><div class="admonition-body"><p>The frames <code>MOD()</code> and <code>MOD06()</code> are virtually the same. However, we selected different names to make clear which theory are being used since mixing transformation between frames from IAU-76/FK5 and IAU-2006/2010 must be performed with caution.</p></div></div><p><strong>EOP Data</strong></p><p>The conversion between the frames depends on EOP Data (see <code>get_iers_eop</code> and <code>read_iers_eop</code>). If IAU-76/FK5 model is used, then the type of <code>eop_data</code> must be <code>EOPData_IAU1980</code>. Otherwise, if IAU-2006/2010 model is used, then the type of <code>eop_data</code> must be <code>EOPData_IAU2000A</code>. The following table shows the requirements for EOP data given the selected frames.</p><table><tr><th style="text-align: left">Model</th><th style="text-align: left">ECEF</th><th style="text-align: left">ECI</th><th style="text-align: left">EOP Data</th></tr><tr><td style="text-align: left">IAU-76/FK5</td><td style="text-align: left"><code>ITRF</code></td><td style="text-align: left"><code>GCRF</code></td><td style="text-align: left">EOP IAU1980</td></tr><tr><td style="text-align: left">IAU-76/FK5</td><td style="text-align: left"><code>ITRF</code></td><td style="text-align: left"><code>J2000</code></td><td style="text-align: left">EOP IAU1980</td></tr><tr><td style="text-align: left">IAU-76/FK5</td><td style="text-align: left"><code>ITRF</code></td><td style="text-align: left"><code>MOD</code></td><td style="text-align: left">EOP IAU1980</td></tr><tr><td style="text-align: left">IAU-76/FK5</td><td style="text-align: left"><code>ITRF</code></td><td style="text-align: left"><code>TOD</code></td><td style="text-align: left">EOP IAU1980</td></tr><tr><td style="text-align: left">IAU-76/FK5</td><td style="text-align: left"><code>ITRF</code></td><td style="text-align: left"><code>TEME</code></td><td style="text-align: left">EOP IAU1980</td></tr><tr><td style="text-align: left">IAU-76/FK5</td><td style="text-align: left"><code>PEF</code></td><td style="text-align: left"><code>GCRF</code></td><td style="text-align: left">EOP IAU1980</td></tr><tr><td style="text-align: left">IAU-76/FK5</td><td style="text-align: left"><code>PEF</code></td><td style="text-align: left"><code>J2000</code></td><td style="text-align: left">Not required¹</td></tr><tr><td style="text-align: left">IAU-76/FK5</td><td style="text-align: left"><code>PEF</code></td><td style="text-align: left"><code>MOD</code></td><td style="text-align: left">Not required¹</td></tr><tr><td style="text-align: left">IAU-76/FK5</td><td style="text-align: left"><code>PEF</code></td><td style="text-align: left"><code>TOD</code></td><td style="text-align: left">Not required¹</td></tr><tr><td style="text-align: left">IAU-76/FK5</td><td style="text-align: left"><code>PEF</code></td><td style="text-align: left"><code>TEME</code></td><td style="text-align: left">Not required¹</td></tr><tr><td style="text-align: left">IAU-2006/2010 CIO-based</td><td style="text-align: left"><code>ITRF</code></td><td style="text-align: left"><code>CIRS</code></td><td style="text-align: left">EOP IAU2000A</td></tr><tr><td style="text-align: left">IAU-2006/2010 CIO-based</td><td style="text-align: left"><code>ITRF</code></td><td style="text-align: left"><code>GCRF</code></td><td style="text-align: left">EOP IAU2000A</td></tr><tr><td style="text-align: left">IAU-2006/2010 CIO-based</td><td style="text-align: left"><code>TIRS</code></td><td style="text-align: left"><code>CIRS</code></td><td style="text-align: left">Not required¹</td></tr><tr><td style="text-align: left">IAU-2006/2010 CIO-based</td><td style="text-align: left"><code>TIRS</code></td><td style="text-align: left"><code>GCRF</code></td><td style="text-align: left">Not required¹ ²</td></tr><tr><td style="text-align: left">IAU-2006/2010 Equinox-based</td><td style="text-align: left"><code>ITRF</code></td><td style="text-align: left"><code>ERS</code></td><td style="text-align: left">EOP IAU2000A</td></tr><tr><td style="text-align: left">IAU-2006/2010 Equinox-based</td><td style="text-align: left"><code>ITRF</code></td><td style="text-align: left"><code>MOD06</code></td><td style="text-align: left">EOP IAU2000A</td></tr><tr><td style="text-align: left">IAU-2006/2010 Equinox-based</td><td style="text-align: left"><code>ITRF</code></td><td style="text-align: left"><code>MJ2000</code></td><td style="text-align: left">EOP IAU2000A</td></tr><tr><td style="text-align: left">IAU-2006/2010 Equinox-based</td><td style="text-align: left"><code>TIRS</code></td><td style="text-align: left"><code>ERS</code></td><td style="text-align: left">Not required¹ ³</td></tr><tr><td style="text-align: left">IAU-2006/2010 Equinox-based</td><td style="text-align: left"><code>TIRS</code></td><td style="text-align: left"><code>MOD06</code></td><td style="text-align: left">Not required¹ ³</td></tr><tr><td style="text-align: left">IAU-2006/2010 Equinox-based</td><td style="text-align: left"><code>TIRS</code></td><td style="text-align: left"><code>MJ2000</code></td><td style="text-align: left">Not required¹ ³</td></tr></table><p><code>¹</code>: In this case, the Julian Time UTC will be assumed equal to Julian Time UT1 to compute the Greenwich Mean Sidereal Time. This is an approximation, but should be sufficiently accurate for some applications. Notice that, if EOP Data is provided, the Julian Day UT1 will be accurately computed.</p><p><code>²</code>: In this case, the terms that account for the free core nutation and time dependent effects of the Celestial Intermediate Pole (CIP) position with respect to the GCRF will not be available, reducing the precision.</p><p><code>³</code>: In this case, the terms that corrects the nutation in obliquity and in longitude due to the free core nutation will not be available, reducing the precision.</p><p><strong>MOD and TOD</strong></p><p>In this function, if EOP corrections are not provided, then MOD and TOD frames will be computed considering the original IAU-76/FK5 theory. Otherwise, the corrected frame will be used.</p><p><strong>Returns</strong></p><p>The rotation description represented by <code>T</code> that rotates the ECEF reference frame into alignment with the ECI reference frame.</p><p><strong>Examples</strong></p><pre><code class="language-julia-repl">julia&gt; eop_IAU1980 = get_iers_eop(:IAU1980);

julia&gt; r_ecef_to_eci(DCM, ITRF(), GCRF(), date_to_jd(1986, 06, 19, 21, 35, 0), eop_IAU1980)
3×3 StaticArrays.SArray{Tuple{3,3},Float64,2,9}:
 -0.619267      0.78518     -0.00132979
 -0.78518      -0.619267     3.33492e-5
 -0.000797313   0.00106478   0.999999

julia&gt; r_ecef_to_eci(ITRF(), GCRF(), date_to_jd(1986, 06, 19, 21, 35, 0), eop_IAU1980)
3×3 StaticArrays.SArray{Tuple{3,3},Float64,2,9}:
 -0.619267      0.78518     -0.00132979
 -0.78518      -0.619267     3.33492e-5
 -0.000797313   0.00106478   0.999999

julia&gt; r_ecef_to_eci(PEF(), J2000(), date_to_jd(1986, 06, 19, 21, 35, 0))
3×3 StaticArrays.SArray{Tuple{3,3},Float64,2,9}:
 -0.619271      0.785176    -0.00133066
 -0.785177     -0.619272     3.45854e-5
 -0.000796885   0.00106622   0.999999

julia&gt; r_ecef_to_eci(PEF(), J2000(), date_to_jd(1986, 06, 19, 21, 35, 0), eop_IAU1980)
3×3 StaticArrays.SArray{Tuple{3,3},Float64,2,9}:
 -0.619267      0.78518     -0.00133066
 -0.78518      -0.619267     3.45854e-5
 -0.000796879   0.00106623   0.999999

julia&gt; r_ecef_to_eci(Quaternion, ITRF(), GCRF(), date_to_jd(1986, 06, 19, 21, 35, 0), eop_IAU1980)
Quaternion{Float64}:
  + 0.4363098936462618 - 0.0005909969666939257.i + 0.00030510511316206974.j + 0.8997962182293519.k

julia&gt; eop_IAU2000A = get_iers_eop(:IAU2000A);

julia&gt; r_ecef_to_eci(ITRF(), GCRF(), date_to_jd(1986, 06, 19, 21, 35, 0), eop_IAU2000A)
3×3 StaticArrays.SArray{Tuple{3,3},Float64,2,9}:
 -0.619267      0.78518     -0.00132979
 -0.78518      -0.619267     3.33502e-5
 -0.000797312   0.00106478   0.999999

julia&gt; r_ecef_to_eci(TIRS(), GCRF(), date_to_jd(1986, 06, 19, 21, 35, 0))
3×3 StaticArrays.SArray{Tuple{3,3},Float64,2,9}:
 -0.619271      0.785176    -0.00133066
 -0.785177     -0.619272     3.45884e-5
 -0.000796885   0.00106623   0.999999

julia&gt; r_ecef_to_eci(Quaternion, ITRF(), GCRF(), date_to_jd(1986, 06, 19, 21, 35, 0), eop_IAU2000A)
Quaternion{Float64}:
  + 0.4363098936309669 - 0.000590996988144556.i + 0.0003051056555230158.j + 0.8997962182365703.k</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaSpace/SatelliteToolbox.jl/blob/c7a891ae8cbd18d844cb2ba648927c3c6dfa564f/src/transformations/ecef_to_eci.jl#L21-L193">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="SatelliteToolbox.r_eci_to_ecef-Tuple{Union{Val{:GCRF}, Val{:J2000}, Val{:TOD}, Val{:MOD}, Val{:TEME}}, Union{Val{:ITRF}, Val{:PEF}}, Number, EOPData_IAU1980}" href="#SatelliteToolbox.r_eci_to_ecef-Tuple{Union{Val{:GCRF}, Val{:J2000}, Val{:TOD}, Val{:MOD}, Val{:TEME}}, Union{Val{:ITRF}, Val{:PEF}}, Number, EOPData_IAU1980}"><code>SatelliteToolbox.r_eci_to_ecef</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">r_eci_to_ecef([T,] ECI, ECEF, JD_UTC::Number [, eop_data])</code></pre><p>Compute the rotation from an Earth-Centered Inertial (<code>ECI</code>) reference frame to an Earth-Centered, Earth-Fixed (<code>ECEF</code>) reference frame at the Julian Day [UTC] <code>JD_UTC</code>. The rotation description that will be used is given by <code>T</code>, which can be <code>DCM</code> or <code>Quaternion</code>. The ECI frame is selected by the input <code>ECI</code> and the <code>ECEF</code> frame is selected by the input <code>ECEF</code>. The possible values are listed below. The model used to compute the rotation is specified by the selection of the origin and destination frames. Currently, there are two models supported: IAU-76/FK5 and IAU-2006 with 2010 conventions (CIO and equinox approaches).</p><p><strong>Rotation description</strong></p><p>The rotations that aligns the ECI with ECEF can be described by Direction Cosine Matrices or Quaternions. This is selected by the parameter <code>T</code>. The possible values are:</p><ul><li><code>DCM</code>: The rotation will be described by a Direction Cosine Matrix.</li><li><code>Quaternion</code>: The rotation will be described by a Quaternion.</li></ul><p>If no value is specified, then it falls back to <code>DCM</code>.</p><p><strong>Conversion model</strong></p><p>The model that will be used to compute the rotation is automatically inferred given the selection of the origin and destination frames. <strong>Notice that mixing IAU-76/FK5 and IAU-2006/2010 frames is not supported yet.</strong></p><p><strong>ECI Frame</strong></p><p>The ECI frame is selected by the parameter <code>ECI</code>. The possible values are:</p><ul><li><code>TEME()</code>: ECI will be selected as the True Equator Mean Equinox (TEME)           reference frame.</li><li><code>TOD()</code>: ECI will be selected as the True of Date (TOD).</li><li><code>MOD()</code>: ECI will be selected as the Mean of Date (MOD).</li><li><code>J2000()</code>: ECI will be selected as the J2000 reference frame.</li><li><code>GCRF()</code>: ECI will be selected as the Geocentric Celestial Reference Frame           (GCRF).</li><li><code>CIRS()</code>: ECEF will be selected as the Celestial Intermediate Reference System           (CIRS).</li><li><code>ERS()</code>: ECI will be selected as the Earth Reference System (ERS).</li><li><code>MOD06()</code>: ECI will be selected as the Mean of Date (MOD) according to the            definition in IAU-2006/2010 theory.</li><li><code>MJ2000()</code>: ECI will be selected as the J2000 mean equatorial frame (MJ2000).</li></ul><div class="admonition is-info"><header class="admonition-header">Note</header><div class="admonition-body"><p>The frames <code>MOD()</code> and <code>MOD06()</code> are virtually the same. However, we selected different names to make clear which theory are being used since mixing transformation between frames from IAU-76/FK5 and IAU-2006/2010 must be performed with caution.</p></div></div><p><strong>ECEF Frame</strong></p><p>The ECEF frame is selected by the parameter <code>ECEF</code>. The possible values are:</p><ul><li><code>ITRF()</code>: ECEF will be selected as the International Terrestrial Reference           Frame (ITRF).</li><li><code>PEF()</code>: ECEF will be selected as the Pseudo-Earth Fixed (PEF) reference          frame.</li><li><code>TIRS()</code>: ECEF will be selected as the Terrestrial Intermediate Reference           System (TIRS).</li></ul><p><strong>EOP Data</strong></p><p>The conversion between the frames depends on EOP Data (see <code>get_iers_eop</code> and <code>read_iers_eop</code>). If IAU-76/FK5 model is used, then the type of <code>eop_data</code> must be <code>EOPData_IAU1980</code>. Otherwise, if IAU-2006/2010 model is used, then the type of <code>eop_data</code> must be <code>EOPData_IAU2000A</code>. The following table shows the requirements for EOP data given the selected frames.</p><table><tr><th style="text-align: left">Model</th><th style="text-align: left">ECI</th><th style="text-align: left">ECEF</th><th style="text-align: left">EOP Data</th></tr><tr><td style="text-align: left">IAU-76/FK5</td><td style="text-align: left"><code>GCRF</code></td><td style="text-align: left"><code>ITRF</code></td><td style="text-align: left">EOP IAU1980</td></tr><tr><td style="text-align: left">IAU-76/FK5</td><td style="text-align: left"><code>J2000</code></td><td style="text-align: left"><code>ITRF</code></td><td style="text-align: left">EOP IAU1980</td></tr><tr><td style="text-align: left">IAU-76/FK5</td><td style="text-align: left"><code>MOD</code></td><td style="text-align: left"><code>ITRF</code></td><td style="text-align: left">EOP IAU1980</td></tr><tr><td style="text-align: left">IAU-76/FK5</td><td style="text-align: left"><code>TOD</code></td><td style="text-align: left"><code>ITRF</code></td><td style="text-align: left">EOP IAU1980</td></tr><tr><td style="text-align: left">IAU-76/FK5</td><td style="text-align: left"><code>TEME</code></td><td style="text-align: left"><code>ITRF</code></td><td style="text-align: left">EOP IAU1980</td></tr><tr><td style="text-align: left">IAU-76/FK5</td><td style="text-align: left"><code>GCRF</code></td><td style="text-align: left"><code>PEF</code></td><td style="text-align: left">EOP IAU1980</td></tr><tr><td style="text-align: left">IAU-76/FK5</td><td style="text-align: left"><code>J2000</code></td><td style="text-align: left"><code>PEF</code></td><td style="text-align: left">Not required¹</td></tr><tr><td style="text-align: left">IAU-76/FK5</td><td style="text-align: left"><code>MOD</code></td><td style="text-align: left"><code>PEF</code></td><td style="text-align: left">Not required¹</td></tr><tr><td style="text-align: left">IAU-76/FK5</td><td style="text-align: left"><code>TOD</code></td><td style="text-align: left"><code>PEF</code></td><td style="text-align: left">Not required¹</td></tr><tr><td style="text-align: left">IAU-76/FK5</td><td style="text-align: left"><code>TEME</code></td><td style="text-align: left"><code>PEF</code></td><td style="text-align: left">Not required¹</td></tr><tr><td style="text-align: left">IAU-2006/2010 CIO-based</td><td style="text-align: left"><code>CIRS</code></td><td style="text-align: left"><code>ITRF</code></td><td style="text-align: left">EOP IAU2000A</td></tr><tr><td style="text-align: left">IAU-2006/2010 CIO-based</td><td style="text-align: left"><code>GCRF</code></td><td style="text-align: left"><code>ITRF</code></td><td style="text-align: left">EOP IAU2000A</td></tr><tr><td style="text-align: left">IAU-2006/2010 CIO-based</td><td style="text-align: left"><code>CIRS</code></td><td style="text-align: left"><code>TIRS</code></td><td style="text-align: left">Not required¹</td></tr><tr><td style="text-align: left">IAU-2006/2010 CIO-based</td><td style="text-align: left"><code>GCRF</code></td><td style="text-align: left"><code>TIRS</code></td><td style="text-align: left">Not required¹ ²</td></tr><tr><td style="text-align: left">IAU-2006/2010 Equinox-based</td><td style="text-align: left"><code>ERS</code></td><td style="text-align: left"><code>TIRS</code></td><td style="text-align: left">EOP IAU2000A</td></tr><tr><td style="text-align: left">IAU-2006/2010 Equinox-based</td><td style="text-align: left"><code>MOD06</code></td><td style="text-align: left"><code>ITRF</code></td><td style="text-align: left">EOP IAU2000A</td></tr><tr><td style="text-align: left">IAU-2006/2010 Equinox-based</td><td style="text-align: left"><code>MJ2000</code></td><td style="text-align: left"><code>ITRF</code></td><td style="text-align: left">EOP IAU2000A</td></tr><tr><td style="text-align: left">IAU-2006/2010 Equinox-based</td><td style="text-align: left"><code>ERS</code></td><td style="text-align: left"><code>TIRS</code></td><td style="text-align: left">Not required¹ ³</td></tr><tr><td style="text-align: left">IAU-2006/2010 Equinox-based</td><td style="text-align: left"><code>MOD06</code></td><td style="text-align: left"><code>TIRS</code></td><td style="text-align: left">Not required¹ ³</td></tr><tr><td style="text-align: left">IAU-2006/2010 Equinox-based</td><td style="text-align: left"><code>MJ2000</code></td><td style="text-align: left"><code>TIRS</code></td><td style="text-align: left">Not required¹ ³</td></tr></table><p><code>¹</code>: In this case, the Julian Time UTC will be assumed equal to Julian Time UT1 to compute the Greenwich Mean Sidereal Time. This is an approximation, but should be sufficiently accurate for some applications. Notice that, if EOP Data is provided, the Julian Day UT1 will be accurately computed.</p><p><code>²</code>: In this case, the terms that account for the free-core nutation and time dependent effects of the Celestial Intermediate Pole (CIP) position with respect to the GCRF will not be available, reducing the precision.</p><p><strong>MOD and TOD</strong></p><p>In this function, if EOP corrections are not provided, then MOD and TOD frames will be computed considering the original IAU-76/FK5 theory. Otherwise, the corrected frame will be used.</p><p><strong>Returns</strong></p><p>The rotation description represented by <code>T</code> that rotates the ECI reference frame into alignment with the ECEF reference frame.</p><p><strong>Examples</strong></p><pre><code class="language-julia-repl">julia&gt; eop_IAU1980 = get_iers_eop(:IAU1980);

julia&gt; r_eci_to_ecef(DCM, GCRF(), ITRF(), date_to_jd(1986, 06, 19, 21, 35, 0), eop_IAU1980)
3×3 StaticArrays.SArray{Tuple{3,3},Float64,2,9}:
 -0.619267    -0.78518     -0.000797313
  0.78518     -0.619267     0.00106478
 -0.00132979   3.33492e-5   0.999999

julia&gt; r_eci_to_ecef(GCRF(), ITRF(), date_to_jd(1986, 06, 19, 21, 35, 0), eop_IAU1980)
3×3 StaticArrays.SArray{Tuple{3,3},Float64,2,9}:
 -0.619267    -0.78518     -0.000797313
  0.78518     -0.619267     0.00106478
 -0.00132979   3.33492e-5   0.999999

julia&gt; r_eci_to_ecef(J2000(), PEF(), date_to_jd(1986, 06, 19, 21, 35, 0))
3×3 StaticArrays.SArray{Tuple{3,3},Float64,2,9}:
 -0.619271    -0.785177    -0.000796885
  0.785176    -0.619272     0.00106622
 -0.00133066   3.45854e-5   0.999999

julia&gt; r_eci_to_ecef(J2000(), PEF(), date_to_jd(1986, 06, 19, 21, 35, 0), eop_IAU1980)
3×3 StaticArrays.SArray{Tuple{3,3},Float64,2,9}:
 -0.619267    -0.78518     -0.000796879
  0.78518     -0.619267     0.00106623
 -0.00133066   3.45854e-5   0.999999

julia&gt; r_eci_to_ecef(Quaternion, GCRF(), ITRF(), date_to_jd(1986, 06, 19, 21, 35, 0), eop_IAU1980)
Quaternion{Float64}:
  + 0.4363098936462618 + 0.0005909969666939257.i - 0.00030510511316206974.j - 0.8997962182293519.k

julia&gt; eop_IAU2000A = get_iers_eop(:IAU2000A);

julia&gt; r_eci_to_ecef(GCRF(), ITRF(), date_to_jd(1986, 06, 19, 21, 35, 0), eop_IAU2000A)
3×3 StaticArrays.SArray{Tuple{3,3},Float64,2,9}:
 -0.619267    -0.78518     -0.000797312
  0.78518     -0.619267     0.00106478
 -0.00132979   3.33502e-5   0.999999

julia&gt; r_eci_to_ecef(GCRF(), TIRS(), date_to_jd(1986, 06, 19, 21, 35, 0))
3×3 StaticArrays.SArray{Tuple{3,3},Float64,2,9}:
 -0.619271    -0.785177    -0.000796885
  0.785176    -0.619272     0.00106623
 -0.00133066   3.45884e-5   0.999999

julia&gt; r_eci_to_ecef(Quaternion, GCRF(), ITRF(), date_to_jd(1986, 06, 19, 21, 35, 0), eop_IAU2000A)
Quaternion{Float64}:
  + 0.4363098936309669 + 0.000590996988144556.i - 0.0003051056555230158.j - 0.8997962182365703.k</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaSpace/SatelliteToolbox.jl/blob/c7a891ae8cbd18d844cb2ba648927c3c6dfa564f/src/transformations/eci_to_ecef.jl#L21-L188">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="SatelliteToolbox.r_eci_to_eci-Tuple{Union{Val{:GCRF}, Val{:J2000}, Val{:TOD}, Val{:MOD}, Val{:TEME}}, Union{Val{:GCRF}, Val{:J2000}, Val{:TOD}, Val{:MOD}, Val{:TEME}}, Number, EOPData_IAU1980}" href="#SatelliteToolbox.r_eci_to_eci-Tuple{Union{Val{:GCRF}, Val{:J2000}, Val{:TOD}, Val{:MOD}, Val{:TEME}}, Union{Val{:GCRF}, Val{:J2000}, Val{:TOD}, Val{:MOD}, Val{:TEME}}, Number, EOPData_IAU1980}"><code>SatelliteToolbox.r_eci_to_eci</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">r_ecef_to_eci([T,] ECIo, ECIf, JD_UTC::Number [, eop_data])
r_ecef_to_eci([T,] ECIo, JD_UTCo::Number, ECIf, JD_UTCf::Number [, eop_data])</code></pre><p>Compute the rotation from an Earth-Centered Inertial (<code>ECI</code>) reference frame to another ECI reference frame. If the origin and destination frame contain only one <em>of date</em> frame, then the first signature is used and <code>JD_UTC</code> is the epoch of this frame. On the other hand, if the origin and destination frame contain two <em>of date</em> frame<sup class="footnote-reference"><a id="citeref-1" href="#footnote-1">[1]</a></sup>, e.g. TOD =&gt; MOD, then the second signature must be used in which <code>JD_UTCo</code> is the epoch of the origin frame and <code>JD_UTCf</code> is the epoch of the destination frame.</p><p>The rotation description that will be used is given by <code>T</code>, which can be <code>DCM</code> or <code>Quaternion</code>. The origin ECI frame is selected by the input <code>ECIo</code> and the destination ECI frame is selected by the input <code>ECIf</code>. The model used to compute the rotation is specified by the selection of the origin and destination frames. Currently, there are two models supported: IAU-76/FK5 and IAU-2006 with 2010 conventions (CIO and equinox approaches).</p><p><strong>Rotation description</strong></p><p>The rotations that aligns the origin ECI frame with the destination ECI frame can be described by Direction Cosine Matrices or Quaternions. This is selected by the parameter <code>T</code>.</p><p>The possible values are:</p><ul><li><code>DCM</code>: The rotation will be described by a Direction Cosine Matrix.</li><li><code>Quaternion</code>: The rotation will be described by a Quaternion.</li></ul><p>If no value is specified, then it falls back to <code>DCM</code>.</p><p><strong>Conversion model</strong></p><p>The model that will be used to compute the rotation is automatically inferred given the selection of the origin and destination frames. <strong>Notice that mixing IAU-76/FK5 and IAU-2006/2010 frames is not supported yet.</strong></p><p><strong>ECI Frame</strong></p><p>The supported ECI frames for both origin <code>ECIo</code> and destination <code>ECIf</code> are:</p><ul><li><code>TEME()</code>: ECI will be selected as the True Equator Mean Equinox (TEME)           reference frame.</li><li><code>TOD()</code>: ECI will be selected as the True of Date (TOD).</li><li><code>MOD()</code>: ECI will be selected as the Mean of Date (MOD).</li><li><code>J2000()</code>: ECI will be selected as the J2000 reference frame.</li><li><code>GCRF()</code>: ECI will be selected as the Geocentric Celestial Reference Frame           (GCRF).</li><li><code>CIRS()</code>: ECEF will be selected as the Celestial Intermediate Reference System           (CIRS).</li><li><code>ERS()</code>: ECI will be selected as the Earth Reference System (ERS).</li><li><code>MOD06()</code>: ECI will be selected as the Mean of Date (MOD) according to the            definition in IAU-2006/2010 theory.</li><li><code>MJ2000()</code>: ECI will be selected as the J2000 mean equatorial frame (MJ2000).</li></ul><div class="admonition is-info"><header class="admonition-header">Note</header><div class="admonition-body"><p>The frames <code>MOD()</code> and <code>MOD06()</code> are virtually the same. However, we selected different names to make clear which theory are being used since mixing transformation between frames from IAU-76/FK5 and IAU-2006/2010 must be performed with caution.</p></div></div><p><strong>EOP Data</strong></p><p>The conversion between the frames depends on EOP Data (see <code>get_iers_eop</code> and <code>read_iers_eop</code>). If IAU-76/FK5 model is used, then the type of <code>eop_data</code> must be <code>EOPData_IAU1980</code>. Otherwise, if IAU-2006/2010 model is used, then the type of <code>eop_data</code> must be <code>EOPData_IAU2000A</code>. The following table shows the requirements for EOP data given the selected frames.</p><table><tr><th style="text-align: left">Model</th><th style="text-align: left">ECIo</th><th style="text-align: left">ECIf</th><th style="text-align: left">EOP Data</th><th style="text-align: left">Function Signature</th></tr><tr><td style="text-align: left">IAU-76/FK5</td><td style="text-align: left"><code>GCRF</code></td><td style="text-align: left"><code>J2000</code></td><td style="text-align: left">EOP IAU1980</td><td style="text-align: left">First</td></tr><tr><td style="text-align: left">IAU-76/FK5</td><td style="text-align: left"><code>GCRF</code></td><td style="text-align: left"><code>MOD</code></td><td style="text-align: left">EOP IAU1980</td><td style="text-align: left">First</td></tr><tr><td style="text-align: left">IAU-76/FK5</td><td style="text-align: left"><code>GCRF</code></td><td style="text-align: left"><code>TOD</code></td><td style="text-align: left">EOP IAU1980</td><td style="text-align: left">First</td></tr><tr><td style="text-align: left">IAU-76/FK5</td><td style="text-align: left"><code>GCRF</code></td><td style="text-align: left"><code>TEME</code></td><td style="text-align: left">EOP IAU1980</td><td style="text-align: left">First</td></tr><tr><td style="text-align: left">IAU-76/FK5</td><td style="text-align: left"><code>J2000</code></td><td style="text-align: left"><code>GCRF</code></td><td style="text-align: left">EOP IAU1980</td><td style="text-align: left">First</td></tr><tr><td style="text-align: left">IAU-76/FK5</td><td style="text-align: left"><code>J2000</code></td><td style="text-align: left"><code>MOD</code></td><td style="text-align: left">Not required</td><td style="text-align: left">First</td></tr><tr><td style="text-align: left">IAU-76/FK5</td><td style="text-align: left"><code>J2000</code></td><td style="text-align: left"><code>TOD</code></td><td style="text-align: left">Not required</td><td style="text-align: left">First</td></tr><tr><td style="text-align: left">IAU-76/FK5</td><td style="text-align: left"><code>J2000</code></td><td style="text-align: left"><code>TEME</code></td><td style="text-align: left">Not required</td><td style="text-align: left">First</td></tr><tr><td style="text-align: left">IAU-76/FK5</td><td style="text-align: left"><code>MOD</code></td><td style="text-align: left"><code>GCRF</code></td><td style="text-align: left">EOP IAU1980</td><td style="text-align: left">First</td></tr><tr><td style="text-align: left">IAU-76/FK5</td><td style="text-align: left"><code>MOD</code></td><td style="text-align: left"><code>J2000</code></td><td style="text-align: left">Not required</td><td style="text-align: left">First</td></tr><tr><td style="text-align: left">IAU-76/FK5</td><td style="text-align: left"><code>MOD</code></td><td style="text-align: left"><code>TOD</code></td><td style="text-align: left">Not required</td><td style="text-align: left">Second</td></tr><tr><td style="text-align: left">IAU-76/FK5</td><td style="text-align: left"><code>MOD</code></td><td style="text-align: left"><code>TEME</code></td><td style="text-align: left">Not required</td><td style="text-align: left">Second</td></tr><tr><td style="text-align: left">IAU-76/FK5</td><td style="text-align: left"><code>TOD</code></td><td style="text-align: left"><code>GCRF</code></td><td style="text-align: left">EOP IAU1980</td><td style="text-align: left">First</td></tr><tr><td style="text-align: left">IAU-76/FK5</td><td style="text-align: left"><code>TOD</code></td><td style="text-align: left"><code>J2000</code></td><td style="text-align: left">Not required</td><td style="text-align: left">First</td></tr><tr><td style="text-align: left">IAU-76/FK5</td><td style="text-align: left"><code>TOD</code></td><td style="text-align: left"><code>MOD</code></td><td style="text-align: left">Not required</td><td style="text-align: left">Second</td></tr><tr><td style="text-align: left">IAU-76/FK5</td><td style="text-align: left"><code>TOD</code></td><td style="text-align: left"><code>TEME</code></td><td style="text-align: left">Not required</td><td style="text-align: left">Second</td></tr><tr><td style="text-align: left">IAU-76/FK5</td><td style="text-align: left"><code>TEME</code></td><td style="text-align: left"><code>GCRF</code></td><td style="text-align: left">EOP IAU1980</td><td style="text-align: left">First</td></tr><tr><td style="text-align: left">IAU-76/FK5</td><td style="text-align: left"><code>TEME</code></td><td style="text-align: left"><code>J2000</code></td><td style="text-align: left">Not required</td><td style="text-align: left">First</td></tr><tr><td style="text-align: left">IAU-76/FK5</td><td style="text-align: left"><code>TEME</code></td><td style="text-align: left"><code>MOD</code></td><td style="text-align: left">Not required</td><td style="text-align: left">Second</td></tr><tr><td style="text-align: left">IAU-76/FK5</td><td style="text-align: left"><code>TEME</code></td><td style="text-align: left"><code>TOD</code></td><td style="text-align: left">Not required</td><td style="text-align: left">Second</td></tr><tr><td style="text-align: left">IAU-2006/2010 CIO-based</td><td style="text-align: left"><code>GCRF</code></td><td style="text-align: left"><code>CIRS</code></td><td style="text-align: left">Not required¹</td><td style="text-align: left">First</td></tr><tr><td style="text-align: left">IAU-2006/2010 CIO-based</td><td style="text-align: left"><code>CIRS</code></td><td style="text-align: left"><code>CIRS</code></td><td style="text-align: left">Not required¹</td><td style="text-align: left">Second</td></tr><tr><td style="text-align: left">IAU-2006/2010 Equinox-based</td><td style="text-align: left"><code>GCRF</code></td><td style="text-align: left"><code>MJ2000</code></td><td style="text-align: left">Not required</td><td style="text-align: left">First²</td></tr><tr><td style="text-align: left">IAU-2006/2010 Equinox-based</td><td style="text-align: left"><code>GCRF</code></td><td style="text-align: left"><code>MOD06</code></td><td style="text-align: left">Not required</td><td style="text-align: left">First</td></tr><tr><td style="text-align: left">IAU-2006/2010 Equinox-based</td><td style="text-align: left"><code>GCRF</code></td><td style="text-align: left"><code>ERS</code></td><td style="text-align: left">Not required³</td><td style="text-align: left">First</td></tr><tr><td style="text-align: left">IAU-2006/2010 Equinox-based</td><td style="text-align: left"><code>MJ2000</code></td><td style="text-align: left"><code>GCRF</code></td><td style="text-align: left">Not required</td><td style="text-align: left">First²</td></tr><tr><td style="text-align: left">IAU-2006/2010 Equinox-based</td><td style="text-align: left"><code>MJ2000</code></td><td style="text-align: left"><code>MOD06</code></td><td style="text-align: left">Not required</td><td style="text-align: left">First</td></tr><tr><td style="text-align: left">IAU-2006/2010 Equinox-based</td><td style="text-align: left"><code>MJ2000</code></td><td style="text-align: left"><code>ERS</code></td><td style="text-align: left">Not required³</td><td style="text-align: left">First</td></tr><tr><td style="text-align: left">IAU-2006/2010 Equinox-based</td><td style="text-align: left"><code>MOD06</code></td><td style="text-align: left"><code>GCRF</code></td><td style="text-align: left">Not required</td><td style="text-align: left">First</td></tr><tr><td style="text-align: left">IAU-2006/2010 Equinox-based</td><td style="text-align: left"><code>MOD06</code></td><td style="text-align: left"><code>MJ2000</code></td><td style="text-align: left">Not required</td><td style="text-align: left">First</td></tr><tr><td style="text-align: left">IAU-2006/2010 Equinox-based</td><td style="text-align: left"><code>MOD06</code></td><td style="text-align: left"><code>ERS</code></td><td style="text-align: left">Not required³</td><td style="text-align: left">First</td></tr><tr><td style="text-align: left">IAU-2006/2010 Equinox-based</td><td style="text-align: left"><code>ERS</code></td><td style="text-align: left"><code>GCRF</code></td><td style="text-align: left">Not required³</td><td style="text-align: left">First</td></tr><tr><td style="text-align: left">IAU-2006/2010 Equinox-based</td><td style="text-align: left"><code>ERS</code></td><td style="text-align: left"><code>MJ2000</code></td><td style="text-align: left">Not required³</td><td style="text-align: left">First</td></tr><tr><td style="text-align: left">IAU-2006/2010 Equinox-based</td><td style="text-align: left"><code>ERS</code></td><td style="text-align: left"><code>MOD06</code></td><td style="text-align: left">Not required³</td><td style="text-align: left">First</td></tr></table><p><code>¹</code>: In this case, the terms that account for the free-core nutation and time dependent effects of the Celestial Intermediate Pole (CIP) position with respect to the GCRF will not be available, reducing the precision.</p><p><code>²</code>: The transformation between GCRF and MJ2000 is a constant rotation matrix called bias. Hence, the date does not modify it. However, this signature was kept to avoid complications in the API.</p><p><code>³</code>: In this case, the terms that corrects the nutation in obliquity and in longitude due to the free core nutation will not be available, reducing the precision.</p><p><strong>MOD and TOD</strong></p><p>In this function, if EOP corrections are not provided, then MOD and TOD frames will be computed considering the original IAU-76/FK5 theory. Otherwise, the corrected frame will be used.</p><p><strong>Returns</strong></p><p>The rotation description represented by <code>T</code> that rotates the origin ECI reference frame into alignment with the destination ECI reference frame.</p><p><strong>Examples</strong></p><pre><code class="language-julia-repl">julia&gt; eop_IAU1980 = get_iers_eop(:IAU1980);

julia&gt; r_eci_to_eci(DCM, GCRF(), J2000(), date_to_jd(1986, 6, 19, 21, 35, 0), eop_IAU1980)
3×3 StaticArrays.SArray{Tuple{3,3},Float64,2,9}:
  1.0          -2.45469e-12   4.56602e-10
  2.45466e-12   1.0          -1.84455e-9
 -4.56602e-10   1.84455e-9    1.0

julia&gt; r_eci_to_eci(Quaternion, TEME(), GCRF(), date_to_jd(1986, 6, 19, 21, 35, 0), eop_IAU1980)
Quaternion{Float64}:
  + 0.9999986335698654 + 1.8300414020900853e-5.i + 0.0006653038276169474.j - 0.0015132396749411375.k

julia&gt; r_eci_to_eci(TOD(), date_to_jd(1986,6,19,21,35,0), TOD(), date_to_jd(1987,5,19,3,0,0), eop_IAU1980)
3×3 StaticArrays.SArray{Tuple{3,3},Float64,2,9}:
 1.0          -0.000224087  -9.73784e-5
 0.000224086   1.0          -5.79859e-6
 9.73797e-5    5.77677e-6    1.0

julia&gt; r_eci_to_eci(Quaternion, TOD(), JD_J2000, MOD(), JD_J2000, eop_IAU1980)
Quaternion{Float64}:
  + 0.9999999993282687 - 1.400220690336851e-5.i + 1.3473593746216003e-5.j - 3.107834312843103e-5.k

julia&gt; r_eci_to_eci(J2000(), TEME(), date_to_jd(1986,6,19,21,35,0))
3×3 StaticArrays.SArray{Tuple{3,3},Float64,2,9}:
  0.999995    0.0030265    0.00133055
 -0.00302645  0.999995    -3.86125e-5
 -0.00133066  3.45854e-5   0.999999

julia&gt; eop_IAU2000A = get_iers_eop(:IAU2000A);

julia&gt; r_eci_to_eci(CIRS(), GCRF(), date_to_jd(1986,6,19,21,35,0), eop_IAU2000A)
3×3 StaticArrays.SArray{Tuple{3,3},Float64,2,9}:
 0.999999     3.88379e-8  -0.00133066
 7.18735e-9   1.0          3.45882e-5
 0.00133066  -3.45882e-5   0.999999

julia&gt; r_eci_to_eci(Quaternion, CIRS(), GCRF(), date_to_jd(1986,6,19,21,35,0), eop_IAU2000A)
Quaternion{Float64}:
  + 0.9999997785177528 + 1.7294102099105917e-5.i + 0.0006653310148723835.j + 7.912627369563795e-9.k</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaSpace/SatelliteToolbox.jl/blob/c7a891ae8cbd18d844cb2ba648927c3c6dfa564f/src/transformations/eci_to_eci.jl#L21-L197">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="SatelliteToolbox.r_ers_to_mod_iau2006" href="#SatelliteToolbox.r_ers_to_mod_iau2006"><code>SatelliteToolbox.r_ers_to_mod_iau2006</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">r_ers_to_mod_iau2006([T::Type,] JD_TT::Number, δΔϵ_2000::Number = 0, δΔΨ_2000::Number = 0)</code></pre><p>Compute the rotation that aligns the Earth Reference System (ERS) with the Mean of Date (MOD) reference frame at Julian day <code>JD_TT</code> [Terrestrial Time]. This algorithm uses the IAU-2006 theory.</p><p>Notice that one can provide corrections for the nutation in obliquity (<code>δΔϵ_2000</code>) and in longitude (<code>δΔψ_2000</code>) [rad] that are usually obtained from IERS EOP Data (see <a href="#SatelliteToolbox.get_iers_eop"><code>get_iers_eop</code></a> and <a href="#SatelliteToolbox.deps_dpsi-Tuple{EOPData_IAU2000A, Number}"><code>deps_dpsi</code></a>). This corrections are related to Free Core Nutation (FCN) that models the effect of a liquid Earth core.</p><p>The rotation type is described by the optional variable <code>T</code>. If it is <code>DCM</code>, then a DCM will be returned. Otherwise, if it is <code>Quaternion</code>, then a Quaternion will be returned. In case this parameter is omitted, then it falls back to <code>DCM</code>.</p><p><strong>Returns</strong></p><p>The rotation that aligns the ERS frame with the MOD frame. The rotation representation is selected by the optional parameter <code>T</code>.</p><p><strong>Remarks</strong></p><p>The reference systems ERS and MOD are separated by the nutation of the pole.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaSpace/SatelliteToolbox.jl/blob/c7a891ae8cbd18d844cb2ba648927c3c6dfa564f/src/transformations/iau2006/iau2006_equinox.jl#L180-L207">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="SatelliteToolbox.r_ers_to_tirs_iau2006" href="#SatelliteToolbox.r_ers_to_tirs_iau2006"><code>SatelliteToolbox.r_ers_to_tirs_iau2006</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">r_ers_to_tirs_iau2006(JD_UT1::Number, JD_TT::Number, δΔΨ_2000::Number = 0)</code></pre><p>Compute the rotation that aligns the Earth Reference System (ERS) with the Terrestrial Intermediate Reference System (TIRS) at the Julian Day <code>JD_UT1</code> [UT1] and <code>JD_TT</code> [Terrestrial Time]. This algorithm uses the IAU-2006 theory.</p><p>Notice that one can provide corrections for the nutation in longitude (<code>δΔψ_2000</code>) [rad] that are usually obtained from IERS EOP Data (see <a href="#SatelliteToolbox.get_iers_eop"><code>get_iers_eop</code></a> and <a href="#SatelliteToolbox.deps_dpsi-Tuple{EOPData_IAU2000A, Number}"><code>deps_dpsi</code></a>). This corrections are related to Free Core Nutation (FCN) that models the effect of a liquid Earth core.</p><p>The rotation type is described by the optional variable <code>T</code>. If it is <code>DCM</code>, then a DCM will be returned. Otherwise, if it is <code>Quaternion</code>, then a Quaternion will be returned. In case this parameter is omitted, then it falls back to <code>DCM</code>.</p><p><strong>Returns</strong></p><p>The rotation that aligns the ERS frame with the TIRS frame. The rotation representation is selected by the optional parameter <code>T</code>.</p><p><strong>Remarks</strong></p><p>The reference frames TIRS and ERS are separated by a rotation about the Z-axis of the Greenwhich apparent sidereal angle (GAST). This angle is computed using the IAU-2006 theory, which consist of obtaining the Earth Rotation Angle (ERA) and subtracting the result of the Equation of Origins (EO).</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaSpace/SatelliteToolbox.jl/blob/c7a891ae8cbd18d844cb2ba648927c3c6dfa564f/src/transformations/iau2006/iau2006_equinox.jl#L130-L159">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="SatelliteToolbox.r_gcrf_to_cirs_iau2006" href="#SatelliteToolbox.r_gcrf_to_cirs_iau2006"><code>SatelliteToolbox.r_gcrf_to_cirs_iau2006</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">r_gcrf_to_cirs_iau2006([T::Type,] JD_TT::Number, dX::Number = 0, dY::Number = 0)</code></pre><p>Compute the rotation that aligns the Geocentric Celestial Reference Frame (GCRF) with the Celestial Intermediate Reference System (CIRS) at the Julian Day <code>JD_TT</code> [TT] and considering the IERS EOP Data <code>dX</code> [rad] and <code>dY</code> [rad] (see <code>get_iers_eop</code>). This algorithm uses the IAU-2006 theory.</p><p>The IERS EOP Data <code>dX</code> and <code>dY</code> accounts for the free-core nutation and time dependent effects of the Celestial Intermediate Pole (CIP) position with respect to the GCRF.</p><p>The rotation type is described by the optional variable <code>T</code>. If it is <code>DCM</code>, then a DCM will be returned. Otherwise, if it is <code>Quaternion</code>, then a Quaternion will be returned. In case this parameter is omitted, then it falls back to <code>DCM</code>.</p><p><strong>Returns</strong></p><p>The rotation that aligns the GCRF frame with the CIRS frame. The rotation representation is selected by the optional parameter <code>T</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaSpace/SatelliteToolbox.jl/blob/c7a891ae8cbd18d844cb2ba648927c3c6dfa564f/src/transformations/iau2006/iau2006_cio.jl#L324-L346">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="SatelliteToolbox.r_gcrf_to_itrf_fk5" href="#SatelliteToolbox.r_gcrf_to_itrf_fk5"><code>SatelliteToolbox.r_gcrf_to_itrf_fk5</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">r_gcrf_to_itrf_fk5([T,] JD_UT1::Number, JD_TT::Number, x_p::Number, y_p::Number [, δΔϵ_1980::Number, δΔψ_1980::Number])</code></pre><p>Compute the rotation that aligns the Geocentric Celestial Reference Frame (GCRF) with the International Terrestrial Reference Frame (ITRF) at the Julian Day <code>JD_UT1</code> [UT1] and <code>JD_TT</code> [Terrestrial Time], and considering the IERS EOP Data <code>x_p</code> [rad], <code>y_p</code> [rad], <code>δΔϵ_1980</code> [rad], and <code>δΔψ_1980</code> [rad] (see <code>get_iers_eop</code>). This algorithm uses the IAU-76/FK5 theory.</p><p><code>x_p</code> is the polar motion displacement about X-axis, which is the IERS Reference Meridian direction (positive south along the 0˚ longitude meridian). <code>y_p</code> is the polar motion displacement about Y-axis (90˚W or 270˚E meridian). <code>δΔϵ_1980</code> is the nutation in obliquity. <code>δΔψ_1980</code> is the nutation in longitude.</p><p>The Julian Day in UT1 is used to compute the Greenwich Mean Sidereal Time (GMST) (see <code>jd_to_gmst</code>), whereas the Julian Day in Terrestrial Time is used to compute the nutation in the longitude. Notice that the Julian Day in UT1 and in Terrestrial Time must be equivalent, i.e. must be related to the same instant. This function <strong>does not</strong> check this.</p><p>The rotation type is described by the optional variable <code>T</code>. If it is <code>DCM</code>, then a DCM will be returned. Otherwise, if it is <code>Quaternion</code>, then a Quaternion will be returned. In case this parameter is omitted, then it falls back to <code>DCM</code>.</p><p><strong>Returns</strong></p><p>The rotation that aligns the GCRF frame with the ITRF frame. The rotation representation is selected by the optional parameter <code>T</code>.</p><p><strong>Remarks</strong></p><p>The EOP data related to the polar motion (<code>x_p</code> and <code>y_p</code>) is required, since this is the only way available to compute the conversion ITRF &lt;=&gt; PEF (the models are highly imprecise since the motion is still not very well understood [1]). However, the EOP data related to the nutation of the obliquity (<code>δΔϵ_1980</code>) and the nutation of the longitude (<code>δΔψ_1980</code>) can be omitted. In this case, the GCRF frame is what is usually called J2000 reference frame.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaSpace/SatelliteToolbox.jl/blob/c7a891ae8cbd18d844cb2ba648927c3c6dfa564f/src/transformations/fk5/fk5.jl#L543-L582">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="SatelliteToolbox.r_gcrf_to_mj2000_iau2006" href="#SatelliteToolbox.r_gcrf_to_mj2000_iau2006"><code>SatelliteToolbox.r_gcrf_to_mj2000_iau2006</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">r_gcrf_to_mj2000_iau2006([T::Type,] JD_TT::Number = 0)</code></pre><p>Compute the rotation that aligns the Geocentric Celestial Reference Frame (GCRF) with the J2000 mean equatorial frame. This algorithm uses the IAU-2006 theory. Notice that this rotation is just a bias matrix that does not depend on the date. However, this function receives the argument <code>JD_TT</code> just to keep the API compatibility.</p><p>The rotation type is described by the optional variable <code>T</code>. If it is <code>DCM</code>, then a DCM will be returned. Otherwise, if it is <code>Quaternion</code>, then a Quaternion will be returned. In case this parameter is omitted, then it falls back to <code>DCM</code>.</p><p><strong>Returns</strong></p><p>The rotation that aligns the MJ2000 frame with the MOD frame. The rotation representation is selected by the optional parameter <code>T</code>.</p><p><strong>Remarks</strong></p><p>According to [1], the frame bias that converts MJ2000 &lt;=&gt; GCRF is not a precise transformation for all the times.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaSpace/SatelliteToolbox.jl/blob/c7a891ae8cbd18d844cb2ba648927c3c6dfa564f/src/transformations/iau2006/iau2006_equinox.jl#L410-L434">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="SatelliteToolbox.r_gcrf_to_mod_fk5-Tuple{Number}" href="#SatelliteToolbox.r_gcrf_to_mod_fk5-Tuple{Number}"><code>SatelliteToolbox.r_gcrf_to_mod_fk5</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">r_gcrf_to_mod_fk5([T,] JD_TT::Number)</code></pre><p>Compute the rotation that aligns the Geocentric Celestial Reference Frame (GCRF) with the Mean of Date (MOD) frame at the Julian Day [Terrestrial Time] <code>JD_TT</code>. This algorithm uses the IAU-76/FK5 theory.</p><p>The rotation type is described by the optional variable <code>T</code>. If it is <code>DCM</code>, then a DCM will be returned. Otherwise, if it is <code>Quaternion</code>, then a Quaternion will be returned. In case this parameter is omitted, then it falls back to <code>DCM</code>.</p><p><strong>Returns</strong></p><p>The rotation that aligns the GCRF frame with the MOD frame. The rotation representation is selected by the optional parameter <code>T</code>.</p><p><strong>Remarks</strong></p><p>The Geocentric Celestial Reference Frame (GCRF) is rotated into the Mean of Date (MOD) frame considering the IAU 1976 Precession model.</p><p>Notice that if the conversion <code>MOD =&gt; TOD</code> is performed <strong>without</strong> considering the EOP corrections, then the GCRF in this rotation is what is usually called the J2000 reference frame.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaSpace/SatelliteToolbox.jl/blob/c7a891ae8cbd18d844cb2ba648927c3c6dfa564f/src/transformations/fk5/fk5.jl#L425-L451">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="SatelliteToolbox.r_gcrf_to_teme" href="#SatelliteToolbox.r_gcrf_to_teme"><code>SatelliteToolbox.r_gcrf_to_teme</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">r_gcrf_to_teme([T,] JD_TT::Number [, δΔϵ_1980::Number = 0, δΔψ_1980::Number = 0])</code></pre><p>Compute the rotation that aligns the GCRF frame with the True Equator Mean Equinox (TEME) frame at the Julian Day <code>JD_TT</code> [Terrestrial Time]. This algorithm uses the IAU-76/FK5 theory and TEME definition in [1, p. 233]. Notice that one can provide corrections for the nutation in obliquity (<code>δΔϵ_1980</code>) [rad] and in longitude (<code>δΔψ_1980</code>) [rad] that are usually obtained from IERS EOP Data (see <code>get_iers_eop</code>).</p><p>The rotation type is described by the optional variable <code>T</code>. If it is <code>DCM</code>, then a DCM will be returned. Otherwise, if it is <code>Quaternion</code>, then a Quaternion will be returned. In case this parameter is omitted, then it falls back to <code>DCM</code>.</p><p><strong>Returns</strong></p><p>The rotation that aligns the GCRF frame with the TEME frame. The rotation representation is selected by the optional parameter <code>T</code>.</p><p><strong>Remarks</strong></p><p>The EOP data related to the nutation of the obliquity (<code>δΔϵ_1980</code>) and the nutation of the longitude (<code>δΔψ_1980</code>) can be omitted. In this case, the GCRF frame is what is usually called J2000 reference frame.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaSpace/SatelliteToolbox.jl/blob/c7a891ae8cbd18d844cb2ba648927c3c6dfa564f/src/transformations/teme/teme.jl#L299-L325">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="SatelliteToolbox.r_itrf_to_gcrf_fk5" href="#SatelliteToolbox.r_itrf_to_gcrf_fk5"><code>SatelliteToolbox.r_itrf_to_gcrf_fk5</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">r_itrf_to_gcrf_fk5([T,] JD_UT1::Number, JD_TT::Number, x_p::Number, y_p::Number [, δΔϵ_1980::Number, δΔψ_1980::Number])</code></pre><p>Compute the rotation that aligns the International Terrestrial Reference Frame (ITRF) with the Geocentric Celestial Reference Frame (GCRF) at the Julian Day <code>JD_UT1</code> [UT1] and <code>JD_TT</code> [Terrestrial Time], and considering the IERS EOP Data <code>x_p</code> [rad], <code>y_p</code> [rad], <code>δΔϵ_1980</code> [rad], and <code>δΔψ_1980</code> [rad] (see <code>get_iers_eop</code>). This algorithm uses the IAU-76/FK5 theory.</p><p><code>x_p</code> is the polar motion displacement about X-axis, which is the IERS Reference Meridian direction (positive south along the 0˚ longitude meridian). <code>y_p</code> is the polar motion displacement about Y-axis (90˚W or 270˚E meridian). <code>δΔϵ_1980</code> is the nutation in obliquity. <code>δΔψ_1980</code> is the nutation in longitude.</p><p>The Julian Day in UT1 is used to compute the Greenwich Mean Sidereal Time (GMST) (see <code>jd_to_gmst</code>), whereas the Julian Day in Terrestrial Time is used to compute the nutation in the longitude. Notice that the Julian Day in UT1 and in Terrestrial Time must be equivalent, i.e. must be related to the same instant. This function <strong>does not</strong> check this.</p><p>The rotation type is described by the optional variable <code>T</code>. If it is <code>DCM</code>, then a DCM will be returned. Otherwise, if it is <code>Quaternion</code>, then a Quaternion will be returned. In case this parameter is omitted, then it falls back to <code>DCM</code>.</p><p><strong>Returns</strong></p><p>The rotation that aligns the ITRF frame with the GCRF frame. The rotation representation is selected by the optional parameter <code>T</code>.</p><p><strong>Remarks</strong></p><p>The EOP data related to the polar motion (<code>x_p</code> and <code>y_p</code>) is required, since this is the only way available to compute the conversion ITRF &lt;=&gt; PEF (the models are highly imprecise since the motion is still not very well understood [1]). However, the EOP data related to the nutation of the obliquity (<code>δΔϵ_1980</code>) and the nutation of the longitude (<code>δΔψ_1980</code>) can be omitted. In this case, the GCRF frame is what is usually called J2000 reference frame.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaSpace/SatelliteToolbox.jl/blob/c7a891ae8cbd18d844cb2ba648927c3c6dfa564f/src/transformations/fk5/fk5.jl#L470-L509">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="SatelliteToolbox.r_itrf_to_pef_fk5-Tuple{Number, Number}" href="#SatelliteToolbox.r_itrf_to_pef_fk5-Tuple{Number, Number}"><code>SatelliteToolbox.r_itrf_to_pef_fk5</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">r_itrf_to_pef_fk5([T,] x_p::Number, y_p::Number)</code></pre><p>Compute the rotation that aligns the International Terrestrial Reference Frame (ITRF) with the Pseudo-Earth Fixed (PEF) frame considering the polar motion represented by the angles <code>x_p</code> [rad] and <code>y_p</code> [rad] that are obtained from IERS EOP Data (see <code>get_iers_eop</code>).</p><p><code>x_p</code> is the polar motion displacement about X-axis, which is the IERS Reference Meridian direction (positive south along the 0˚ longitude meridian). <code>y_p</code> is the polar motion displacement about Y-axis (90˚W or 270˚E meridian).</p><p>The rotation type is described by the optional variable <code>T</code>. If it is <code>DCM</code>, then a DCM will be returned. Otherwise, if it is <code>Quaternion</code>, then a Quaternion will be returned. In case this parameter is omitted, then it falls back to <code>DCM</code>.</p><p><strong>Returns</strong></p><p>The rotation that aligns the ITRF frame with the PEF frame. The rotation representation is selected by the optional parameter <code>T</code>.</p><p><strong>Remarks</strong></p><p>The ITRF is defined based on the International Reference Pole (IRP), which is the location of the terrestrial pole agreed by international committees [1]. The Pseudo-Earth Fixed, on the other hand, is defined based on the Earth axis of rotation, or the Celestial Intermediate Pole (CIP). Hence, PEF XY-plane contains the True Equator. Furthermore, since the recovered latitude and longitude are sensitive to the CIP, then it should be computed considering the PEF frame.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaSpace/SatelliteToolbox.jl/blob/c7a891ae8cbd18d844cb2ba648927c3c6dfa564f/src/transformations/fk5/fk5.jl#L61-L92">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="SatelliteToolbox.r_itrf_to_tirs_iau2006-Tuple{Number, Number, Number}" href="#SatelliteToolbox.r_itrf_to_tirs_iau2006-Tuple{Number, Number, Number}"><code>SatelliteToolbox.r_itrf_to_tirs_iau2006</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">r_itrf_to_tirs_iau2006([T::Type,] JD_TT::Number, x_p::Number, y_p::Number)</code></pre><p>Compute the rotation that aligns the International Terrestrial Reference Frame (ITRF) with the Terrestrial Intermediate Reference System (TIRS) considering the polar motion represented by the angles <code>x_p</code> [rad] and <code>y_p</code> [rad] that are obtained from IERS EOP Data (see <code>get_iers_eop</code>).</p><p><code>x_p</code> is the polar motion displacement about X-axis, which is the IERS Reference Meridian direction (positive south along the 0˚ longitude meridian). <code>y_p</code> is the polar motion displacement about Y-axis (90˚W or 270˚E meridian).</p><p>The rotation type is described by the optional variable <code>T</code>. If it is <code>DCM</code>, then a DCM will be returned. Otherwise, if it is <code>Quaternion</code>, then a Quaternion will be returned. In case this parameter is omitted, then it falls back to <code>DCM</code>.</p><p><strong>Returns</strong></p><p>The rotation that aligns the ITRF frame with the TIRS frame. The rotation representation is selected by the optional parameter <code>T</code>.</p><p><strong>Remarks</strong></p><p>The ITRF is defined based on the International Reference Pole (IRP), which is the location of the terrestrial pole agreed by international committees [1]. The Terrestrial Intermediate Reference Frame (TIRS), on the other hand, is defined based on the Earth axis of rotation, or the Celestial Intermediate Pole (CIP). Hence, TIRS XY-plane contains the True Equator. Furthermore, since the recovered latitude and longitude are sensitive to the CIP, then it should be computed considering the TIRS frame.</p><p>The TIRS and PEF (IAU-76/FK5) are virtually the same reference frame, but according to [1] it is convenient to separate the names as the exact formulae differ.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaSpace/SatelliteToolbox.jl/blob/c7a891ae8cbd18d844cb2ba648927c3c6dfa564f/src/transformations/iau2006/iau2006_cio.jl#L53-L89">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="SatelliteToolbox.r_mj2000_to_gcrf_iau2006" href="#SatelliteToolbox.r_mj2000_to_gcrf_iau2006"><code>SatelliteToolbox.r_mj2000_to_gcrf_iau2006</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">r_mj2000_to_gcrf_iau2006([T::Type,] JD_TT::Number = 0)</code></pre><p>Compute the rotation that aligns the J2000 mean equatorial frame with the Geocentric Celestial Reference Frame (GCRF). This algorithm uses the IAU-2006 theory. Notice that this rotation is just a bias matrix that does not depend on the date. However, this function receives the argument <code>JD_TT</code> just to keep the API compatibility.</p><p>The rotation type is described by the optional variable <code>T</code>. If it is <code>DCM</code>, then a DCM will be returned. Otherwise, if it is <code>Quaternion</code>, then a Quaternion will be returned. In case this parameter is omitted, then it falls back to <code>DCM</code>.</p><p><strong>Returns</strong></p><p>The rotation that aligns the MJ2000 frame with the MOD frame. The rotation representation is selected by the optional parameter <code>T</code>.</p><p><strong>Remarks</strong></p><p>According to [1], the frame bias that converts MJ2000 &lt;=&gt; GCRF is not a precise transformation for all the times.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaSpace/SatelliteToolbox.jl/blob/c7a891ae8cbd18d844cb2ba648927c3c6dfa564f/src/transformations/iau2006/iau2006_equinox.jl#L370-L394">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="SatelliteToolbox.r_mj2000_to_mod_iau2006-Tuple{Number}" href="#SatelliteToolbox.r_mj2000_to_mod_iau2006-Tuple{Number}"><code>SatelliteToolbox.r_mj2000_to_mod_iau2006</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">r_mj2000_to_mod_iau2006([T::Type,] JD_TT::Number)</code></pre><p>Compute the rotation that aligns the J2000 mean equatorial frame with the Mean of Date (MOD) reference frame with the at Julian day <code>JD_TT</code> [Terrestrial Time]. This algorithm uses the IAU-2006 theory.</p><p>The rotation type is described by the optional variable <code>T</code>. If it is <code>DCM</code>, then a DCM will be returned. Otherwise, if it is <code>Quaternion</code>, then a Quaternion will be returned. In case this parameter is omitted, then it falls back to <code>DCM</code>.</p><p><strong>Returns</strong></p><p>The rotation that aligns the MJ2000 frame with the MOD frame. The rotation representation is selected by the optional parameter <code>T</code>.</p><p><strong>Remarks</strong></p><p>The J2000 reference frame here is not equal to the previous definition in FK5 theory. It is the reason why it is internally called <code>MJ2000</code>. According to [3]:</p><blockquote><p>The mean equinox of J2000.0 to be considered is not the “rotational dynamical mean equinox of J2000.0” as used in the past, but the “inertial dynamical mean equinox of J2000.0” to which the recent numerical or analytical solutions refer.  The latter is associated with the ecliptic in the inertial sense, which is the plane perpendicular to the angular momentum vector of the orbital motion of the Earth-Moon barycenter as computed from the velocity of the barycenter relative to an inertial system. The rotational equinox is associated with the ecliptic in the rotational sense, which is perpendicular to the angular momentum vector computed from the velocity referred to the rotating orbital plane of the Earth-Moon barycenter. (The difference between the two angular momenta is the angular momentum associated with the rotation of the orbital plane.)</p></blockquote></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaSpace/SatelliteToolbox.jl/blob/c7a891ae8cbd18d844cb2ba648927c3c6dfa564f/src/transformations/iau2006/iau2006_equinox.jl#L324-L359">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="SatelliteToolbox.r_mod_to_ers_iau2006" href="#SatelliteToolbox.r_mod_to_ers_iau2006"><code>SatelliteToolbox.r_mod_to_ers_iau2006</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">r_mod_to_ers_iau2006([T::Type,] JD_TT::Number, δΔϵ_2000::Number = 0, δΔΨ_2000::Number = 0)</code></pre><p>Compute the rotation that aligns the Mean of Date (MOD) reference frame with the Earth Reference System (ERS) at Julian day <code>JD_TT</code> [Terrestrial Time]. This algorithm uses the IAU-2006 theory.</p><p>Notice that one can provide corrections for the nutation in obliquity (<code>δΔϵ_2000</code>) and in longitude (<code>δΔψ_2000</code>) [rad] that are usually obtained from IERS EOP Data (see <a href="#SatelliteToolbox.get_iers_eop"><code>get_iers_eop</code></a> and <a href="#SatelliteToolbox.deps_dpsi-Tuple{EOPData_IAU2000A, Number}"><code>deps_dpsi</code></a>). This corrections are related to Free Core Nutation (FCN) that models the effect of a liquid Earth core.</p><p>The rotation type is described by the optional variable <code>T</code>. If it is <code>DCM</code>, then a DCM will be returned. Otherwise, if it is <code>Quaternion</code>, then a Quaternion will be returned. In case this parameter is omitted, then it falls back to <code>DCM</code>.</p><p><strong>Returns</strong></p><p>The rotation that aligns the MOD frame with the ERS frame. The rotation representation is selected by the optional parameter <code>T</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaSpace/SatelliteToolbox.jl/blob/c7a891ae8cbd18d844cb2ba648927c3c6dfa564f/src/transformations/iau2006/iau2006_equinox.jl#L227-L250">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="SatelliteToolbox.r_mod_to_gcrf_fk5-Tuple{Number}" href="#SatelliteToolbox.r_mod_to_gcrf_fk5-Tuple{Number}"><code>SatelliteToolbox.r_mod_to_gcrf_fk5</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">r_mod_to_gcrf_fk5([T,] JD_TT::Number)</code></pre><p>Compute the rotation that aligns the Mean of Date (MOD) frame with the Geocentric Celestial Reference Frame (GCRF) at the Julian Day [Terrestrial Time] <code>JD_TT</code>. This algorithm uses the IAU-76/FK5 theory.</p><p>The rotation type is described by the optional variable <code>T</code>. If it is <code>DCM</code>, then a DCM will be returned. Otherwise, if it is <code>Quaternion</code>, then a Quaternion will be returned. In case this parameter is omitted, then it falls back to <code>DCM</code>.</p><p><strong>Returns</strong></p><p>The rotation that aligns the MOD frame with the GCRF frame. The rotation representation is selected by the optional parameter <code>T</code>.</p><p><strong>Remarks</strong></p><p>The Mean of Date (MOD) frame is rotated into the Geocentric Celestial Reference Frame (GCRF) considering the IAU 1976 Precession model.</p><p>Notice that if the conversion <code>TOD =&gt; MOD</code> is performed <strong>without</strong> considering the EOP corrections, then the GCRF obtained by this rotation is what is usually called the J2000 reference frame.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaSpace/SatelliteToolbox.jl/blob/c7a891ae8cbd18d844cb2ba648927c3c6dfa564f/src/transformations/fk5/fk5.jl#L391-L417">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="SatelliteToolbox.r_mod_to_mj2000_iau2006-Tuple{Number}" href="#SatelliteToolbox.r_mod_to_mj2000_iau2006-Tuple{Number}"><code>SatelliteToolbox.r_mod_to_mj2000_iau2006</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">r_mod_to_mj2000_iau2006([T::Type,] JD_TT::Number)</code></pre><p>Compute the rotation that aligns the Mean of Date (MOD) reference frame with the J2000 mean equatorial frame at Julian day <code>JD_TT</code> [Terrestrial Time]. This algorithm uses the IAU-2006 theory.</p><p>The rotation type is described by the optional variable <code>T</code>. If it is <code>DCM</code>, then a DCM will be returned. Otherwise, if it is <code>Quaternion</code>, then a Quaternion will be returned. In case this parameter is omitted, then it falls back to <code>DCM</code>.</p><p><strong>Returns</strong></p><p>The rotation that aligns the MOD frame with the MJ2000 frame. The rotation representation is selected by the optional parameter <code>T</code>.</p><p><strong>Remarks</strong></p><p>The J2000 reference frame here is not equal to the previous definition in FK5 theory. It is the reason why it is internally called <code>MJ2000</code>. According to [3]:</p><blockquote><p>The mean equinox of J2000.0 to be considered is not the “rotational dynamical mean equinox of J2000.0” as used in the past, but the “inertial dynamical mean equinox of J2000.0” to which the recent numerical or analytical solutions refer.  The latter is associated with the ecliptic in the inertial sense, which is the plane perpendicular to the angular momentum vector of the orbital motion of the Earth-Moon barycenter as computed from the velocity of the barycenter relative to an inertial system. The rotational equinox is associated with the ecliptic in the rotational sense, which is perpendicular to the angular momentum vector computed from the velocity referred to the rotating orbital plane of the Earth-Moon barycenter. (The difference between the two angular momenta is the angular momentum associated with the rotation of the orbital plane.)</p></blockquote></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaSpace/SatelliteToolbox.jl/blob/c7a891ae8cbd18d844cb2ba648927c3c6dfa564f/src/transformations/iau2006/iau2006_equinox.jl#L271-L306">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="SatelliteToolbox.r_mod_to_pef_fk5" href="#SatelliteToolbox.r_mod_to_pef_fk5"><code>SatelliteToolbox.r_mod_to_pef_fk5</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">r_mod_to_pef_fk5([T,] JD_UT1::Number, JD_TT::Number [, δΔϵ_1980::Number, δΔψ_1980::Number])</code></pre><p>Compute the rotation that aligns the Mean of Date (MOD) reference frame with the Pseudo-Earth Fixed (PEF) frame at the Julian Day <code>JD_UT1</code> [UT1] and <code>JD_TT</code> [Terrestrial Time]. This algorithm uses the IAU-76/FK5 theory. Notice that one can provide corrections for the nutation in obliquity (<code>δΔϵ_1980</code>) [rad] and in longitude (<code>δΔψ_1980</code>) [rad] that are usually obtained from IERS EOP Data (see <code>get_iers_eop</code>).</p><p>The Julian Day in UT1 is used to compute the Greenwich Mean Sidereal Time (GMST) (see <code>jd_to_gmst</code>), whereas the Julian Day in Terrestrial Time is used to compute the nutation in the longitude. Notice that the Julian Day in UT1 and in Terrestrial Time must be equivalent, i.e. must be related to the same instant. This function <strong>does not</strong> check this.</p><p>The rotation type is described by the optional variable <code>T</code>. If it is <code>DCM</code>, then a DCM will be returned. Otherwise, if it is <code>Quaternion</code>, then a Quaternion will be returned. In case this parameter is omitted, then it falls back to <code>DCM</code>.</p><p><strong>Returns</strong></p><p>The rotation that aligns the MOD frame with the PEF frame. The rotation representation is selected by the optional parameter <code>T</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaSpace/SatelliteToolbox.jl/blob/c7a891ae8cbd18d844cb2ba648927c3c6dfa564f/src/transformations/fk5/fk5.jl#L705-L731">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="SatelliteToolbox.r_mod_to_teme" href="#SatelliteToolbox.r_mod_to_teme"><code>SatelliteToolbox.r_mod_to_teme</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">r_mod_to_teme([T,] JD_TT::Number [, δΔϵ_1980::Number = 0, δΔψ_1980::Number = 0])</code></pre><p>Compute the rotation that aligns the Mean of Date (MOD) frame with the True Equator Mean Equinox (TEME) frame at the Julian Day <code>JD_TT</code> [Terrestrial Time]. This algorithm uses the IAU-76/FK5 theory and TEME definition in [1, p. 233]. Notice that one can provide corrections for the nutation in obliquity (<code>δΔϵ_1980</code>) [rad] and in longitude (<code>δΔψ_1980</code>) [rad] that are usually obtained from IERS EOP Data (see <code>get_iers_eop</code>).  .</p><p>The rotation type is described by the optional variable <code>T</code>. If it is <code>DCM</code>, then a DCM will be returned. Otherwise, if it is <code>Quaternion</code>, then a Quaternion will be returned. In case this parameter is omitted, then it falls back to <code>DCM</code>.</p><p><strong>Returns</strong></p><p>The rotation that aligns the MOD frame with the TEME frame. The rotation representation is selected by the optional parameter <code>T</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaSpace/SatelliteToolbox.jl/blob/c7a891ae8cbd18d844cb2ba648927c3c6dfa564f/src/transformations/teme/teme.jl#L215-L235">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="SatelliteToolbox.r_mod_to_tirs_iau2006" href="#SatelliteToolbox.r_mod_to_tirs_iau2006"><code>SatelliteToolbox.r_mod_to_tirs_iau2006</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">r_mod_to_tirs_iau2006([T::Type,] JD_UT1::Number, JD_TT::Number, δΔϵ_2000::Number = 0, δΔΨ_2000::Number = 0)</code></pre><p>Compute the rotation that aligns the Mean of Date (MOD) reference frame with the Terrestrial Intermediate Reference System (TIRS) at the Julian Day <code>JD_UT1</code> [UT1] and <code>JD_TT</code> [Terrestrial Time]. This algorithm uses the IAU-2006 theory.</p><p>Notice that one can provide corrections for the nutation in obliquity (<code>δΔϵ_2000</code>) and in longitude (<code>δΔψ_2000</code>) [rad] that are usually obtained from IERS EOP Data (see <a href="#SatelliteToolbox.get_iers_eop"><code>get_iers_eop</code></a> and <a href="#SatelliteToolbox.deps_dpsi-Tuple{EOPData_IAU2000A, Number}"><code>deps_dpsi</code></a>). This corrections are related to Free Core Nutation (FCN) that models the effect of a liquid Earth core.</p><p>The rotation type is described by the optional variable <code>T</code>. If it is <code>DCM</code>, then a DCM will be returned. Otherwise, if it is <code>Quaternion</code>, then a Quaternion will be returned. In case this parameter is omitted, then it falls back to <code>DCM</code>.</p><p><strong>Returns</strong></p><p>The rotation that aligns the TIRS frame with the ERS frame. The rotation representation is selected by the optional parameter <code>T</code>.</p><p><strong>Remarks</strong></p><p>This composed rotation TIRS &lt;=&gt; ERS &lt;=&gt; MOD is implemented as a new function because the single rotations TIRS &lt;=&gt; ERS and ERS &lt;=&gt; MOD call the function <code>nutation_eo</code>, which has a high computational burden. In this case, the composed algorithm is about 2x faster than calling those function separately.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaSpace/SatelliteToolbox.jl/blob/c7a891ae8cbd18d844cb2ba648927c3c6dfa564f/src/transformations/iau2006/iau2006_equinox.jl#L522-L553">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="SatelliteToolbox.r_mod_to_tod_fk5" href="#SatelliteToolbox.r_mod_to_tod_fk5"><code>SatelliteToolbox.r_mod_to_tod_fk5</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">r_mod_to_tod_fk5([T,] JD_TT::Number [, δΔϵ_1980::Number, δΔψ_1980::Number])</code></pre><p>Compute the rotation that aligns the Mean of Date (MOD) frame with the True of Date (TOD) frame at the Julian Day <code>JD_TT</code> [Terrestrial Time]. This algorithm uses the IAU-76/FK5 theory. Notice that one can provide corrections for the nutation in obliquity (<code>δΔϵ_1980</code>) [rad] and in longitude (<code>δΔψ_1980</code>) [rad] that are usually obtained from IERS EOP Data (see <code>get_iers_eop</code>).</p><p>The rotation type is described by the optional variable <code>T</code>. If it is <code>DCM</code>, then a DCM will be returned. Otherwise, if it is <code>Quaternion</code>, then a Quaternion will be returned. In case this parameter is omitted, then it falls back to <code>DCM</code>.</p><p><strong>Returns</strong></p><p>The rotation that aligns the MOD frame with the TOD frame. The rotation representation is selected by the optional parameter <code>T</code>.</p><p><strong>Remarks</strong></p><p>The Mean of Date (MOD) frame is rotated into the True of Date (TOD) frame considering the 1980 IAU Theory of Nutation. The IERS EOP corrections must be added if one wants to make the rotation consistent with the Geocentric Celestial Reference Systems (GCRS).</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaSpace/SatelliteToolbox.jl/blob/c7a891ae8cbd18d844cb2ba648927c3c6dfa564f/src/transformations/fk5/fk5.jl#L344-L370">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="SatelliteToolbox.r_pef_to_itrf_fk5-Tuple{Number, Number}" href="#SatelliteToolbox.r_pef_to_itrf_fk5-Tuple{Number, Number}"><code>SatelliteToolbox.r_pef_to_itrf_fk5</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">r_pef_to_itrf_fk5([T,] x_p::Number, y_p::Number)</code></pre><p>Compute the rotation that aligns the Pseudo-Earth Fixed (PEF) with the International Terrestrial Reference Frame (ITRF) considering the polar motion represented by the angles <code>x_p</code> [rad] and <code>y_p</code> [rad] that are obtained from IERS EOP Data (see <code>get_iers_eop</code>).</p><p><code>x_p</code> is the polar motion displacement about X-axis, which is the IERS Reference Meridian direction (positive south along the 0˚ longitude meridian). <code>y_p</code> is the polar motion displacement about Y-axis (90˚W or 270˚E meridian).</p><p>The rotation type is described by the optional variable <code>T</code>. If it is <code>DCM</code>, then a DCM will be returned. Otherwise, if it is <code>Quaternion</code>, then a Quaternion will be returned. In case this parameter is omitted, then it falls back to <code>DCM</code>.</p><p><strong>Returns</strong></p><p>The rotation that aligns the PEF frame with the ITRF. The rotation representation is selected by the optional parameter <code>T</code>.</p><p><strong>Remarks</strong></p><p>The ITRF is defined based on the International Reference Pole (IRP), which is the location of the terrestrial pole agreed by international committees [1]. The Pseudo-Earth Fixed, on the other hand, is defined based on the Earth axis of rotation, or the Celestial Intermediate Pole (CIP). Hence, PEF XY-plane contains the True Equator. Furthermore, since the recovered latitude and longitude are sensitive to the CIP, then it should be computed considering the PEF frame.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaSpace/SatelliteToolbox.jl/blob/c7a891ae8cbd18d844cb2ba648927c3c6dfa564f/src/transformations/fk5/fk5.jl#L106-L137">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="SatelliteToolbox.r_pef_to_mod_fk5" href="#SatelliteToolbox.r_pef_to_mod_fk5"><code>SatelliteToolbox.r_pef_to_mod_fk5</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">r_pef_to_mod_fk5([T,] JD_UT1::Number, JD_TT::Number [, δΔϵ_1980::Number, δΔψ_1980::Number])</code></pre><p>Compute the rotation that aligns the Pseudo-Earth Fixed (PEF) frame with the Mean of Date (MOD) at the Julian Day <code>JD_UT1</code> [UT1] and <code>JD_TT</code> [Terrestrial Time]. This algorithm uses the IAU-76/FK5 theory. Notice that one can provide corrections for the nutation in obliquity (<code>δΔϵ_1980</code>) [rad] and in longitude (<code>δΔψ_1980</code>) [rad] that are usually obtained from IERS EOP Data (see <code>get_iers_eop</code>).</p><p>The Julian Day in UT1 is used to compute the Greenwich Mean Sidereal Time (GMST) (see <code>jd_to_gmst</code>), whereas the Julian Day in Terrestrial Time is used to compute the nutation in the longitude. Notice that the Julian Day in UT1 and in Terrestrial Time must be equivalent, i.e. must be related to the same instant. This function <strong>does not</strong> check this.</p><p>The rotation type is described by the optional variable <code>T</code>. If it is <code>DCM</code>, then a DCM will be returned. Otherwise, if it is <code>Quaternion</code>, then a Quaternion will be returned. In case this parameter is omitted, then it falls back to <code>DCM</code>.</p><p><strong>Returns</strong></p><p>The rotation that aligns the PEF frame with the TOD frame. The rotation representation is selected by the optional parameter <code>T</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaSpace/SatelliteToolbox.jl/blob/c7a891ae8cbd18d844cb2ba648927c3c6dfa564f/src/transformations/fk5/fk5.jl#L609-L635">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="SatelliteToolbox.r_pef_to_teme-Tuple{Number}" href="#SatelliteToolbox.r_pef_to_teme-Tuple{Number}"><code>SatelliteToolbox.r_pef_to_teme</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">r_pef_to_teme([T,] JD_TT::Number)</code></pre><p>Compute the rotation that aligns the Pseudo-Earth Fixed (PEF) frame with the True Equator Mean Equinox (TEME) frame at the Julian Day <code>JD_TT</code> [Terrestrial Time]. This algorithm uses the IAU-76/FK5 theory and TEME definition in [1, p. 233].</p><p>The rotation type is described by the optional variable <code>T</code>. If it is <code>DCM</code>, then a DCM will be returned. Otherwise, if it is <code>Quaternion</code>, then a Quaternion will be returned. In case this parameter is omitted, then it falls back to <code>DCM</code>.</p><p><strong>Returns</strong></p><p>The rotation that aligns the PEF frame with the TEME frame. The rotation representation is selected by the optional parameter <code>T</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaSpace/SatelliteToolbox.jl/blob/c7a891ae8cbd18d844cb2ba648927c3c6dfa564f/src/transformations/teme/teme.jl#L370-L388">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="SatelliteToolbox.r_pef_to_tod_fk5" href="#SatelliteToolbox.r_pef_to_tod_fk5"><code>SatelliteToolbox.r_pef_to_tod_fk5</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">r_pef_to_tod_fk5([T,] JD_UT1::Number, JD_TT::Number [, δΔψ_1980::Number])</code></pre><p>Compute the rotation that aligns the Pseudo-Earth Fixed (PEF) frame with the True of Date (TOD) frame at the Julian Day <code>JD_UT1</code> [UT1] and <code>JD_TT</code> [Terrestrial Time]. This algorithm uses the IAU-76/FK5 theory. Notice that one can provide correction for the nutation in longitude (<code>δΔψ_1980</code>) [rad] that is usually obtained from IERS EOP Data (see <code>get_iers_eop</code>).</p><p>The Julian Day in UT1 is used to compute the Greenwich Mean Sidereal Time (GMST) (see <code>jd_to_gmst</code>), whereas the Julian Day in Terrestrial Time is used to compute the nutation in the longitude. Notice that the Julian Day in UT1 and in Terrestrial Time must be equivalent, i.e. must be related to the same instant. This function <strong>does not</strong> check this.</p><p>The rotation type is described by the optional variable <code>T</code>. If it is <code>DCM</code>, then a DCM will be returned. Otherwise, if it is <code>Quaternion</code>, then a Quaternion will be returned. In case this parameter is omitted, then it falls back to <code>DCM</code>.</p><p><strong>Returns</strong></p><p>The rotation that aligns the PEF frame with the TOD frame. The rotation representation is selected by the optional parameter <code>T</code>.</p><p><strong>Remarks</strong></p><p>The Pseudo-Earth Fixed (PEF) frame is rotated into the True of Date (TOD) frame considering the 1980 IAU Theory of Nutation. The IERS EOP corrections must be added if one wants to make the rotation consistent with the Geocentric Celestial Reference Systems (GCRS).</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaSpace/SatelliteToolbox.jl/blob/c7a891ae8cbd18d844cb2ba648927c3c6dfa564f/src/transformations/fk5/fk5.jl#L150-L182">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="SatelliteToolbox.r_teme_to_gcrf" href="#SatelliteToolbox.r_teme_to_gcrf"><code>SatelliteToolbox.r_teme_to_gcrf</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">r_teme_to_gcrf([T,] JD_TT::Number [, δΔϵ_1980::Number = 0, δΔψ_1980::Number = 0])</code></pre><p>Compute the rotation that aligns the True Equator Mean Equinox (TEME) frame with the Geocentric Celestial Reference Frame (GCRF) at the Julian Day <code>JD_TT</code> [Terrestrial Time]. This algorithm uses the IAU-76/FK5 theory and TEME definition in [1, p. 233]. Notice that one can provide corrections for the nutation in obliquity (<code>δΔϵ_1980</code>) [rad] and in longitude (<code>δΔψ_1980</code>) [rad] that are usually obtained from IERS EOP Data (see <code>get_iers_eop</code>).</p><p>The rotation type is described by the optional variable <code>T</code>. If it is <code>DCM</code>, then a DCM will be returned. Otherwise, if it is <code>Quaternion</code>, then a Quaternion will be returned. In case this parameter is omitted, then it falls back to <code>DCM</code>.</p><p><strong>Returns</strong></p><p>The rotation that aligns the TEME frame with the GCRF frame. The rotation representation is selected by the optional parameter <code>T</code>.</p><p><strong>Remarks</strong></p><p>The EOP data related to the nutation of the obliquity (<code>δΔϵ_1980</code>) and the nutation of the longitude (<code>δΔψ_1980</code>) can be omitted. In this case, the GCRF frame is what is usually called J2000 reference frame.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaSpace/SatelliteToolbox.jl/blob/c7a891ae8cbd18d844cb2ba648927c3c6dfa564f/src/transformations/teme/teme.jl#L252-L278">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="SatelliteToolbox.r_teme_to_mod" href="#SatelliteToolbox.r_teme_to_mod"><code>SatelliteToolbox.r_teme_to_mod</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">r_teme_to_mod([T,] JD_TT::Number [, δΔϵ_1980::Number = 0, δΔψ_1980::Number = 0])</code></pre><p>Compute the rotation that aligns the True Equator Mean Equinox (TEME) frame with the Mean of Date (MOD) frame at the Julian Day <code>JD_TT</code> [Terrestrial Time]. This algorithm uses the IAU-76/FK5 theory and TEME definition in [1, p. 233]. Notice that one can provide corrections for the nutation in obliquity (<code>δΔϵ_1980</code>) [rad] and in longitude (<code>δΔψ_1980</code>) [rad] that are usually obtained from IERS EOP Data (see <code>get_iers_eop</code>).</p><p>The rotation type is described by the optional variable <code>T</code>. If it is <code>DCM</code>, then a DCM will be returned. Otherwise, if it is <code>Quaternion</code>, then a Quaternion will be returned. In case this parameter is omitted, then it falls back to <code>DCM</code>.</p><p><strong>Returns</strong></p><p>The rotation that aligns the TEME frame with the MOD frame. The rotation representation is selected by the optional parameter <code>T</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaSpace/SatelliteToolbox.jl/blob/c7a891ae8cbd18d844cb2ba648927c3c6dfa564f/src/transformations/teme/teme.jl#L138-L158">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="SatelliteToolbox.r_teme_to_pef-Tuple{Number}" href="#SatelliteToolbox.r_teme_to_pef-Tuple{Number}"><code>SatelliteToolbox.r_teme_to_pef</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">r_teme_to_pef([T,] JD_TT::Number)</code></pre><p>Compute the rotation that aligns the True Equator Mean Equinox (TEME) frame with the Pseudo-Earth Fixed (PEF) frame at the Julian Day <code>JD_TT</code> [Terrestrial Time]. This algorithm uses the IAU-76/FK5 theory and TEME definition in [1, p. 233].</p><p>The rotation type is described by the optional variable <code>T</code>. If it is <code>DCM</code>, then a DCM will be returned. Otherwise, if it is <code>Quaternion</code>, then a Quaternion will be returned. In case this parameter is omitted, then it falls back to <code>DCM</code>.</p><p><strong>Returns</strong></p><p>The rotation that aligns the TEME frame with the PEF frame. The rotation representation is selected by the optional parameter <code>T</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaSpace/SatelliteToolbox.jl/blob/c7a891ae8cbd18d844cb2ba648927c3c6dfa564f/src/transformations/teme/teme.jl#L342-L359">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="SatelliteToolbox.r_teme_to_tod" href="#SatelliteToolbox.r_teme_to_tod"><code>SatelliteToolbox.r_teme_to_tod</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">r_teme_to_tod([T,] JD_TT::Number [, δΔϵ_1980::Number = 0, δΔψ_1980::Number = 0])</code></pre><p>Compute the rotation that aligns the True Equator Mean Equinox (TEME) frame with the True of Date (TOD) frame at the Julian Day <code>JD_TT</code> [Terrestrial Time]. This algorithm uses the IAU-76/FK5 theory and TEME definition in [1, p. 233]. Notice that one can provide corrections for the nutation in obliquity (<code>δΔϵ_1980</code>) [rad] and in longitude (<code>δΔψ_1980</code>) [rad] that are usually obtained from IERS EOP Data (see <code>get_iers_eop</code>).</p><p>The rotation type is described by the optional variable <code>T</code>. If it is <code>DCM</code>, then a DCM will be returned. Otherwise, if it is <code>Quaternion</code>, then a Quaternion will be returned. In case this parameter is omitted, then it falls back to <code>DCM</code>.</p><p><strong>Returns</strong></p><p>The rotation that aligns the TEME frame with the TOD frame. The rotation representation is selected by the optional parameter <code>T</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaSpace/SatelliteToolbox.jl/blob/c7a891ae8cbd18d844cb2ba648927c3c6dfa564f/src/transformations/teme/teme.jl#L35-L55">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="SatelliteToolbox.r_tirs_to_cirs_iau2006-Tuple{Number}" href="#SatelliteToolbox.r_tirs_to_cirs_iau2006-Tuple{Number}"><code>SatelliteToolbox.r_tirs_to_cirs_iau2006</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">r_tirs_to_cirs_iau2006([T::Type,] JD_UT1::Number)</code></pre><p>Compute the rotation that aligns the Terrestrial Intermediate Reference System (TIRS) with the Celestial Intermediate Reference System (CIRS) at the Julian Day <code>JD_UT1</code> [UT1]. This algorithm uses the IAU-2006 theory.</p><p>The rotation type is described by the optional variable <code>T</code>. If it is <code>DCM</code>, then a DCM will be returned. Otherwise, if it is <code>Quaternion</code>, then a Quaternion will be returned. In case this parameter is omitted, then it falls back to <code>DCM</code>.</p><p><strong>Returns</strong></p><p>The rotation that aligns the TIRS frame with the CIRS frame. The rotation representation is selected by the optional parameter <code>T</code>.</p><p><strong>Remarks</strong></p><p>The reference frames TIRS and CIRS are separated by a rotation about the Z-axis of the Earth Rotation Angle, which is the angle between the Conventional International Origin (CIO) and the Terrestrial Intermediate Origin (TIO) [1]. The latter is a reference meridian on Earth that is located about 100m away from Greenwich meridian along the equator of the Celestial Intermediate Pole (CIP) [1].</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaSpace/SatelliteToolbox.jl/blob/c7a891ae8cbd18d844cb2ba648927c3c6dfa564f/src/transformations/iau2006/iau2006_cio.jl#L170-L196">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="SatelliteToolbox.r_tirs_to_ers_iau2006" href="#SatelliteToolbox.r_tirs_to_ers_iau2006"><code>SatelliteToolbox.r_tirs_to_ers_iau2006</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">r_tirs_to_ers_iau2006([T::Type,] JD_UT1::Number, JD_TT::Number, δΔΨ_2000::Number = 0)</code></pre><p>Compute the rotation that aligns the Terrestrial Intermediate Reference System (TIRS) with the Earth Reference System (ERS) at the Julian Day <code>JD_UT1</code> [UT1] and <code>JD_TT</code> [Terrestrial Time]. This algorithm uses the IAU-2006 theory.</p><p>Notice that one can provide corrections for the nutation in longitude (<code>δΔψ_2000</code>) [rad] that are usually obtained from IERS EOP Data (see <a href="#SatelliteToolbox.get_iers_eop"><code>get_iers_eop</code></a> and <a href="#SatelliteToolbox.deps_dpsi-Tuple{EOPData_IAU2000A, Number}"><code>deps_dpsi</code></a>). This corrections are related to Free Core Nutation (FCN) that models the effect of a liquid Earth core.</p><p>The rotation type is described by the optional variable <code>T</code>. If it is <code>DCM</code>, then a DCM will be returned. Otherwise, if it is <code>Quaternion</code>, then a Quaternion will be returned. In case this parameter is omitted, then it falls back to <code>DCM</code>.</p><p><strong>Returns</strong></p><p>The rotation that aligns the TIRS frame with the ERS frame. The rotation representation is selected by the optional parameter <code>T</code>.</p><p><strong>Remarks</strong></p><p>The reference frames TIRS and ERS are separated by a rotation about the Z-axis of the Greenwhich apparent sidereal angle (GAST). This angle is computed using the IAU-2006 theory, which consist of obtaining the Earth Rotation Angle (ERA) and subtracting the result of the Equation of Origins (EO).</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaSpace/SatelliteToolbox.jl/blob/c7a891ae8cbd18d844cb2ba648927c3c6dfa564f/src/transformations/iau2006/iau2006_equinox.jl#L66-L96">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="SatelliteToolbox.r_tirs_to_itrf_iau2006-Tuple{Number, Number, Number}" href="#SatelliteToolbox.r_tirs_to_itrf_iau2006-Tuple{Number, Number, Number}"><code>SatelliteToolbox.r_tirs_to_itrf_iau2006</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">r_tirs_to_itrf_iau2006([T::Type,] JD_TT::Number, x_p::Number, y_p::Number)</code></pre><p>Compute the rotation that aligns the Terrestrial Intermediate Reference System (TIRS) with the International Terrestrial Reference Frame (ITRF) considering the polar motion represented by the angles <code>x_p</code> [rad] and <code>y_p</code> [rad] that are obtained from IERS EOP Data (see <code>get_iers_eop</code>).</p><p><code>x_p</code> is the polar motion displacement about X-axis, which is the IERS Reference Meridian direction (positive south along the 0˚ longitude meridian). <code>y_p</code> is the polar motion displacement about Y-axis (90˚W or 270˚E meridian).</p><p>The rotation type is described by the optional variable <code>T</code>. If it is <code>DCM</code>, then a DCM will be returned. Otherwise, if it is <code>Quaternion</code>, then a Quaternion will be returned. In case this parameter is omitted, then it falls back to <code>DCM</code>.</p><p><strong>Returns</strong></p><p>The rotation that aligns the TIRS frame with the ITRF frame. The rotation representation is selected by the optional parameter <code>T</code>.</p><p><strong>Remarks</strong></p><p>The ITRF is defined based on the International Reference Pole (IRP), which is the location of the terrestrial pole agreed by international committees [1]. The Terrestrial Intermediate Reference Frame (TIRS), on the other hand, is defined based on the Earth axis of rotation, or the Celestial Intermediate Pole (CIP). Hence, TIRS XY-plane contains the True Equator. Furthermore, since the recovered latitude and longitude are sensitive to the CIP, then it should be computed considering the TIRS frame.</p><p>The TIRS and PEF (IAU-76/FK5) are virtually the same reference frame, but according to [1] it is convenient to separate the names as the exact formulae differ.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaSpace/SatelliteToolbox.jl/blob/c7a891ae8cbd18d844cb2ba648927c3c6dfa564f/src/transformations/iau2006/iau2006_cio.jl#L110-L146">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="SatelliteToolbox.r_tirs_to_mod_iau2006" href="#SatelliteToolbox.r_tirs_to_mod_iau2006"><code>SatelliteToolbox.r_tirs_to_mod_iau2006</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">r_tirs_to_mod_iau2006([T::Type,] JD_UT1::Number, JD_TT::Number, δΔϵ_2000::Number = 0, δΔΨ_2000::Number = 0)</code></pre><p>Compute the rotation that aligns the Terrestrial Intermediate Reference System (TIRS) with the Mean of Date (MOD) reference frame at the Julian Day <code>JD_UT1</code> [UT1] and <code>JD_TT</code> [Terrestrial Time]. This algorithm uses the IAU-2006 theory.</p><p>Notice that one can provide corrections for the nutation in obliquity (<code>δΔϵ_2000</code>) and in longitude (<code>δΔψ_2000</code>) [rad] that are usually obtained from IERS EOP Data (see <a href="#SatelliteToolbox.get_iers_eop"><code>get_iers_eop</code></a> and <a href="#SatelliteToolbox.deps_dpsi-Tuple{EOPData_IAU2000A, Number}"><code>deps_dpsi</code></a>). This corrections are related to Free Core Nutation (FCN) that models the effect of a liquid Earth core.</p><p>The rotation type is described by the optional variable <code>T</code>. If it is <code>DCM</code>, then a DCM will be returned. Otherwise, if it is <code>Quaternion</code>, then a Quaternion will be returned. In case this parameter is omitted, then it falls back to <code>DCM</code>.</p><p><strong>Returns</strong></p><p>The rotation that aligns the TIRS frame with the ERS frame. The rotation representation is selected by the optional parameter <code>T</code>.</p><p><strong>Remarks</strong></p><p>This composed rotation TIRS &lt;=&gt; ERS &lt;=&gt; MOD is implemented as a new function because the single rotations TIRS &lt;=&gt; ERS and ERS &lt;=&gt; MOD call the function <code>nutation_eo</code>, which has a high computational burden. In this case, the composed algorithm is about 2x faster than calling those function separately.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaSpace/SatelliteToolbox.jl/blob/c7a891ae8cbd18d844cb2ba648927c3c6dfa564f/src/transformations/iau2006/iau2006_equinox.jl#L449-L480">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="SatelliteToolbox.r_tod_to_mod_fk5" href="#SatelliteToolbox.r_tod_to_mod_fk5"><code>SatelliteToolbox.r_tod_to_mod_fk5</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">r_tod_to_mod_fk5([T,] JD_TT::Number [, δΔϵ_1980::Number, δΔψ_1980::Number])</code></pre><p>Compute the rotation that aligns the True of Date (TOD) frame with the Mean of Date (MOD) frame at the Julian Day <code>JD_TT</code> [Terrestrial Time]. This algorithm uses the IAU-76/FK5 theory. Notice that one can provide corrections for the nutation in obliquity (<code>δΔϵ_1980</code>) [rad] and in longitude (<code>δΔψ_1980</code>) [rad] that are usually obtained from IERS EOP Data (see <code>get_iers_eop</code>).</p><p>The rotation type is described by the optional variable <code>T</code>. If it is <code>DCM</code>, then a DCM will be returned. Otherwise, if it is <code>Quaternion</code>, then a Quaternion will be returned. In case this parameter is omitted, then it falls back to <code>DCM</code>.</p><p><strong>Returns</strong></p><p>The rotation that aligns the TOD frame with the MOD frame. The rotation representation is selected by the optional parameter <code>T</code>.</p><p><strong>Remarks</strong></p><p>The True of Date (TOD) frame is rotated into the Mean of Date (MOD) frame considering the 1980 IAU Theory of Nutation. The IERS EOP corrections must be added if one wants to make the rotation consistent with the Geocentric Celestial Reference Systems (GCRS).</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaSpace/SatelliteToolbox.jl/blob/c7a891ae8cbd18d844cb2ba648927c3c6dfa564f/src/transformations/fk5/fk5.jl#L289-L315">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="SatelliteToolbox.r_tod_to_pef_fk5" href="#SatelliteToolbox.r_tod_to_pef_fk5"><code>SatelliteToolbox.r_tod_to_pef_fk5</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">r_tod_to_pef_fk5([T,] JD_UT1::Number, JD_TT::Number [, δΔψ_1980::Number])</code></pre><p>Compute the rotation that aligns the True of Date (TOD) frame with the Pseudo-Earth Fixed (PEF) frame at the Julian Day <code>JD_UT1</code> [UT1] and <code>JD_TT</code> [Terrestrial Time]. This algorithm uses the IAU-76/FK5 theory. Notice that one can provide correction for the nutation in longitude (<code>δΔψ_1980</code>) [rad] that is usually obtained from IERS EOP Data (see <code>get_iers_eop</code>).</p><p>The Julian Day in UT1 is used to compute the Greenwich Mean Sidereal Time (GMST) (see <code>jd_to_gmst</code>), whereas the Julian Day in Terrestrial Time is used to compute the nutation in the longitude. Notice that the Julian Day in UT1 and in Terrestrial Time must be equivalent, i.e. must be related to the same instant. This function <strong>does not</strong> check this.</p><p>The rotation type is described by the optional variable <code>T</code>. If it is <code>DCM</code>, then a DCM will be returned. Otherwise, if it is <code>Quaternion</code>, then a Quaternion will be returned. In case this parameter is omitted, then it falls back to <code>DCM</code>.</p><p><strong>Returns</strong></p><p>The rotation that aligns the TOD frame with the PEF frame. The rotation representation is selected by the optional parameter <code>T</code>.</p><p><strong>Remarks</strong></p><p>The True of Date (TOD) frame is rotated into the Pseudo-Earth Fixed (PEF) frame considering the 1980 IAU Theory of Nutation. The IERS EOP corrections must be added if one wants to make the rotation consistent with the Geocentric Celestial Reference Systems (GCRS).</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaSpace/SatelliteToolbox.jl/blob/c7a891ae8cbd18d844cb2ba648927c3c6dfa564f/src/transformations/fk5/fk5.jl#L236-L268">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="SatelliteToolbox.r_tod_to_teme" href="#SatelliteToolbox.r_tod_to_teme"><code>SatelliteToolbox.r_tod_to_teme</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">r_tod_to_teme([T,] JD_TT::Number [, δΔϵ_1980::Number = 0, δΔψ_1980::Number = 0])</code></pre><p>Compute the rotation that aligns the True of Date (TOD) frame with the True Equator Mean Equinox (TEME) frame at the Julian Day <code>JD_TT</code> [Terrestrial Time]. This algorithm uses the IAU-76/FK5 theory and TEME definition in [1, p. 233]. Notice that one can provide corrections for the nutation in obliquity (<code>δΔϵ_1980</code>) [rad] and in longitude (<code>δΔψ_1980</code>) [rad] that are usually obtained from IERS EOP Data (see <code>get_iers_eop</code>).</p><p>The rotation type is described by the optional variable <code>T</code>. If it is <code>DCM</code>, then a DCM will be returned. Otherwise, if it is <code>Quaternion</code>, then a Quaternion will be returned. In case this parameter is omitted, then it falls back to <code>DCM</code>.</p><p><strong>Returns</strong></p><p>The rotation that aligns the TOD frame with the TEME frame. The rotation representation is selected by the optional parameter <code>T</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaSpace/SatelliteToolbox.jl/blob/c7a891ae8cbd18d844cb2ba648927c3c6dfa564f/src/transformations/teme/teme.jl#L101-L121">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="SatelliteToolbox.read_iers_eop" href="#SatelliteToolbox.read_iers_eop"><code>SatelliteToolbox.read_iers_eop</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">read_iers_eop(filename::String, data_type::Symbol = :IAU1980)</code></pre><p>Read IERS EOP Data from the file <code>filename</code>. The user must specify if the data is related to the model IAU 1980 (<code>data_type = :IAU1980</code>), which is the default, or to the model IAU 2000A (<code>data_type = :IAU2000A</code>).</p><p><strong>Returns</strong></p><p>A structure (<code>EOPData_IAU1980</code> or <code>EOPData_IAU2000A</code>, depending on <code>data_type</code>) with the interpolations of the EOP parameters. Notice that the interpolation indexing is set to the Julian Day.</p><p><strong>Remarks</strong></p><p>The input file <strong>must be exactly the same</strong> as provided by IERS. One can download it using the following commands:</p><ul><li><p>IAU 1980</p><pre><code class="language-none">  curl -O https://datacenter.iers.org/data/latestVersion/223_EOP_C04_14.62-NOW.IAU1980223.txt
  wget https://datacenter.iers.org/data/latestVersion/223_EOP_C04_14.62-NOW.IAU1980223.txt</code></pre></li><li><p>IAU 2000A</p><pre><code class="language-none">  curl -O https://datacenter.iers.org/data/latestVersion/224_EOP_C04_14.62-NOW.IAU2000A224.txt
  wget https://datacenter.iers.org/data/latestVersion/224_EOP_C04_14.62-NOW.IAU2000A224.txt</code></pre></li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaSpace/SatelliteToolbox.jl/blob/c7a891ae8cbd18d844cb2ba648927c3c6dfa564f/src/transformations/eop.jl#L152-L180">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="SatelliteToolbox.rv_to_kepler" href="#SatelliteToolbox.rv_to_kepler"><code>SatelliteToolbox.rv_to_kepler</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">rv_to_kepler(r_i::AbstractVector, v_i::AbstractVector, t::Number = 0)
rv_to_kepler(x::Number, y::Number, z::Number, vx::Number, vy::Number, vz::Number, t::Number = 0)</code></pre><p>Convert a Cartesian representation (position vector <code>r_i</code> [m] and velocity vector <code>v_i</code> [m/s²]) to the Keplerian elements. Optionally, the user can specify the epoch of the returned elements using the parameter <code>t</code>. It it is omitted, then it default to 0.</p><p>The input vectors can also be passed component by component:</p><pre><code class="language-none">r_i = [x,   y,  z]
v_i = [vx, vy, vz]</code></pre><p><strong>Returns</strong></p><p>An instance of the structure <code>KeplerianElements</code> [SI units].</p><p><strong>Remarks</strong></p><p>The special cases are treated as follows:</p><ul><li><strong>Circular and equatorial</strong>: the right ascension of the ascending node and the argument of perigee are set to 0. Hence, the true anomaly is equal to the true longitude.</li><li><strong>Elliptical and equatorial</strong>: the right ascension of the ascending node is set to 0. Hence, the argument of perigee is equal to the longitude of periapsis.</li><li><strong>Circular and inclined</strong>: the argument of perigee is set to 0. Hence, the true anomaly is equal to the argument of latitude.</li></ul><p><strong>References</strong></p><p>The algorithm was adapted from [1].</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaSpace/SatelliteToolbox.jl/blob/c7a891ae8cbd18d844cb2ba648927c3c6dfa564f/src/orbit/representations/rv.jl#L99-L134">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="SatelliteToolbox.rv_to_mean_elements_j2osc-Union{Tuple{Tv}, Tuple{T}, Tuple{AbstractVector{T}, AbstractVector{Tv}, AbstractVector{Tv}}, Tuple{AbstractVector{T}, AbstractVector{Tv}, AbstractVector{Tv}, Any}} where {T, Tv&lt;:(AbstractVector{T} where T)}" href="#SatelliteToolbox.rv_to_mean_elements_j2osc-Union{Tuple{Tv}, Tuple{T}, Tuple{AbstractVector{T}, AbstractVector{Tv}, AbstractVector{Tv}}, Tuple{AbstractVector{T}, AbstractVector{Tv}, AbstractVector{Tv}, Any}} where {T, Tv&lt;:(AbstractVector{T} where T)}"><code>SatelliteToolbox.rv_to_mean_elements_j2osc</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">rv_to_mean_elements_j2osc(vJD::AbstractVector{T}, vr::AbstractVector{Tv}, vv::AbstractVector{Tv}, W = I; mean_elements_epoch::Symbol = :end, max_it::Int = 50, j2_gc = sgp4_gc_wgs84, atol::Number = 2e-4, rtol::Number = 2e-4) where {T,Tv&lt;:AbstractVector}</code></pre><p>Compute the mean elements for SGP4 based on the position <code>vr</code> and velocity vectors <code>vr</code> represented in TEME reference frame. The epoch of those measurements [Julian Day] must be in <code>vJD</code>.</p><p>The matrix <code>W</code> defined the weights for the least-square algorithm.</p><p><strong>Keywords</strong></p><ul><li><code>estimate_bstar</code>: If <code>true</code>, then the BSTAR parameters of the TLE will be                   estimated.</li><li><code>mean_elements_epoch</code>: If it is  <code>:end</code>, the epoch of the mean elements will                        be equal to the last value in <code>vJD</code>. Otherwise, if it                        is <code>:begin</code>, the epoch will be selected as the first                        value in <code>vJD</code>.</li><li><code>max_it</code>: The maximum allowed number of iterations.</li><li><code>sgp4_gc</code>: SPG4 constants (see <code>SGP4_GravCte</code>).</li><li><code>atol</code>: The tolerance for the absolute value of the residue. If, at any         iteration, the residue is lower than <code>atol</code>, then the iterations stop.</li><li><code>rtol</code>: The tolerance for the relative difference between the residues. If, at         any iteration, the relative difference between the residues in two         consecutive iterations is lower than <code>rtol</code>, then the iterations stop.</li></ul><p><strong>Returns</strong></p><ul><li>The epoch of the elements [Julian Day].</li><li>The mean elements for SGP4 algorithm:<ul><li>Semi-major axis [m];</li><li>Eccentricity [ ];</li><li>Inclination [rad];</li><li>Right ascension of the ascending node [rad];</li><li>Argument of perigee [rad];</li><li>True anomaly [rad];</li><li>BSTAR (0 if <code>estimate_bstar</code> is <code>false</code>).</li></ul></li><li>The covariance matrix of the mean elements estimation.</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaSpace/SatelliteToolbox.jl/blob/c7a891ae8cbd18d844cb2ba648927c3c6dfa564f/src/orbit/mean_elements/j2osc.jl#L21-L59">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="SatelliteToolbox.rv_to_mean_elements_sgp4-Union{Tuple{Tv}, Tuple{T}, Tuple{AbstractVector{T}, AbstractVector{Tv}, AbstractVector{Tv}}, Tuple{AbstractVector{T}, AbstractVector{Tv}, AbstractVector{Tv}, Any}} where {T, Tv&lt;:(AbstractVector{T} where T)}" href="#SatelliteToolbox.rv_to_mean_elements_sgp4-Union{Tuple{Tv}, Tuple{T}, Tuple{AbstractVector{T}, AbstractVector{Tv}, AbstractVector{Tv}}, Tuple{AbstractVector{T}, AbstractVector{Tv}, AbstractVector{Tv}, Any}} where {T, Tv&lt;:(AbstractVector{T} where T)}"><code>SatelliteToolbox.rv_to_mean_elements_sgp4</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">rv_to_mean_elements_sgp4(vJD::AbstractVector{T}, vr::AbstractVector{Tv}, vv::AbstractVector{Tv}, W = I; estimate_bstar::Bool = true, mean_elements_epoch::Symbol = :end, max_it::Int = 50, sgp4_gc = sgp4_gc_wgs84, atol::Number = 2e-4, rtol::Number = 2e-4) where {T,Tv&lt;:AbstractVector}</code></pre><p>Compute the mean elements for SGP4 based on the position <code>vr</code> and velocity vectors <code>vr</code> represented in TEME reference frame. The epoch of those measurements [Julian Day] must be in <code>vJD</code>.</p><p>The matrix <code>W</code> defined the weights for the least-square algorithm.</p><p><strong>Keywords</strong></p><ul><li><code>estimate_bstar</code>: If <code>true</code>, then the BSTAR parameters of the TLE will be                   estimated.</li><li><code>mean_elements_epoch</code>: If it is  <code>:end</code>, the epoch of the mean elements will                        be equal to the last value in <code>vJD</code>. Otherwise, if it                        is <code>:begin</code>, the epoch will be selected as the first                        value in <code>vJD</code>.</li><li><code>max_it</code>: The maximum allowed number of iterations.</li><li><code>sgp4_gc</code>: SPG4 constants (see <code>SGP4_GravCte</code>).</li><li><code>atol</code>: The tolerance for the absolute value of the residue. If, at any         iteration, the residue is lower than <code>atol</code>, then the iterations stop.</li><li><code>rtol</code>: The tolerance for the relative difference between the residues. If, at         any iteration, the relative difference between the residues in two         consecutive iterations is lower than <code>rtol</code>, then the iterations stop.</li></ul><p><strong>Returns</strong></p><ul><li>The epoch of the elements [Julian Day].</li><li>The mean elements for SGP4 algorithm:<ul><li>Semi-major axis [m];</li><li>Eccentricity [ ];</li><li>Inclination [rad];</li><li>Right ascension of the ascending node [rad];</li><li>Argument of perigee [rad];</li><li>True anomaly [rad];</li><li>BSTAR (0 if <code>estimate_bstar</code> is <code>false</code>).</li></ul></li><li>The covariance matrix of the mean elements estimation.</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaSpace/SatelliteToolbox.jl/blob/c7a891ae8cbd18d844cb2ba648927c3c6dfa564f/src/orbit/mean_elements/sgp4.jl#L20-L58">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="SatelliteToolbox.rv_to_tle-Tuple" href="#SatelliteToolbox.rv_to_tle-Tuple"><code>SatelliteToolbox.rv_to_tle</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">rv_to_tle(args...; name::String = &quot;UNDEFINED&quot;, sat_num::Int = 9999, classification::Char = &#39;U&#39;, int_designator = &quot;999999&quot;, elem_set_number::Int = 0, rev_num, kwargs...)</code></pre><p>Convert a set of position and velocity vectors represented in TEME reference frame to a TLE. The arguments <code>args</code> and keywords <code>kwargs</code> are the same as those described in the function <code>rv_to_mean_elements_sgp4</code>.</p><p>Additionally, the user can specify some parameters of the generated TLE.</p><p>This function returns the TLE and the covariance of the estimated elements (state vector).</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaSpace/SatelliteToolbox.jl/blob/c7a891ae8cbd18d844cb2ba648927c3c6dfa564f/src/orbit/mean_elements/sgp4.jl#L199-L211">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="SatelliteToolbox.satellite_check_Brazil-Tuple{Number, Number}" href="#SatelliteToolbox.satellite_check_Brazil-Tuple{Number, Number}"><code>SatelliteToolbox.satellite_check_Brazil</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">satellite_check_Brazil(lat::Number, lon::Number)</code></pre><p>Verify if a point described by latitude <code>lat</code> [rad] and longitude <code>lon</code> [rad] is inside Brazil. Returns <code>true</code> if the point is inside Brazil, of <code>false</code> otherwise.</p><p><strong>Remarks</strong></p><p>This function was based on the algorithm sent by Renato Branco to Ronan Arraes by e-mail at 2016-02-16.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaSpace/SatelliteToolbox.jl/blob/c7a891ae8cbd18d844cb2ba648927c3c6dfa564f/src/analysis/satellite_position_countries.jl#L13-L25">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="SatelliteToolbox.satellite_lighting_condition-Tuple{AbstractVector{T} where T, AbstractVector{T} where T}" href="#SatelliteToolbox.satellite_lighting_condition-Tuple{AbstractVector{T} where T, AbstractVector{T} where T}"><code>SatelliteToolbox.satellite_lighting_condition</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">satellite_lighting_condition(r_i::AbstractVector, s_i::AbstractVector)</code></pre><p>Compute the satellite lighting condition given the Sun unitary vector <code>s_i</code> [m] and the satellite position vector <code>r_i</code> [m].</p><p><strong>Returns</strong></p><ul><li><code>SAT_LIGHTING_SUNLIGHT</code>: Satellite is under sunlight.</li><li><code>SAT_LIGHTING_PENUMBRA</code>: Satellite is at penumbra region.</li><li><code>SAT_LIGHTING_UMBRA</code>: Satellite is at umbra region.</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaSpace/SatelliteToolbox.jl/blob/c7a891ae8cbd18d844cb2ba648927c3c6dfa564f/src/analysis/lighting_conditions.jl#L28-L40">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="SatelliteToolbox.satellite_position_i-NTuple{6, Number}" href="#SatelliteToolbox.satellite_position_i-NTuple{6, Number}"><code>SatelliteToolbox.satellite_position_i</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">satellite_position_i(a::Number, e::Number, i::Number, RAAN::Number, w::Number, f::Number)</code></pre><p>Compute the satellite position in the Earth-Centered Inertial (ECI) reference frame given the orbital elements <code>a</code>, <code>e</code>, <code>i</code>, <code>RAAN</code>, <code>w</code>, and <code>f</code>.</p><p>Notice that the ECI frame used will be the same as the frame of the orbital elements.</p><p><strong>Args</strong></p><ul><li><code>a</code>: Semi-major axis.</li><li><code>e</code>: Eccentricity.</li><li><code>i</code>: Inclination [rad].</li><li><code>RAAN</code>: Right ascension of the ascending node [rad].</li><li><code>w</code>: Argument of perigee [rad].</li><li><code>f</code>: True anomaly [rad].</li></ul><p><strong>Returns</strong></p><ul><li>The satellite position vector represented in the ECI reference frame.</li><li>The unit vector perpendicular to the satellite position vector that lies on the orbit plane represented in the ECI reference frame.</li></ul><p><strong>Remarks</strong></p><p>The satellite position vector will have the same unit of the semi-major axis.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaSpace/SatelliteToolbox.jl/blob/c7a891ae8cbd18d844cb2ba648927c3c6dfa564f/src/transformations/position.jl#L11-L39">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="SatelliteToolbox.satellite_sun_angle_earth_pointing" href="#SatelliteToolbox.satellite_sun_angle_earth_pointing"><code>SatelliteToolbox.satellite_sun_angle_earth_pointing</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">satellite_sun_angle_earth_pointing(JD0::Number, a::Number, e::Number, i::Number, RAAN::Number, w::Number, numDays::Integer, fN_k::Function, meanAnomaly::Bool = false, step::Number = 0.1*pi/180.0)</code></pre><p>Compute the Sun angle on a satellite surface for an Earth-pointing mission.</p><p><strong>Args</strong></p><ul><li><code>JD0</code>: Initial instant for the analysis [Julian day].</li><li><code>a</code>: Semi-major axis of the orbit [m].</li><li><code>e</code>: Orbit eccentricity.</li><li><code>i</code>: Orbit inclination [rad].</li><li><code>w</code>: Argument of perigee [rad].</li><li><code>RAAN</code>: Right ascension of the ascending node at <code>JD0</code> [rad].</li><li><code>numDays</code>: Number of days for the analysis.</li><li><code>fN_k</code>: Function <strong>f(s_b)</strong> that describes the solar panel normal at each k-th         sampling step. Notice that <strong>s_b</strong> is the Sun vector represented in         the body coordinate frame.</li><li><code>meanAnomaly</code>: (OPTIONAL) If <strong>true</strong>, compute using angular steps in the mean                anomaly instead of in the orbit latitude (<strong>Default</strong>: false).</li><li><code>step</code>: (OPTIONAL) Mean anomaly step (<strong>Default</strong>: 0.1 deg).</li></ul><p><strong>Returns</strong></p><p>A matrix containing the sun angle [rad] for each position in orbit for each day.</p><p><strong>NOTE</strong>: if the Sun angle is larger than 90 deg or if the satellite is in eclipse, then <code>NaN</code> is returned in the matrix.</p><p><strong>Remarks</strong></p><p>The body reference frame is defined as:</p><ul><li><strong>Z axis</strong> points towards the center of Earth;</li><li><strong>Y axis</strong> points towards the negative direction of orbit normal;</li><li><strong>X axis</strong> completes the right-hand reference frame.</li></ul><p>If the <strong>mean anomaly</strong> is used, then the average value of the output is the average sun radiation received by the satellite surface, because every angular steps have a fixed time interval.</p><p>If the <strong>mean anomaly</strong> is used, then the angle interval is [0, 2π]. Otherwise, the angle interval is [-π,π].</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaSpace/SatelliteToolbox.jl/blob/c7a891ae8cbd18d844cb2ba648927c3c6dfa564f/src/analysis/sun_angle.jl#L11-L54">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="SatelliteToolbox.satellite_sun_angle_earth_pointing" href="#SatelliteToolbox.satellite_sun_angle_earth_pointing"><code>SatelliteToolbox.satellite_sun_angle_earth_pointing</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">satellite_sun_angle_earth_pointing(JD0::Number, a::Number, e::Number, i::Number, RAAN::Number, w::Number, numDays::Integer, N::AbstractVector, step::Number = 0.1*pi/180.0)</code></pre><p>Compute the Sun angle on a satellite surface for an Earth-pointing mission.</p><p><strong>Args</strong></p><ul><li><code>JD0</code>: Initial instant for the analysis [Julian day].</li><li><code>a</code>: Semi-major axis of the orbit [m].</li><li><code>e</code>: Orbit eccentricity.</li><li><code>i</code>: Orbit inclination [rad].</li><li><code>w</code>: Argument of perigee [rad].</li><li><code>RAAN</code>: Right ascension of the ascending node at <code>JD0</code> [rad].</li><li><code>numDays</code>: Number of days for the analysis.</li><li><code>N</code>: Vector normal to the surface represented in the body reference frame.</li><li><code>meanAnomaly</code>: (OPTIONAL) If <strong>true</strong>, compute using angular steps in the mean                anomaly instead of in the orbit latitude (<strong>Default</strong>: false).</li><li><code>step</code>: (OPTIONAL) Mean anomaly step (<strong>Default</strong>: 0.1 deg).</li></ul><p><strong>Returns</strong></p><p>A matrix containing the Sun angle for each position in orbit for each day.</p><p><strong>NOTE</strong>: if the Sun angle is larger than 90 deg or if the satellite is in eclipse, then <code>NaN</code> is returned in the matrix.</p><p><strong>Remarks</strong></p><p>The body reference frame is defined as:</p><ul><li><strong>Z axis</strong> points towards the center of Earth;</li><li><strong>Y axis</strong> points towards the negative direction of orbit normal;</li><li><strong>X axis</strong> completes the right-hand reference frame.</li></ul><p>If the <strong>mean anomaly</strong> is used, then the average value of the output is the average sun radiation received by the satellite surface, because every angular steps have a fixed time interval.</p><p>If the <strong>mean anomaly</strong> is used, then the angle interval is [0, 2π]. Otherwise, the angle interval is [-π,π].</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaSpace/SatelliteToolbox.jl/blob/c7a891ae8cbd18d844cb2ba648927c3c6dfa564f/src/analysis/sun_angle.jl#L168-L209">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="SatelliteToolbox.satellite_sun_radiation_earth_pointing" href="#SatelliteToolbox.satellite_sun_radiation_earth_pointing"><code>SatelliteToolbox.satellite_sun_radiation_earth_pointing</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">satellite_sun_radiation_earth_pointing(JD0::Number, a::Number, e::Number, i::Number, RAAN::Number, w::Number, numDays::Integer, N::Vector, meanAnomaly::Bool = false, step::Number = 0.1*pi/180.0)</code></pre><p>Compute the Sun radiation on a satellite surface for an Earth-pointing mission.</p><p><strong>Args</strong></p><ul><li><code>JD0</code>: Initial instant for the analysis [Julian day].</li><li><code>a</code>: Semi-major axis of the orbit [m].</li><li><code>e</code>: Orbit eccentricity.</li><li><code>i</code>: Orbit inclination [rad].</li><li><code>w</code>: Argument of perigee [rad].</li><li><code>RAAN</code>: Right ascension of the ascending node at <code>JD0</code> [rad].</li><li><code>numDays</code>: Number of days for the analysis.</li><li><code>N</code>: Vector normal to the surface represented in the body reference frame.</li><li><code>meanAnomaly</code>: (OPTIONAL) If <strong>true</strong>, compute using angular steps in the mean                anomaly instead of in the orbit latitude (<strong>Default</strong>: false).</li><li><code>step</code>: (OPTIONAL) Mean anomaly step (<strong>Default</strong>: 0.1 deg).</li></ul><p><strong>Returns</strong></p><p>A matrix containing the Sun radiation [W/m²] for each position in orbit for each day.</p><p><strong>NOTE</strong>: if the Sun angle is larger than 90 deg or if the satellite is in eclipse, then <code>NaN</code> is returned in the matrix.</p><p><strong>Remarks</strong></p><p>The body reference frame is defined as:</p><ul><li><strong>Z axis</strong> points towards the center of Earth;</li><li><strong>Y axis</strong> points towards the negative direction of orbit normal;</li><li><strong>X axis</strong> completes the right-hand reference frame.</li></ul><p>If the <strong>mean anomaly</strong> is used, then the average value of the output is the average sun radiation received by the satellite surface, because every angular steps have a fixed time interval.</p><p>If the <strong>mean anomaly</strong> is used, then the angle interval is [0, 2π]. Otherwise, the angle interval is [-π,π].</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaSpace/SatelliteToolbox.jl/blob/c7a891ae8cbd18d844cb2ba648927c3c6dfa564f/src/analysis/sun_radiation.jl#L229-L271">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="SatelliteToolbox.satellite_sun_radiation_earth_pointing" href="#SatelliteToolbox.satellite_sun_radiation_earth_pointing"><code>SatelliteToolbox.satellite_sun_radiation_earth_pointing</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">satellite_sun_radiation_earth_pointing(JD0::Number, a::Number, e::Number, i::Number, RAAN::Number, w::Number, numDays::Integer, fN_k::Function, meanAnomaly::Bool = false, step::Number = 0.1*pi/180.0)</code></pre><p>Compute the Sun radiation on a satellite surface for an Earth-pointing mission.</p><p><strong>Args</strong></p><ul><li><code>JD0</code>: Initial instant for the analysis [Julian day].</li><li><code>a</code>: Semi-major axis of the orbit [m].</li><li><code>e</code>: Orbit eccentricity.</li><li><code>i</code>: Orbit inclination [rad].</li><li><code>w</code>: Argument of perigee [rad].</li><li><code>RAAN</code>: Right ascension of the ascending node at <code>JD0</code> [rad].</li><li><code>numDays</code>: Number of days for the analysis.</li><li><code>fN_k</code>: Function <strong>f(s_b)</strong> that describes the solar panel normal at each k-th         sampling step. Notice that <strong>s_b</strong> is the Sun vector represented in         the body coordinate frame.</li><li><code>meanAnomaly</code>: (OPTIONAL) If <strong>true</strong>, compute using angular steps in the mean                anomaly instead of in the orbit latitude (<strong>Default</strong>: false).</li><li><code>step</code>: (OPTIONAL) Mean anomaly step (<strong>Default</strong>: 0.1 deg).</li></ul><p><strong>Returns</strong></p><p>A matrix containing the Sun radiation [W/m²] for each position in orbit for each day.</p><p><strong>NOTE</strong>: if the Sun angle is larger than 90 deg or if the satellite is in eclipse, then <code>NaN</code> is returned in the matrix.</p><p><strong>Remarks</strong></p><p>The body reference frame is defined as:</p><ul><li><strong>Z axis</strong> points towards the center of Earth;</li><li><strong>Y axis</strong> points towards the negative direction of orbit normal;</li><li><strong>X axis</strong> completes the right-hand reference frame.</li></ul><p>If the <strong>mean anomaly</strong> is used, then the average value of the output is the average sun radiation received by the satellite surface, because every angular steps have a fixed time interval.</p><p>If the <strong>mean anomaly</strong> is used, then the angle interval is [0, 2π]. Otherwise, the angle interval is [-π,π].</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaSpace/SatelliteToolbox.jl/blob/c7a891ae8cbd18d844cb2ba648927c3c6dfa564f/src/analysis/sun_radiation.jl#L12-L56">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="SatelliteToolbox.satellite_sun_radiation_earth_pointing_mean" href="#SatelliteToolbox.satellite_sun_radiation_earth_pointing_mean"><code>SatelliteToolbox.satellite_sun_radiation_earth_pointing_mean</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">satellite_sun_radiation_earth_pointing_mean(JD0::Number, a::Number, e::Number, i::Number, RAAN::Number, w::Number, numDays::Integer, N::AbstractVector, step::Number = 0.1*pi/180.0)</code></pre><p>Compute the mean Sun radiation on a satellite surface for an Earth-pointing mission.</p><p><strong>Args</strong></p><ul><li><code>JD0</code>: Initial instant for the analysis [Julian day].</li><li><code>a</code>: Semi-major axis of the orbit [m].</li><li><code>e</code>: Orbit eccentricity.</li><li><code>i</code>: Orbit inclination [rad].</li><li><code>w</code>: Argument of perigee [rad].</li><li><code>RAAN</code>: Right ascension of the ascending node at <code>JD0</code> [rad].</li><li><code>numDays</code>: Number of days for the analysis.</li><li><code>N</code>: Vector normal to the surface represented in the body reference frame.</li><li><code>meanAnomaly</code>: (OPTIONAL) If <strong>true</strong>, compute using angular steps in the mean                anomaly instead of in the orbit latitude (<strong>Default</strong>: false).</li><li><code>step</code>: (OPTIONAL) Mean anomaly step (<strong>Default</strong>: 0.1 deg).</li></ul><p><strong>Returns</strong></p><p>The mean Sun radiation on a surface [W/m²].</p><p><strong>Remarks</strong></p><p>For more details, see <strong>satellite<em>sun</em>radiation<em>earth</em>pointing</strong>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaSpace/SatelliteToolbox.jl/blob/c7a891ae8cbd18d844cb2ba648927c3c6dfa564f/src/analysis/sun_radiation.jl#L287-L315">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="SatelliteToolbox.satellite_sun_radiation_earth_pointing_mean" href="#SatelliteToolbox.satellite_sun_radiation_earth_pointing_mean"><code>SatelliteToolbox.satellite_sun_radiation_earth_pointing_mean</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">satellite_sun_radiation_earth_pointing_mean(JD0::Number, a::Number, e::Number, i::Number, RAAN::Number, w::Number, numDays::Integer, fN_k::Function, step::Number = 0.1*pi/180.0)</code></pre><p>Compute the mean Sun radiation on a satellite surface for an Earth-pointing mission.</p><p><strong>Args</strong></p><ul><li><code>JD0</code>: Initial instant for the analysis [Julian day].</li><li><code>a</code>: Semi-major axis of the orbit [m].</li><li><code>e</code>: Orbit eccentricity.</li><li><code>i</code>: Orbit inclination [rad].</li><li><code>w</code>: Argument of perigee [rad].</li><li><code>RAAN</code>: Right ascension of the ascending node at <code>JD0</code> [rad].</li><li><code>numDays</code>: Number of days for the analysis.</li><li><code>fN_k</code>: Function <strong>f(s_b)</strong> that describes the solar panel normal at each k-th         sampling step. Notice that <strong>s_b</strong> is the Sun vector represented in         the body coordinate frame.</li><li><code>meanAnomaly</code>: (OPTIONAL) If <strong>true</strong>, compute using angular steps in the mean                anomaly instead of in the orbit latitude (<strong>Default</strong>: false).</li><li><code>step</code>: (OPTIONAL) Mean anomaly step (<strong>Default</strong>: 0.1 deg).</li></ul><p><strong>Returns</strong></p><p>The mean Sun radiation on a surface [W/m²].</p><p><strong>Remarks</strong></p><p>For more details, see <strong>satellite<em>sun</em>radiation<em>earth</em>pointing</strong>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaSpace/SatelliteToolbox.jl/blob/c7a891ae8cbd18d844cb2ba648927c3c6dfa564f/src/analysis/sun_radiation.jl#L171-L201">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="SatelliteToolbox.sim_RAAN_J2-Tuple{Number, Number, Number, Number, Integer}" href="#SatelliteToolbox.sim_RAAN_J2-Tuple{Number, Number, Number, Number, Integer}"><code>SatelliteToolbox.sim_RAAN_J2</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">sim_RAAN_J2(a::Number, e::Number, i::Number, RAAN_0::Number, numDays::Integer)</code></pre><p>Simulate the RAAN of an orbit with semi-major axis <code>a</code> [m], eccentricity <code>e</code>, inclination <code>i</code> [rad], and initial RAAN <code>RAAN_0</code> [rad] considering J2 perturbations. The analysis is performed for <code>numDays</code> days.</p><p><strong>Returns</strong></p><p>A <code>numDays</code> × 2 matrix in which the i-th line is:</p><pre><code class="language-none">| day | RAAN (0,2π) [rad] |</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaSpace/SatelliteToolbox.jl/blob/c7a891ae8cbd18d844cb2ba648927c3c6dfa564f/src/analysis/raan.jl#L40-L53">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="SatelliteToolbox.sort_list_ss_orbits_by_height-Tuple{Matrix{T} where T}" href="#SatelliteToolbox.sort_list_ss_orbits_by_height-Tuple{Matrix{T} where T}"><code>SatelliteToolbox.sort_list_ss_orbits_by_height</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">sort_list_ss_orbits_by_height(ss_orbits::Matrix)</code></pre><p>Sort the list of Sun-synchronous orbits <code>ss_orbits</code> (see <code>list_ss_orbits_by_rep_period</code>) by height and return a new matrix.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaSpace/SatelliteToolbox.jl/blob/c7a891ae8cbd18d844cb2ba648927c3c6dfa564f/src/orbit/orbit_sun_sync_ground_reap.jl#L221-L227">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="SatelliteToolbox.step!" href="#SatelliteToolbox.step!"><code>SatelliteToolbox.step!</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">step!(orbp::OrbitPropagator{T}, Δt::Number)</code></pre><p>Propagate the orbit in <code>orbp</code> by <code>Δt</code> [s] using the algorithm of <code>orbp</code>. The new parameters will be written in <code>orbp</code>.</p><p><strong>Returns</strong></p><ul><li>The position vector represented in the inertial frame after the step [m].</li><li>The velocity vector represented in the inertial frame after the step [m].</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaSpace/SatelliteToolbox.jl/blob/c7a891ae8cbd18d844cb2ba648927c3c6dfa564f/src/orbit/propagators/api/api.jl#L103-L114">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="SatelliteToolbox.sun_position_i-Tuple{Number}" href="#SatelliteToolbox.sun_position_i-Tuple{Number}"><code>SatelliteToolbox.sun_position_i</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">sun_position_i(JD::Number)</code></pre><p>Compute the Sun position represented in the Mean Equinox of Date (MOD) at the Julian Day <code>JD</code>. The algorithm was adapted from [3, p. 277-279].</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaSpace/SatelliteToolbox.jl/blob/c7a891ae8cbd18d844cb2ba648927c3c6dfa564f/src/sun/sun_position.jl#L24-L30">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="SatelliteToolbox.sun_velocity_i-Tuple{Number}" href="#SatelliteToolbox.sun_velocity_i-Tuple{Number}"><code>SatelliteToolbox.sun_velocity_i</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">sun_velocity_i(JD::Number)</code></pre><p>Compute the Sun velocity represented in the Mean Equinox of Date (MOD) at the Julian Day <code>JD</code>. The algorithm was obtained by computing the time derivative of the Sun position in [3, p. 277-279].</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaSpace/SatelliteToolbox.jl/blob/c7a891ae8cbd18d844cb2ba648927c3c6dfa564f/src/sun/sun_velocity.jl#L24-L31">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="SatelliteToolbox.sv_ecef_to_ecef-Tuple{OrbitStateVector, Vararg{Any, N} where N}" href="#SatelliteToolbox.sv_ecef_to_ecef-Tuple{OrbitStateVector, Vararg{Any, N} where N}"><code>SatelliteToolbox.sv_ecef_to_ecef</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">sv_ecef_to_ecef(sv::OrbitStateVector, args...)</code></pre><p>Convert the orbit state vector <code>sv</code> from an ECEF frame to another ECEF frame. The arguments <code>args...</code> must match those of the function <code>r_ecef_to_ecef</code> <strong>wihtout</strong> the rotation representation.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaSpace/SatelliteToolbox.jl/blob/c7a891ae8cbd18d844cb2ba648927c3c6dfa564f/src/transformations/sv_ecef_to_ecef.jl#L21-L28">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="SatelliteToolbox.sv_ecef_to_eci-Tuple{OrbitStateVector, Val{:ITRF}, Union{Val{:GCRF}, Val{:J2000}, Val{:TOD}, Val{:MOD}, Val{:TEME}}, Number, EOPData_IAU1980}" href="#SatelliteToolbox.sv_ecef_to_eci-Tuple{OrbitStateVector, Val{:ITRF}, Union{Val{:GCRF}, Val{:J2000}, Val{:TOD}, Val{:MOD}, Val{:TEME}}, Number, EOPData_IAU1980}"><code>SatelliteToolbox.sv_ecef_to_eci</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">sv_ecef_to_eci(sv::OrbitStateVector, ECEF, ECI, JD_UTC [, eop_data])</code></pre><p>Convert the orbit state vector <code>sv</code> from the Earth-Centered, Earth-Fixed (ECEF) reference frame <code>ECEF</code> to the Earth-Centered Inertial (ECI) reference frame at the Julian day <code>JD_UTC</code> [UTC]. The <code>eop_data</code> may be required depending on the selection of the input and output reference system. For more information, see the documentation of the function <code>r_ecef_to_eci</code>.</p><div class="admonition is-info"><header class="admonition-header">Info</header><div class="admonition-body"><p>It is assumed that the input velocity and acceleration in <code>sv</code> are obtained by an observer on the ECEF frame. Thus, the output will contain the velocity and acceleration as measured by an observer on the ECI frame.</p></div></div></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaSpace/SatelliteToolbox.jl/blob/c7a891ae8cbd18d844cb2ba648927c3c6dfa564f/src/transformations/sv_ecef_to_eci.jl#L21-L36">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="SatelliteToolbox.sv_eci_to_ecef-Tuple{OrbitStateVector, Union{Val{:GCRF}, Val{:J2000}, Val{:TOD}, Val{:MOD}, Val{:TEME}}, Val{:ITRF}, Number, EOPData_IAU1980}" href="#SatelliteToolbox.sv_eci_to_ecef-Tuple{OrbitStateVector, Union{Val{:GCRF}, Val{:J2000}, Val{:TOD}, Val{:MOD}, Val{:TEME}}, Val{:ITRF}, Number, EOPData_IAU1980}"><code>SatelliteToolbox.sv_eci_to_ecef</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">sv_eci_to_ecef(sv::OrbitStateVector, ECI, ECEF, JD_UTC [, eop_data])</code></pre><p>Convert the orbit state vector <code>sv</code> from the Earth-Centered Inertial (ECI) reference frame <code>ECI</code> to the Earth-Centered, Earth-Fixed (ECEF) reference frame at the Julian day <code>JD_UTC</code> [UTC]. The <code>eop_data</code> may be required depending on the selection of the input and output reference system. For more information, see the documentation of the function <code>r_eci_to_ecef</code>.</p><div class="admonition is-info"><header class="admonition-header">Info</header><div class="admonition-body"><p>It is assumed that the input velocity and acceleration in <code>sv</code> are obtained by an observer on the ECI frame. Thus, the output will contain the velocity and acceleration as measured by an observer on the ECEF frame.</p></div></div></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaSpace/SatelliteToolbox.jl/blob/c7a891ae8cbd18d844cb2ba648927c3c6dfa564f/src/transformations/sv_eci_to_ecef.jl#L21-L36">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="SatelliteToolbox.sv_eci_to_eci-Tuple{OrbitStateVector, Vararg{Any, N} where N}" href="#SatelliteToolbox.sv_eci_to_eci-Tuple{OrbitStateVector, Vararg{Any, N} where N}"><code>SatelliteToolbox.sv_eci_to_eci</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">sv_eci_to_eci(sv::OrbitStateVector, args...)</code></pre><p>Convert the orbit state vector <code>sv</code> from an ECI frame to another ECI frame. The arguments <code>args...</code> must match those of the function <code>r_eci_to_eci</code> <strong>wihtout</strong> the rotation representation.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaSpace/SatelliteToolbox.jl/blob/c7a891ae8cbd18d844cb2ba648927c3c6dfa564f/src/transformations/sv_eci_to_eci.jl#L21-L28">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="SatelliteToolbox.sv_to_kepler-Tuple{OrbitStateVector}" href="#SatelliteToolbox.sv_to_kepler-Tuple{OrbitStateVector}"><code>SatelliteToolbox.sv_to_kepler</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">sv_to_kepler(sv::OrbitStateVector)</code></pre><p>Convert the state vector <code>sv</code> to Keplerian elements represented by an instance of the structure <code>KeplerianElements</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaSpace/SatelliteToolbox.jl/blob/c7a891ae8cbd18d844cb2ba648927c3c6dfa564f/src/orbit/representations/state_vector.jl#L32-L38">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="SatelliteToolbox.swath_width-Tuple{Real, Real}" href="#SatelliteToolbox.swath_width-Tuple{Real, Real}"><code>SatelliteToolbox.swath_width</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">swath_width(h::real, HalfFOV::real)</code></pre><p>Compute the swath width given the orbit altitude and the half FOV.</p><p><strong>Args</strong></p><ul><li><code>h</code>: Orbit altitude [m].</li><li><code>HalfFOV</code>: Half field of view [rad].</li></ul><p><strong>Returns</strong></p><p>The swath width [m].</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaSpace/SatelliteToolbox.jl/blob/c7a891ae8cbd18d844cb2ba648927c3c6dfa564f/src/analysis/payload_optical_analysis.jl#L99-L113">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="SatelliteToolbox.twobody!-Tuple{TwoBody_Structure, Number}" href="#SatelliteToolbox.twobody!-Tuple{TwoBody_Structure, Number}"><code>SatelliteToolbox.twobody!</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">twobody!(tbd::TwoBody_Structure, t::Number)</code></pre><p>Propagate the orbit defined in <code>tbd</code> (see <code>TwoBody_Structure</code>) until the time <code>t</code> [s]. Notice that the values in <code>tbd</code> will be modified.</p><p><strong>Returns</strong></p><ul><li>The position vector represented in the inertial frame at time <code>t</code> [m].</li><li>The velocity vector represented in the inertial frame at time <code>t</code> [m/s]</li></ul><p><strong>Remarks</strong></p><p>The inertial frame in which the output is represented depends on which frame it was used to generate the orbit parameters.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaSpace/SatelliteToolbox.jl/blob/c7a891ae8cbd18d844cb2ba648927c3c6dfa564f/src/orbit/propagators/twobody.jl#L85-L101">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="SatelliteToolbox.twobody_init-Union{Tuple{T}, NTuple{7, Number}} where T" href="#SatelliteToolbox.twobody_init-Union{Tuple{T}, NTuple{7, Number}} where T"><code>SatelliteToolbox.twobody_init</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">twobody_init(epoch::Number, a_0::Number, e_0::Number, i_0::Number, Ω_0::Number, ω_0::Number, f_0::Number; μ::T = m0) where T</code></pre><p>Initialize the data structure of two body orbit propagator algorithm.</p><p><strong>Args</strong></p><ul><li><code>epoch</code>: Epoch of the initial mean orbital elements [s].</li><li><code>a_0</code>: Initial mean semi-major axis [m].</li><li><code>e_0</code>: Initial mean eccentricity.</li><li><code>i_0</code>: Initial mean inclination [rad].</li><li><code>Ω_0</code>: Initial mean right ascension of the ascending node [rad].</li><li><code>ω_0</code>: Initial mean argument of perigee [rad].</li><li><code>f_0</code>: Initial mean true anomaly.</li></ul><p><strong>Keywords</strong></p><ul><li><code>μ</code>: Standard gravitational parameter of the central body [m^3/s^2].      (<strong>Default</strong> = <code>m0</code>)</li></ul><p><strong>Returns</strong></p><p>The structure <code>TwoBody_Structure</code> with the initialized parameters.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaSpace/SatelliteToolbox.jl/blob/c7a891ae8cbd18d844cb2ba648927c3c6dfa564f/src/orbit/propagators/twobody.jl#L29-L53">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="SatelliteToolbox.@_keyword_found-Tuple{Any, Any, Any}" href="#SatelliteToolbox.@_keyword_found-Tuple{Any, Any, Any}"><code>SatelliteToolbox.@_keyword_found</code></a> — <span class="docstring-category">Macro</span></header><section><div><pre><code class="language-julia">@_keyword_found(keyword, keywords_found, current_line)</code></pre><p>Check if the <code>keyword</code> exists in the list <code>keywords_found</code>. If <code>true</code>, then throw an error indicating that the problem occurred on the <code>current_line</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaSpace/SatelliteToolbox.jl/blob/c7a891ae8cbd18d844cb2ba648927c3c6dfa564f/src/misc/icgem.jl#L22-L28">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="SatelliteToolbox.@_parse_float-Tuple{Any}" href="#SatelliteToolbox.@_parse_float-Tuple{Any}"><code>SatelliteToolbox.@_parse_float</code></a> — <span class="docstring-category">Macro</span></header><section><div><pre><code class="language-julia">@_parse_float(input)</code></pre><p>Parse the <code>input</code> to float substituting all <code>D</code>s and <code>d</code>s  to <code>e</code>, so that we can convert numbers in FORTRAN format.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaSpace/SatelliteToolbox.jl/blob/c7a891ae8cbd18d844cb2ba648927c3c6dfa564f/src/misc/icgem.jl#L40-L46">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="SatelliteToolbox.@check_orbit-Tuple{Any, Any}" href="#SatelliteToolbox.@check_orbit-Tuple{Any, Any}"><code>SatelliteToolbox.@check_orbit</code></a> — <span class="docstring-category">Macro</span></header><section><div><pre><code class="language-julia">@check_orbit(a, e)</code></pre><p>Verify if the orbit with semi-major axis <code>a</code> [m] and eccentricity <code>e</code> is valid. This macro throws an exception if the orbit is not valid.</p><p>Return <code>true</code> is the orbit is valid, and <code>false</code> otherwise.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaSpace/SatelliteToolbox.jl/blob/c7a891ae8cbd18d844cb2ba648927c3c6dfa564f/src/orbit/general.jl#L16-L24">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="SatelliteToolbox.SGP4.SGP4_GravCte" href="#SatelliteToolbox.SGP4.SGP4_GravCte"><code>SatelliteToolbox.SGP4.SGP4_GravCte</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia">SGP4_GravCte{T&lt;:Real}</code></pre><p>Gravitational constants for SGP4.</p><p><strong>Fields</strong></p><ul><li><code>R0</code>: Earth equatorial radius [km].</li><li><code>XKE</code>: √GM [er/s]^(3/2).</li><li><code>J2</code>: The second gravitational zonal harmonic of the Earth.</li><li><code>J3</code>: The thrid gravitational zonal harmonic of the Earth.</li><li><code>J4</code>: The fourth gravitational zonal harmonic of the Earth.</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaSpace/SatelliteToolbox.jl/blob/c7a891ae8cbd18d844cb2ba648927c3c6dfa564f/src/submodules/SGP4/types.jl#L11-L24">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="SatelliteToolbox.SGP4.SGP4_Structure" href="#SatelliteToolbox.SGP4.SGP4_Structure"><code>SatelliteToolbox.SGP4.SGP4_Structure</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia">SGP4_Structure{T&lt;:Real}</code></pre><p>Low level SGP4 structure.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaSpace/SatelliteToolbox.jl/blob/c7a891ae8cbd18d844cb2ba648927c3c6dfa564f/src/submodules/SGP4/types.jl#L109-L114">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="SatelliteToolbox.SGP4.dsinit-Union{Tuple{T}, NTuple{11, T}} where T&lt;:Number" href="#SatelliteToolbox.SGP4.dsinit-Union{Tuple{T}, NTuple{11, T}} where T&lt;:Number"><code>SatelliteToolbox.SGP4.dsinit</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">dsinit(epoch::T, nll_0::T, all_0::T, e_0::T, i_0::T, Ω_0::T, ω_0::T, M_0::T, dotM::T, dotω::T, dotΩ::T) where T&lt;:Number</code></pre><p>Initialize the deep space structure. This function performs the initial computations and save the values at an instance of the structure <code>SGP4_DeepSpace</code>. Those will be used when calling the functions <code>dsper!</code> and <code>dpsec!</code>.</p><p><strong>Args</strong></p><ul><li><code>epoch</code>: Epoch of the initial orbit [Julian Day].</li><li><code>nll_0</code>: Initial mean motion [rad/min].</li><li><code>all_0</code>: Initial semi-major axis [ER].</li><li><code>e_0</code>: Initial eccentricity.</li><li><code>i_0</code>: Initial inclination [rad].</li><li><code>Ω_0</code>: Initial right ascencion of the ascending node [rad].</li><li><code>ω_0</code>: Initial argument of perigee [rad].</li><li><code>M_0</code>: Initial mean motion [rad].</li><li><code>dotM</code>: Time-derivative of the mean motion [rad/min].</li><li><code>dotω</code>: Time-derivative of the argument of perigee [rad/min].</li><li><code>dotΩ</code>: Time-derivative of the RAAN [rad/min].</li></ul><p><strong>Returns</strong></p><p>An instance of the structure <code>SGP4_DeepSpace</code> with the initalized values.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaSpace/SatelliteToolbox.jl/blob/c7a891ae8cbd18d844cb2ba648927c3c6dfa564f/src/submodules/SGP4/sgp4_model.jl#L609-L635">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="SatelliteToolbox.SGP4.dsper!-Union{Tuple{T}, Tuple{SatelliteToolbox.SGP4.SGP4_DeepSpace{T}, T, T, T, T, T, Number}} where T&lt;:Number" href="#SatelliteToolbox.SGP4.dsper!-Union{Tuple{T}, Tuple{SatelliteToolbox.SGP4.SGP4_DeepSpace{T}, T, T, T, T, T, Number}} where T&lt;:Number"><code>SatelliteToolbox.SGP4.dsper!</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">dsper!(sgp4_ds::SGP4_DeepSpace{T}, e_k::T, i_k::T, Ω_k::T, ω_k::T, M_k::T, Δt:Number) where T&lt;:Number</code></pre><p>Compute the effects caused by Lunar-Solar periodics.</p><p>Notice that the values in the structure <code>sgp4_ds</code> <strong>will be modified</strong>.</p><p><strong>Args</strong></p><ul><li><code>sgp4_ds</code>: Deep space structure (see <code>SGP4_DeepSpace</code>).</li><li><code>e_k</code>: Current eccentricity.</li><li><code>i_k</code>: Current inclination [rad].</li><li><code>Ω_k</code>: Current right ascension of the ascending node [rad].</li><li><code>ω_k</code>: Current argument of perigee [rad].</li><li><code>M_k</code>: Current mean anomaly [rad].</li><li><code>Δt</code>: Time interval since the epoch [min].</li></ul><p><strong>Returns</strong></p><p>The following elements perturbed by lunar-solar periodics.</p><ul><li>Eccentricity.</li><li>Inclination [rad].</li><li>Right ascension of the ascending node [rad].</li><li>Argument of perigee [rad].</li><li>Mean anomaly [rad].</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaSpace/SatelliteToolbox.jl/blob/c7a891ae8cbd18d844cb2ba648927c3c6dfa564f/src/submodules/SGP4/sgp4_model.jl#L1148-L1175">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="SatelliteToolbox.SGP4.dssec!-Union{Tuple{T}, Tuple{SatelliteToolbox.SGP4.SGP4_DeepSpace{T}, T, T, T, T, T, T, T, T, Number}} where T&lt;:Number" href="#SatelliteToolbox.SGP4.dssec!-Union{Tuple{T}, Tuple{SatelliteToolbox.SGP4.SGP4_DeepSpace{T}, T, T, T, T, T, T, T, T, Number}} where T&lt;:Number"><code>SatelliteToolbox.SGP4.dssec!</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">dssec!(sgp4_ds::SGP4_DeepSpace{T}, nll_0::T, e_0::T, i_0::T, ω_0::T, Ω_k::T, ω_k::T, M_k::T, dotω::T, Δt::Number) where T&lt;:Number</code></pre><p>Compute the secular effects.</p><p>Notice that the values in the structure <code>sgp4_ds</code> <strong>will be modified</strong>.</p><p><strong>Args</strong></p><ul><li><code>sgp4_ds</code>: Deep space structure (see <code>SGP4_DeepSpace</code>).</li><li><code>nll_0</code>: Initial mean motion [rad/min].</li><li><code>e_0</code>: Initial eccentricity.</li><li><code>i_0</code>: Initial inclination [rad].</li><li><code>ω_0</code>: Initial argument of perigee [rad].</li><li><code>Ω_k</code>: Current right ascension of the ascending node [rad].</li><li><code>ω_k</code>: Current argument of perigee [rad].</li><li><code>M_k</code>: Current mean anomaly [rad].</li><li><code>dotω</code>: Time-derivative of the argument of perigee [rad/min].</li><li><code>Δt</code>: Time interval since the epoch [min].</li></ul><p><strong>Returns</strong></p><p>The following elements perturbed by the secular effects:</p><ul><li>Mean motion [rad/min].</li><li>Eccentricity.</li><li>Inclination [rad].</li><li>Right ascension of the ascending node [rad].</li><li>Argument of perigee [rad].</li><li>Mean anomaly [rad].</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaSpace/SatelliteToolbox.jl/blob/c7a891ae8cbd18d844cb2ba648927c3c6dfa564f/src/submodules/SGP4/sgp4_model.jl#L1004-L1035">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="SatelliteToolbox.SGP4.j2000_to_gmst-Tuple{Number}" href="#SatelliteToolbox.SGP4.j2000_to_gmst-Tuple{Number}"><code>SatelliteToolbox.SGP4.j2000_to_gmst</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">j2000_to_gmst(J2000_UT1::Number)</code></pre><p>Compute the Greenwich Mean Sideral Time (GMST) [rad] given the instant <code>J2000_UT1</code> in J2000.0 reference [UT1].</p><p><strong>Remarks</strong></p><p>Based on algorithm in <a href="http://www.navipedia.net/index.php/CEP_to_ITRF">2</a>, accessed at 2015-12-01.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaSpace/SatelliteToolbox.jl/blob/c7a891ae8cbd18d844cb2ba648927c3c6dfa564f/src/submodules/SGP4/gmst.jl#L25-L36">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="SatelliteToolbox.SGP4.jd_to_gmst-Tuple{Number}" href="#SatelliteToolbox.SGP4.jd_to_gmst-Tuple{Number}"><code>SatelliteToolbox.SGP4.jd_to_gmst</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">jd_to_gmst(JD_UT1::Number)</code></pre><p>Compute the Greenwich Mean Sideral Time (GMST) [rad] for the Julian Day <code>JD_UT1</code> [UT1].</p><p><strong>Remarks</strong></p><p>Based on algorithm in [1, pp. 188].</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaSpace/SatelliteToolbox.jl/blob/c7a891ae8cbd18d844cb2ba648927c3c6dfa564f/src/submodules/SGP4/gmst.jl#L57-L67">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="SatelliteToolbox.SGP4.sgp4!-Union{Tuple{T}, Tuple{SGP4_Structure{T}, Number}} where T" href="#SatelliteToolbox.SGP4.sgp4!-Union{Tuple{T}, Tuple{SGP4_Structure{T}, Number}} where T"><code>SatelliteToolbox.SGP4.sgp4!</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">sgp4!(sgp4d::SGP4_Structure{T}, t::Number) where T</code></pre><p>Propagate the orbit defined in <code>sgp4d</code> (see <code>SGP4_Structure</code>) until the time <code>t</code> [min]. Notice that the values in <code>sgp4d</code> will be modified.</p><p><strong>Returns</strong></p><ul><li>The position vector represented in TEME frame at time <code>t</code> [km].</li><li>The velocity vector represented in TEME frame at time <code>t</code> [km/s].</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaSpace/SatelliteToolbox.jl/blob/c7a891ae8cbd18d844cb2ba648927c3c6dfa564f/src/submodules/SGP4/sgp4_model.jl#L311-L322">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="SatelliteToolbox.SGP4.sgp4-Tuple{Any, Vararg{Any, N} where N}" href="#SatelliteToolbox.SGP4.sgp4-Tuple{Any, Vararg{Any, N} where N}"><code>SatelliteToolbox.SGP4.sgp4</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">sgp4(Δt, args...)</code></pre><p>Function that initialize the SGP4 structure and propagate the orbit until the time Δt.</p><p><strong>Returns</strong></p><ul><li>The position vector [km].</li><li>The velocity vector [km/s].</li><li>The SGP4 structure (see <code>SGP4_Structure</code>).</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaSpace/SatelliteToolbox.jl/blob/c7a891ae8cbd18d844cb2ba648927c3c6dfa564f/src/submodules/SGP4/helpers.jl#L11-L22">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="SatelliteToolbox.SGP4.sgp4_init" href="#SatelliteToolbox.SGP4.sgp4_init"><code>SatelliteToolbox.SGP4.sgp4_init</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">sgp4_init(spg4_gc::SGP4_GravCte{T}, epoch::Number, n_0::Number, e_0::Number, i_0::Number, Ω_0::Number, ω_0::Number, M_0::Number, bstar::Number) where T
sgp4_init(tle::TLE, sgp4_gc::SGP4_GravCte = sgp4_gc_wgs84)</code></pre><p>Initialize the data structure of SGP4 algorithm.</p><p><strong>Args</strong></p><ul><li><code>spg4_gc</code>: SPG4 gravitational constants (see <code>SGP4_GravCte</code>).</li><li><code>epoch</code>: Epoch of the orbital elements [Julian Day].</li><li><code>n_0</code>: SGP type &quot;mean&quot; mean motion at epoch [rad/min].</li><li><code>e_0</code>: &quot;Mean&quot; eccentricity at epoch.</li><li><code>i_0</code>: &quot;Mean&quot; inclination at epoch [rad].</li><li><code>Ω_0</code>: &quot;Mean&quot; longitude of the ascending node at epoch [rad].</li><li><code>ω_0</code>: &quot;Mean&quot; argument of perigee at epoch [rad].</li><li><code>M_0</code>: &quot;Mean&quot; mean anomaly at epoch [rad].</li><li><code>bstar</code>: Drag parameter (B*).</li><li><code>tle</code>: TLE to initialize the SPG4 (see <code>TLE</code>).</li></ul><p><strong>Returns</strong></p><p>The structure <code>SGP4_Structure</code> with the initialized parameters.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaSpace/SatelliteToolbox.jl/blob/c7a891ae8cbd18d844cb2ba648927c3c6dfa564f/src/submodules/SGP4/sgp4_model.jl#L100-L123">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="SatelliteToolbox.SatelliteToolboxTLE.TLE" href="#SatelliteToolbox.SatelliteToolboxTLE.TLE"><code>SatelliteToolbox.SatelliteToolboxTLE.TLE</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia">TLE</code></pre><p>This structure contains the same elements of the TLE with the same units.</p><p><strong>Fields</strong></p><ul><li><code>name</code>: Name of the satellite.</li></ul><p><strong>First line</strong></p><ul><li><code>sat_num</code>: Satellite number.</li><li><code>classification</code>: Classification (&#39;U&#39;, &#39;C&#39;, or &#39;S&#39;).</li><li><code>int_designator</code>: International designator.</li><li><code>epoch_year</code>: Epoch year (two digits).</li><li><code>epoch_day</code>: Epoch day (day + fraction of the day).</li><li><code>epoch</code>: The epoch represented in Julian Day.</li><li><code>dn_o2</code>: 1st time derivative of mean motion / 2 [rev/day²].</li><li><code>ddn_o6</code>: 2nd time derivative of mean motion / 6 [rev/day³].</li><li><code>bstar</code>: B* drag term.</li><li><code>elem_set_number</code>: Element set number.</li><li><code>checksum_l1</code>: Checksum of the line 1 (modulo 10).</li></ul><p><strong>Second line</strong></p><ul><li><code>i</code>: Inclination [deg].</li><li><code>Ω</code>: Right ascension of the ascending node [deg].</li><li><code>e</code>: Eccentricity.</li><li><code>ω</code>: Argument of perigee [deg].</li><li><code>M</code>: Mean anomaly [deg].</li><li><code>n</code>: Mean motion [rev/day].</li><li><code>rev_num</code>: Revolution number at epoch [rev].</li><li><code>checksum_l2</code>: Checksum of the line 2 (modulo 10).</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaSpace/SatelliteToolbox.jl/blob/c7a891ae8cbd18d844cb2ba648927c3c6dfa564f/src/submodules/SatelliteToolboxTLE/types.jl#L11-L45">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="SatelliteToolbox.SatelliteToolboxTLE._show_tle" href="#SatelliteToolbox.SatelliteToolboxTLE._show_tle"><code>SatelliteToolbox.SatelliteToolboxTLE._show_tle</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">_show_tle(io::IO, tle::TLE, color::Bool = true)</code></pre><p>Show the TLE <code>tle</code> in the IO <code>io</code>.</p><p>If <code>color</code> is <code>true</code>, then the text will be printed using colors. If <code>color</code> is omitted, then it defaults to <code>true</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaSpace/SatelliteToolbox.jl/blob/c7a891ae8cbd18d844cb2ba648927c3c6dfa564f/src/submodules/SatelliteToolboxTLE/private.jl#L334-L342">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="SatelliteToolbox.SatelliteToolboxTLE.compute_checksum-Tuple{AbstractString}" href="#SatelliteToolbox.SatelliteToolboxTLE.compute_checksum-Tuple{AbstractString}"><code>SatelliteToolbox.SatelliteToolboxTLE.compute_checksum</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">compute_checksum(str::AbstractString)</code></pre><p>Compute the checksum of the line <code>str</code> modulo 10.</p><p>The algorithm is simple: add all the numbers in the line, ignoring letters, spaces, periods, and plus signs, but assigning +1 to the minus signs. The checksum is the remainder of the division by 10.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaSpace/SatelliteToolbox.jl/blob/c7a891ae8cbd18d844cb2ba648927c3c6dfa564f/src/submodules/SatelliteToolboxTLE/private.jl#L304-L313">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="SatelliteToolbox.SatelliteToolboxTLE.print_tle-Tuple{Any}" href="#SatelliteToolbox.SatelliteToolboxTLE.print_tle-Tuple{Any}"><code>SatelliteToolbox.SatelliteToolboxTLE.print_tle</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">print_tle(io::IO, tle; kwargs...)</code></pre><p>Print the TLE <code>tle</code> to the IO <code>io</code>. If <code>io</code> is omited, then <code>stdout</code> is used.</p><p>The keywords of this function are the same that can be used in <code>tle_to_str</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaSpace/SatelliteToolbox.jl/blob/c7a891ae8cbd18d844cb2ba648927c3c6dfa564f/src/submodules/SatelliteToolboxTLE/main.jl#L88-L95">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="SatelliteToolbox.SatelliteToolboxTLE.read_tle" href="#SatelliteToolbox.SatelliteToolboxTLE.read_tle"><code>SatelliteToolbox.SatelliteToolboxTLE.read_tle</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">read_tle(tle_filename::String, verify_checksum::Bool = true)</code></pre><p>Read the TLEs in the file <code>tle_filename</code> and return an array of <code>TLE</code> with the parsed TLEs.</p><p>If <code>verify_checksum</code> if <code>true</code>, then the checksum of both TLE lines will be verified. Otherwise, the checksum will not be checked. If <code>verify_checksum</code> is omitted, then it defaults to <code>true</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaSpace/SatelliteToolbox.jl/blob/c7a891ae8cbd18d844cb2ba648927c3c6dfa564f/src/submodules/SatelliteToolboxTLE/main.jl#L105-L115">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="SatelliteToolbox.SatelliteToolboxTLE.read_tle_from_string" href="#SatelliteToolbox.SatelliteToolboxTLE.read_tle_from_string"><code>SatelliteToolbox.SatelliteToolboxTLE.read_tle_from_string</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">read_tle_from_string(tles::String, verify_checksum::Bool = true)
read_tle_from_string(tle_l1::String, tle_l2::String, verify_checksum::Bool = false)</code></pre><p>Parse a set of TLEs in the string <code>tles</code> or one TLE with first line <code>tle_l1</code> and second line <code>tle_l2</code>. This function returns an array of <code>TLE</code> with the parsed TLEs.</p><p>If <code>verify_checksum</code> if <code>true</code>, then the checksum of both TLE lines will be verified. Otherwise, the checksum will not be checked. If <code>verify_checksum</code> is omitted, then it defaults to <code>true</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaSpace/SatelliteToolbox.jl/blob/c7a891ae8cbd18d844cb2ba648927c3c6dfa564f/src/submodules/SatelliteToolboxTLE/main.jl#L123-L135">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="SatelliteToolbox.SatelliteToolboxTLE.tle_to_str-Tuple{TLE}" href="#SatelliteToolbox.SatelliteToolboxTLE.tle_to_str-Tuple{TLE}"><code>SatelliteToolbox.SatelliteToolboxTLE.tle_to_str</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">tle_to_str(tle::TLE; recompute_checksum = true, bstar_exp_le = true)</code></pre><p>Convert the TLE <code>tle</code> to a string. If <code>recompute_checksum</code> is <code>true</code>, then the checksums in <code>tle</code> will be ignored and they will be computed considering the TLE data.</p><p>The keyword <code>bstar_exp_le</code> selects if the BSTAR exponent signal will be <code>+</code> or <code>-</code> when BSTAR is zero. This is required for the tests because it is not standardized in TLE generation. If it is <code>true</code>, then the exponent signal will be <code>-</code> when BSTAR is zero.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaSpace/SatelliteToolbox.jl/blob/c7a891ae8cbd18d844cb2ba648927c3c6dfa564f/src/submodules/SatelliteToolboxTLE/main.jl#L150-L162">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="SatelliteToolbox.SatelliteToolboxTLE.@parse_value-Tuple{Any, Any, Any}" href="#SatelliteToolbox.SatelliteToolboxTLE.@parse_value-Tuple{Any, Any, Any}"><code>SatelliteToolbox.SatelliteToolboxTLE.@parse_value</code></a> — <span class="docstring-category">Macro</span></header><section><div><pre><code class="language-julia">@parse_value(T, str, line_num)</code></pre><p>Parse the string <code>str</code> using the type <code>T</code>. If it is not succeeded, then throw an error indicating the line <code>line_num</code> with the problem.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaSpace/SatelliteToolbox.jl/blob/c7a891ae8cbd18d844cb2ba648927c3c6dfa564f/src/submodules/SatelliteToolboxTLE/private.jl#L13-L19">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="SatelliteToolbox.SatelliteToolboxTLE.@tle_str-Tuple{Any}" href="#SatelliteToolbox.SatelliteToolboxTLE.@tle_str-Tuple{Any}"><code>SatelliteToolbox.SatelliteToolboxTLE.@tle_str</code></a> — <span class="docstring-category">Macro</span></header><section><div><pre><code class="language-julia">@tle_str(str)</code></pre><p>Parse a set of TLEs in the string <code>str</code> and return as an array of <code>TLE</code>. This version verifies the checksum of the TLE. If the checksum verification is not desired, see <code>@tlenc_str</code>.</p><p><strong>Example</strong></p><pre><code class="language-julia-repl">julia&gt; tles = tle&quot;&quot;&quot;
       CBERS 4
       1 40336U 14079A   18166.15595376 -.00000014  00000-0  10174-4 0  9993
       2 40336  98.4141 237.7928 0001694  75.7582 284.3804 14.35485112184485
       SCD 1
       1 22490U 93009B   18165.62596833  .00000225  00000-0  11410-4 0  9991
       2 22490  24.9690 231.7852 0042844 200.7311 292.7198 14.44524498338066
       SCD 2
       1 25504U 98060A   18165.15074951  .00000201  00000-0  55356-5 0  9994
       2 25504  24.9961  80.1303 0017060 224.4822 286.6438 14.44043397 37312
       &quot;&quot;&quot;</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaSpace/SatelliteToolbox.jl/blob/c7a891ae8cbd18d844cb2ba648927c3c6dfa564f/src/submodules/SatelliteToolboxTLE/main.jl#L16-L38">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="SatelliteToolbox.SatelliteToolboxTLE.@tlenc_str-Tuple{Any}" href="#SatelliteToolbox.SatelliteToolboxTLE.@tlenc_str-Tuple{Any}"><code>SatelliteToolbox.SatelliteToolboxTLE.@tlenc_str</code></a> — <span class="docstring-category">Macro</span></header><section><div><pre><code class="language-julia">@tlenc_str(str)</code></pre><p>Parse a set of TLEs in the string <code>str</code> and return as an array of <code>TLE</code>. This version <strong>does not</strong> verify the checksum of the TLE. If the checksum verification is required, see <code>@tle_str</code>.</p><p><strong>Example</strong></p><pre><code class="language-julia-repl">julia&gt; tles = tlenc&quot;&quot;&quot;
       CBERS 4
       1 40336U 14079A   18166.15595376 -.00000014  00000-0  10174-4 0  9993
       2 40336  98.4141 237.7928 0001694  75.7582 284.3804 14.35485112184485
       SCD 1
       1 22490U 93009B   18165.62596833  .00000225  00000-0  11410-4 0  9991
       2 22490  24.9690 231.7852 0042844 200.7311 292.7198 14.44524498338066
       SCD 2
       1 25504U 98060A   18165.15074951  .00000201  00000-0  55356-5 0  9994
       2 25504  24.9961  80.1303 0017060 224.4822 286.6438 14.44043397 37312
       &quot;&quot;&quot;</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaSpace/SatelliteToolbox.jl/blob/c7a891ae8cbd18d844cb2ba648927c3c6dfa564f/src/submodules/SatelliteToolboxTLE/main.jl#L43-L65">source</a></section></article><section class="footnotes is-size-7"><ul><li class="footnote" id="footnote-1"><a class="tag is-link" href="#citeref-1">1</a>TEME is an <em>of date</em> frame.</li></ul></section></article><nav class="docs-footer"><a class="docs-footer-prevpage" href="../../man/transformations/geodetic_geocentric/">« Geodetic and Geocentric</a><div class="flexbox-break"></div><p class="footer-message">Powered by <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> and the <a href="https://julialang.org/">Julia Programming Language</a>.</p></nav></div><div class="modal" id="documenter-settings"><div class="modal-background"></div><div class="modal-card"><header class="modal-card-head"><p class="modal-card-title">Settings</p><button class="delete"></button></header><section class="modal-card-body"><p><label class="label">Theme</label><div class="select"><select id="documenter-themepicker"><option value="documenter-light">documenter-light</option><option value="documenter-dark">documenter-dark</option></select></div></p><hr/><p>This document was generated with <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> on <span class="colophon-date" title="Sunday 9 May 2021 23:46">Sunday 9 May 2021</span>. Using Julia version 1.6.1.</p></section><footer class="modal-card-foot"></footer></div></div></div></body></html>
