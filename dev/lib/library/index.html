<!DOCTYPE html>
<html lang="en"><head><meta charset="UTF-8"/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><title>Library · Satellite Toolbox</title><link rel="canonical" href="https://juliaspace.github.io/SatelliteToolbox.jl/stable/lib/library/index.html"/><link href="https://fonts.googleapis.com/css?family=Lato|Roboto+Mono" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.11.2/css/fontawesome.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.11.2/css/solid.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.11.2/css/brands.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/KaTeX/0.11.1/katex.min.css" rel="stylesheet" type="text/css"/><script>documenterBaseURL="../.."</script><script src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.3.6/require.min.js" data-main="../../assets/documenter.js"></script><script src="../../siteinfo.js"></script><script src="../../../versions.js"></script><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../../assets/themes/documenter-dark.css" data-theme-name="documenter-dark"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../../assets/themes/documenter-light.css" data-theme-name="documenter-light" data-theme-primary/><script src="../../assets/themeswap.js"></script></head><body><div id="documenter"><nav class="docs-sidebar"><a class="docs-logo" href="../../"><img src="../../assets/logo.png" alt="Satellite Toolbox logo"/></a><div class="docs-package-name"><span class="docs-autofit">Satellite Toolbox</span></div><form class="docs-search" action="../../search/"><input class="docs-search-query" id="documenter-search-query" name="q" type="text" placeholder="Search docs"/></form><ul class="docs-menu"><li><a class="tocitem" href="../../">Home</a></li><li><span class="tocitem">Earth</span><ul><li><a class="tocitem" href="../../man/earth/atmospheric_models/">Earth atmospheric models</a></li><li><a class="tocitem" href="../../man/earth/geomagnetic_field_models/">Earth geomagnetic field models</a></li><li><a class="tocitem" href="../../man/earth/space_indices/">Space indices</a></li></ul></li><li><span class="tocitem">Orbit</span><ul><li><a class="tocitem" href="../../man/orbit/anomalies/">Anomalies</a></li><li><a class="tocitem" href="../../man/orbit/general/">General analysis</a></li><li><a class="tocitem" href="../../man/orbit/propagators/">Orbit propagators</a></li><li><a class="tocitem" href="../../man/orbit/tle/">TLE</a></li></ul></li><li><span class="tocitem">Transformations</span><ul><li><a class="tocitem" href="../../man/transformations/ecef_eci/">ECEF and ECI</a></li><li><a class="tocitem" href="../../man/transformations/geodetic_geocentric/">Geodetic and Geocentric</a></li></ul></li><li class="is-active"><a class="tocitem" href>Library</a></li></ul><div class="docs-version-selector field has-addons"><div class="control"><span class="docs-label button is-static is-size-7">Version</span></div><div class="docs-selector control is-expanded"><div class="select is-fullwidth is-size-7"><select id="documenter-version-selector"></select></div></div></div></nav><div class="docs-main"><header class="docs-navbar"><nav class="breadcrumb"><ul class="is-hidden-mobile"><li class="is-active"><a href>Library</a></li></ul><ul class="is-hidden-tablet"><li class="is-active"><a href>Library</a></li></ul></nav><div class="docs-right"><a class="docs-edit-link" href="https://github.com/JuliaSpace/SatelliteToolbox.jl/blob/master/docs/src/lib/library.md" title="Edit on GitHub"><span class="docs-icon fab"></span><span class="docs-label is-hidden-touch">Edit on GitHub</span></a><a class="docs-settings-button fas fa-cog" id="documenter-settings-button" href="#" title="Settings"></a><a class="docs-sidebar-button fa fa-bars is-hidden-desktop" id="documenter-sidebar-button" href="#"></a></div></header><article class="content" id="documenter-page"><h1 id="Library-1"><a class="docs-heading-anchor" href="#Library-1">Library</a><a class="docs-heading-anchor-permalink" href="#Library-1" title="Permalink"></a></h1><p>Documentation for <code>SatelliteToolbox.jl</code>.</p><article class="docstring"><header><a class="docstring-binding" id="SatelliteToolbox.T_ECEFs" href="#SatelliteToolbox.T_ECEFs"><code>SatelliteToolbox.T_ECEFs</code></a> — <span class="docstring-category">Constant</span></header><section><div><p>Union of all Earth-Centered Earth-Fixed (ECEF) frames supported by the IAU-76/FK5 theory.</p></div></section></article><article class="docstring"><header><a class="docstring-binding" id="SatelliteToolbox.T_ECEFs_IAU_2006" href="#SatelliteToolbox.T_ECEFs_IAU_2006"><code>SatelliteToolbox.T_ECEFs_IAU_2006</code></a> — <span class="docstring-category">Constant</span></header><section><div><p>Union of all Earth-Centered Earth-Fixed (ECEF) frames supported by IAU-2006/2010 theory.</p></div></section></article><article class="docstring"><header><a class="docstring-binding" id="SatelliteToolbox.T_ECIs" href="#SatelliteToolbox.T_ECIs"><code>SatelliteToolbox.T_ECIs</code></a> — <span class="docstring-category">Constant</span></header><section><div><p>Union of all Earth-Centered Inertial (ECI) frames supported by the IAU-76/FK5 theory.</p></div></section></article><article class="docstring"><header><a class="docstring-binding" id="SatelliteToolbox.T_ECIs_IAU_2006" href="#SatelliteToolbox.T_ECIs_IAU_2006"><code>SatelliteToolbox.T_ECIs_IAU_2006</code></a> — <span class="docstring-category">Constant</span></header><section><div><p>Union of all Earth-Centered Inertial (ECI) frames supported by IAU-2006/2010 theory.</p></div></section></article><article class="docstring"><header><a class="docstring-binding" id="SatelliteToolbox.T_ECIs_of_date" href="#SatelliteToolbox.T_ECIs_of_date"><code>SatelliteToolbox.T_ECIs_of_date</code></a> — <span class="docstring-category">Constant</span></header><section><div><p>Union of all <em>of date</em> Earth-Centered Inertial (ECI) frames supported by the IAU-76/FK5 theory.</p></div></section></article><article class="docstring"><header><a class="docstring-binding" id="SatelliteToolbox.T_ROT" href="#SatelliteToolbox.T_ROT"><code>SatelliteToolbox.T_ROT</code></a> — <span class="docstring-category">Constant</span></header><section><div><p>Union of all supported rotation descriptions.</p></div></section></article><article class="docstring"><header><a class="docstring-binding" id="SatelliteToolbox.EOPData_IAU1980" href="#SatelliteToolbox.EOPData_IAU1980"><code>SatelliteToolbox.EOPData_IAU1980</code></a> — <span class="docstring-category">Type</span></header><section><div><p>EOP Data for IAU 1980.</p><p><strong>Fields</strong></p><ul><li><code>x, y</code>: Polar motion with respect to the crust [arcsec].</li><li><code>UT1_UTC</code>: Irregularities of the rotation angle [s].</li><li><code>LOD</code>: Length of day offset [s].</li><li><code>dPsi, dEps</code>: Celestial pole offsets referred to the model IAU1980 [arcsec].</li><li><code>*_err</code>: Errors in the components [same unit as the component].</li></ul><p><strong>Remarks</strong></p><p>Each field will be an <code>AbstractInterpolation</code> indexed by the Julian Day. Hence, if one want to obtain, for example, the X component of the polar motion with respect to the crust at 19 June 2018, the following can be used:</p><pre><code class="language-none">x[DatestoJD(2018,19,06,0,0,0)]</code></pre></div></section></article><article class="docstring"><header><a class="docstring-binding" id="SatelliteToolbox.EOPData_IAU2000A" href="#SatelliteToolbox.EOPData_IAU2000A"><code>SatelliteToolbox.EOPData_IAU2000A</code></a> — <span class="docstring-category">Type</span></header><section><div><p>EOP Data for IAU 2000A.</p><p><strong>Fields</strong></p><ul><li><code>x, y</code>: Polar motion with respect to the crust [arcsec].</li><li><code>UT1_UTC</code>: Irregularities of the rotation angle [s].</li><li><code>LOD</code>: Length of day offset [s].</li><li><code>dX, dY</code>: Celestial pole offsets referred to the model IAU2000A [arcsec].</li><li><code>*_err</code>: Errors in the components [same unit as the component].</li></ul><p><strong>Remarks</strong></p><p>Each field will be an <code>AbstractInterpolation</code> indexed by the Julian Day. Hence, if one want to obtain, for example, the X component of the polar motion with respect to the crust at 19 June 2018, the following can be used:</p><pre><code class="language-none">x[DatestoJD(2018,19,06,0,0,0)]</code></pre></div></section></article><article class="docstring"><header><a class="docstring-binding" id="SatelliteToolbox.GravityModel_Coefs" href="#SatelliteToolbox.GravityModel_Coefs"><code>SatelliteToolbox.GravityModel_Coefs</code></a> — <span class="docstring-category">Type</span></header><section><div><p>Structure to store the information about a gravity model.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaLang/julia/blob/2d5741174ce3e6a394010d2e470e4269ca54607f/base/#L0-L3">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="SatelliteToolbox.ICGEM" href="#SatelliteToolbox.ICGEM"><code>SatelliteToolbox.ICGEM</code></a> — <span class="docstring-category">Type</span></header><section><div><p>Structure to store the information contained in ICGEM files.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaLang/julia/blob/2d5741174ce3e6a394010d2e470e4269ca54607f/base/#L0-L3">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="SatelliteToolbox.J2_GravCte" href="#SatelliteToolbox.J2_GravCte"><code>SatelliteToolbox.J2_GravCte</code></a> — <span class="docstring-category">Type</span></header><section><div><p>Gravitational constants for J2 orbit propagator.</p><p><strong>Fields</strong></p><ul><li><code>R0</code>: Earth equatorial radius [m].</li><li><code>μm</code>: √GM [er/s]^(3/2).</li><li><code>J2</code>: The second gravitational zonal harmonic of the Earth.</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaLang/julia/blob/2d5741174ce3e6a394010d2e470e4269ca54607f/base/#L0-L9">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="SatelliteToolbox.J2_Structure" href="#SatelliteToolbox.J2_Structure"><code>SatelliteToolbox.J2_Structure</code></a> — <span class="docstring-category">Type</span></header><section><div><p>Low level J2 orbit propagator structure.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaLang/julia/blob/2d5741174ce3e6a394010d2e470e4269ca54607f/base/#L0-L3">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="SatelliteToolbox.J4_GravCte" href="#SatelliteToolbox.J4_GravCte"><code>SatelliteToolbox.J4_GravCte</code></a> — <span class="docstring-category">Type</span></header><section><div><p>Gravitational constants for J4 orbit propagator.</p><p><strong>Fields</strong></p><ul><li><code>R0</code>: Earth equatorial radius [m].</li><li><code>μm</code>: √GM [er/s]^(3/2).</li><li><code>J2</code>: The second gravitational zonal harmonic of the Earth.</li><li><code>J4</code>: The fourth gravitational zonal harmonic of the Earth.</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaLang/julia/blob/2d5741174ce3e6a394010d2e470e4269ca54607f/base/#L0-L10">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="SatelliteToolbox.J4_Structure" href="#SatelliteToolbox.J4_Structure"><code>SatelliteToolbox.J4_Structure</code></a> — <span class="docstring-category">Type</span></header><section><div><p>Low level J4 orbit propagator structure.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaLang/julia/blob/2d5741174ce3e6a394010d2e470e4269ca54607f/base/#L0-L3">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="SatelliteToolbox.JB2008_Output" href="#SatelliteToolbox.JB2008_Output"><code>SatelliteToolbox.JB2008_Output</code></a> — <span class="docstring-category">Type</span></header><section><div><p>Output structure of the Jacchia-Bowman 2008.</p><p><strong>Fields</strong></p><ul><li><code>nN2</code>: Number density of N₂ [1/m³].</li><li><code>nO2</code>: Number density of O₂ [1/m³].</li><li><code>nO</code>: Number density of O [1/m³].</li><li><code>nAr</code>: Number density of Ar [1/m³].</li><li><code>nHe</code>: Number density of He [1/m³].</li><li><code>nH</code>: Number density of H [1/m³].</li><li><code>rho</code>: Total density [kg/m³].</li><li><code>T_exo</code>: Exospheric temperature [K].</li><li><code>Tz</code>: Temperature at the selected altitude [K].</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaLang/julia/blob/2d5741174ce3e6a394010d2e470e4269ca54607f/base/#L0-L15">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="SatelliteToolbox.JR1971_Output" href="#SatelliteToolbox.JR1971_Output"><code>SatelliteToolbox.JR1971_Output</code></a> — <span class="docstring-category">Type</span></header><section><div><p>Output structure of the Jacchia-Roberts 1971 model.</p><p><strong>Fields</strong></p><ul><li><code>nN2</code>: Number density of N₂ [1/m³].</li><li><code>nO2</code>: Number density of O₂ [1/m³].</li><li><code>nO</code>: Number density of O [1/m³].</li><li><code>nAr</code>: Number density of Ar [1/m³].</li><li><code>nHe</code>: Number density of He [1/m³].</li><li><code>nH</code>: Number density of H [1/m³].</li><li><code>rho</code>: Total density [kg/m³].</li><li><code>T_exo</code>: Exospheric temperature [K].</li><li><code>Tz</code>: Temperature at the selected altitude [K].</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaLang/julia/blob/2d5741174ce3e6a394010d2e470e4269ca54607f/base/#L0-L15">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="SatelliteToolbox.NRLMSISE00_Flags" href="#SatelliteToolbox.NRLMSISE00_Flags"><code>SatelliteToolbox.NRLMSISE00_Flags</code></a> — <span class="docstring-category">Type</span></header><section><div><p>Flags to configure NRLMSISE-00.</p><p><strong>Fields</strong></p><ul><li><code>output_m_kg</code></li><li><code>F107_Mean</code></li><li><code>time_independent</code></li><li><code>sym_annual</code></li><li><code>sym_semiannual</code></li><li><code>asym_annual</code></li><li><code>asyn_semiannual</code></li><li><code>diurnal</code></li><li><code>semidiurnal</code></li><li><code>daily_ap</code></li><li><code>all_ut_long_effects</code></li><li><code>longitudinal</code></li><li><code>ut_mixed_ut_long</code></li><li><code>mixed_ap_ut_long</code></li><li><code>terdiurnal</code></li><li><code>departures_from_eq</code></li><li><code>all_tinf_var</code></li><li><code>all_tlb_var</code></li><li><code>all_tn1_var</code></li><li><code>all_s_var</code></li><li><code>all_tn2_var</code></li><li><code>all_nlb_var</code></li><li><code>all_tn3_var</code></li><li><code>turbo_scale_height</code></li><li><code>use_ap_array</code></li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaLang/julia/blob/2d5741174ce3e6a394010d2e470e4269ca54607f/base/#L0-L31">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="SatelliteToolbox.NRLMSISE00_Output" href="#SatelliteToolbox.NRLMSISE00_Output"><code>SatelliteToolbox.NRLMSISE00_Output</code></a> — <span class="docstring-category">Type</span></header><section><div><p>Output structure for NRLMSISE00 model.</p><p><strong>Fields</strong></p><ul><li><code>den_N</code>: Nitrogen number density [U].</li><li><code>den_N2</code>: N₂ number density [U].</li><li><code>den_O</code>: Oxygen number density [U].</li><li><code>den_aO</code>: Anomalous Oxygen number density [U].</li><li><code>den_O2</code>: O₂ number density [U].</li><li><code>den_H</code>: Hydrogen number density [U].</li><li><code>den_He</code>: Helium number density [U].</li><li><code>den_Ar</code>: Argon number density [U].</li><li><code>den_Total</code>: Total mass density [T/U] (this value has different meanings for              routines <code>gtd7</code> and <code>gtd7d</code>).</li><li><code>T_exo</code>: Exospheric temperature [K].</li><li><code>T_alt</code>: Temperature at the selected altitude [K].</li><li><code>flags</code>: Flags used to compute NRLMSISE-00 model.</li></ul><p>Notice that:</p><ul><li>If <code>flags.output_m_kg</code> is <code>false</code>, then [U] is [cm⁻³] and [T] is [g/cm⁻³].</li><li>If <code>flags.output_m_kg</code> is <code>true</code>, then [U] is [m⁻³] and [T] is [kg/m⁻³].</li></ul><p><strong>Remarks</strong></p><p>Anomalous oxygen is defined as hot atomic oxygen or ionized oxygen that can become appreciable at high altitudes (<code>&gt; 500 km</code>) for some ranges of inputs, thereby affection drag on satellites and debris. We group these species under the term <strong>Anomalous Oxygen</strong>, since their individual variations are not presently separable with the drag data used to define this model component.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaLang/julia/blob/2d5741174ce3e6a394010d2e470e4269ca54607f/base/#L0-L32">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="SatelliteToolbox.NRLMSISE00_Structure" href="#SatelliteToolbox.NRLMSISE00_Structure"><code>SatelliteToolbox.NRLMSISE00_Structure</code></a> — <span class="docstring-category">Type</span></header><section><div><p>Structure with the configuration parameters for NRLMSISE-00 model. It can be created using the function <code>conf_nrlmsise00</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaLang/julia/blob/2d5741174ce3e6a394010d2e470e4269ca54607f/base/#L0-L4">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="SatelliteToolbox.Orbit" href="#SatelliteToolbox.Orbit"><code>SatelliteToolbox.Orbit</code></a> — <span class="docstring-category">Type</span></header><section><div><p>This structure defines the orbit in terms of the Keplerian elements.</p><p><strong>Fields</strong></p><ul><li><code>t</code>: Orbit epoch.</li><li><code>a</code>: Semi-major axis [m].</li><li><code>e</code>: Eccentricity.</li><li><code>i</code>: Inclination [rad].</li><li><code>Ω</code>: Right ascension of the ascending node [rad].</li><li><code>ω</code>: Argument of perigee [rad].</li><li><code>f</code>: True anomaly [rad].</li></ul></div></section></article><article class="docstring"><header><a class="docstring-binding" id="SatelliteToolbox.Orbit-NTuple{6,Number}" href="#SatelliteToolbox.Orbit-NTuple{6,Number}"><code>SatelliteToolbox.Orbit</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">function Orbit(a::Number, e::Number, i::Number, Ω::Number, ω::Number, f::Number)</code></pre><p>Create an orbit with semi-major axis <code>a</code> [m], eccentricity <code>e</code>, inclination <code>i</code> [rad], right ascension of the ascending node <code>Ω</code> [rad], argument of perigee <code>ω</code> [rad], and true anomaly <code>f</code> [rad].</p><p><strong>Returns</strong></p><p>An object of type <code>Orbit</code> with the specified orbit. The orbit epoch is defined as 0.0.</p></div></section></article><article class="docstring"><header><a class="docstring-binding" id="SatelliteToolbox.OrbitPropagator" href="#SatelliteToolbox.OrbitPropagator"><code>SatelliteToolbox.OrbitPropagator</code></a> — <span class="docstring-category">Type</span></header><section><div><p>Abstract type of the orbit propagator. Every propagator structure must be a subtype of this type and must implement the following API functions:</p><pre><code class="language-none">function propagate!(orbp, t::Number)
function propagate!(orbp, t::AbstractVector)
function propagate_to_epoch!(orbp, JD::Number)
function propagate_to_epoch!(orbp, JD::AbstractVector)
function step!(orbp, Δt::Number)</code></pre></div></section></article><article class="docstring"><header><a class="docstring-binding" id="SatelliteToolbox.OrbitPropagatorJ2" href="#SatelliteToolbox.OrbitPropagatorJ2"><code>SatelliteToolbox.OrbitPropagatorJ2</code></a> — <span class="docstring-category">Type</span></header><section><div><p>Structure that holds the information related to the J2 orbit propagator.</p><p><strong>Fields</strong></p><ul><li><code>orb</code>: Mean orbital elements (see <code>Orbit</code>).</li><li><code>j2d</code>: Structure that stores the J2 orbit propagator data (see        <code>J2_Structure</code>).</li></ul></div></section></article><article class="docstring"><header><a class="docstring-binding" id="SatelliteToolbox.OrbitPropagatorJ4" href="#SatelliteToolbox.OrbitPropagatorJ4"><code>SatelliteToolbox.OrbitPropagatorJ4</code></a> — <span class="docstring-category">Type</span></header><section><div><p>Structure that holds the information related to the J4 orbit propagator.</p><p><strong>Fields</strong></p><ul><li><code>orb</code>: Mean orbital elements (see <code>Orbit</code>).</li><li><code>j4d</code>: Structure that stores the J4 orbit propagator data (see        <code>J4_Structure</code>).</li></ul></div></section></article><article class="docstring"><header><a class="docstring-binding" id="SatelliteToolbox.OrbitPropagatorSGP4" href="#SatelliteToolbox.OrbitPropagatorSGP4"><code>SatelliteToolbox.OrbitPropagatorSGP4</code></a> — <span class="docstring-category">Type</span></header><section><div><p>Structure that holds the information related to the SGP4 propagator.</p><p><strong>Fields</strong></p><ul><li><code>orb</code>: Mean orbital elements (see <code>Orbit</code>).</li><li><code>sgp4_gc</code>: Gravitational contents of the SGP4 algorithm (see <code>SGP4_GravCte</code>).</li><li><code>sgp4d</code>: Structure that stores the SGP4 data (see <code>SGP4_Structure</code>).</li></ul></div></section></article><article class="docstring"><header><a class="docstring-binding" id="SatelliteToolbox.OrbitPropagatorTwoBody" href="#SatelliteToolbox.OrbitPropagatorTwoBody"><code>SatelliteToolbox.OrbitPropagatorTwoBody</code></a> — <span class="docstring-category">Type</span></header><section><div><p>Structure that holds the information related to the Two Body orbit propagator.</p><p><strong>Fields</strong></p><ul><li><code>orb</code>: Mean orbital elements (see <code>Orbit</code>).</li><li><code>tbd</code>: Structure that stores the Two Body orbit propagator data (see       <code>TwoBody_Structure</code>).</li></ul></div></section></article><article class="docstring"><header><a class="docstring-binding" id="SatelliteToolbox.TwoBody_Structure" href="#SatelliteToolbox.TwoBody_Structure"><code>SatelliteToolbox.TwoBody_Structure</code></a> — <span class="docstring-category">Type</span></header><section><div><p>Low level Two Body orbit propagator structure.</p></div></section></article><article class="docstring"><header><a class="docstring-binding" id="SatelliteToolbox.DatetoJD-Tuple{Dates.DateTime}" href="#SatelliteToolbox.DatetoJD-Tuple{Dates.DateTime}"><code>SatelliteToolbox.DatetoJD</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">function DatetoJD(dateTime::DateTime)</code></pre><p>Convert the date and time <code>dateTime</code> to Julian Day.</p></div></section></article><article class="docstring"><header><a class="docstring-binding" id="SatelliteToolbox.DatetoJD-Tuple{Dates.Date}" href="#SatelliteToolbox.DatetoJD-Tuple{Dates.Date}"><code>SatelliteToolbox.DatetoJD</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">function DatetoJD(date::Date)</code></pre><p>Convert the date <code>date</code> to Julian Day.</p></div></section></article><article class="docstring"><header><a class="docstring-binding" id="SatelliteToolbox.DatetoJD-Tuple{Int64,Int64,Int64,Int64,Int64,Number}" href="#SatelliteToolbox.DatetoJD-Tuple{Int64,Int64,Int64,Int64,Int64,Number}"><code>SatelliteToolbox.DatetoJD</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">function DatetoJD(Y::Int, M::Int, D::Int, h::Int, m::Int, s::Number)</code></pre><p>Convert a date represented using the Gregorian Calendar (Year = <code>y</code>, Month = <code>M</code> (1-12), Day = <code>D</code>, Hour = <code>h</code> (0-24), minute = <code>m</code>, and second = <code>s</code>) to Julian Day.</p><p><strong>Remarks</strong></p><p>The algorithm was obtained from [2] (Accessed on 2018-04-11).</p></div></section></article><article class="docstring"><header><a class="docstring-binding" id="SatelliteToolbox.ECEFtoGeodetic-Tuple{AbstractArray{T,1} where T}" href="#SatelliteToolbox.ECEFtoGeodetic-Tuple{AbstractArray{T,1} where T}"><code>SatelliteToolbox.ECEFtoGeodetic</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">function ECEFtoGeodetic(r_e::AbstractVector)</code></pre><p>Convert the vector <code>r_e</code> [m] represented in the Earth-Centered, Earth-Fixed (ECEF) reference frame into Geodetic coordinates (WGS-84).</p><p><strong>Returns</strong></p><ul><li>Latitude [rad].</li><li>Longitude [rad].</li><li>Altitude [m].</li></ul><p><strong>Remarks</strong></p><p>Based on algorithm in [3].</p></div></section></article><article class="docstring"><header><a class="docstring-binding" id="SatelliteToolbox.E_to_M-Tuple{Number,Number}" href="#SatelliteToolbox.E_to_M-Tuple{Number,Number}"><code>SatelliteToolbox.E_to_M</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">function E_to_M(e::Number, E::Number)</code></pre><p>Compute the mean anomaly (0,2π) [rad] given the eccentricity <code>e</code> and the eccentric anomaly <code>E</code> [rad].</p></div></section></article><article class="docstring"><header><a class="docstring-binding" id="SatelliteToolbox.E_to_f-Tuple{Number,Number}" href="#SatelliteToolbox.E_to_f-Tuple{Number,Number}"><code>SatelliteToolbox.E_to_f</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">function E_to_f(e::Number, E::Number)</code></pre><p>Compute the true anomaly (0,2π) [rad] given the eccentricity <code>e</code> and the eccentric anomaly <code>E</code> [rad].</p></div></section></article><article class="docstring"><header><a class="docstring-binding" id="SatelliteToolbox.GeodetictoECEF-Tuple{Number,Number,Number}" href="#SatelliteToolbox.GeodetictoECEF-Tuple{Number,Number,Number}"><code>SatelliteToolbox.GeodetictoECEF</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">function GeodetictoECEF(lat::Number, lon::Number, h::Number)</code></pre><p>Convert the latitude <code>lat</code> [rad], longitude <code>lon</code> [rad], and altitude <code>h</code> [m] (WGS-84) into a vector represented on the Earth-Centered, Earth-Fixed (ECEF) reference frame.</p><p><strong>Remarks</strong></p><p>Based on algorithm in [3].</p></div></section></article><article class="docstring"><header><a class="docstring-binding" id="SatelliteToolbox.GeodetictoGeocentric-Tuple{Number,Number}" href="#SatelliteToolbox.GeodetictoGeocentric-Tuple{Number,Number}"><code>SatelliteToolbox.GeodetictoGeocentric</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">function GeodetictoGeocentric(ϕ_gd::Number, h::Number)</code></pre><p>Compute the geocentric latitude and radius from the geodetic latitude <code>ϕ_gd</code> (-π/2,π/2) [rad] and height above the reference ellipsoid <code>h</code> [m] (WGS-84). Notice that the longitude is the same in both geocentric and geodetic coordinates.</p><p><strong>Returns</strong></p><ul><li>Geocentric latitude [rad].</li><li>Radius from the center of the Earth [m].</li></ul><p><strong>Remarks</strong></p><p>Based on algorithm in [4, p. 3].</p></div></section></article><article class="docstring"><header><a class="docstring-binding" id="SatelliteToolbox.J2000toGMST-Tuple{Number}" href="#SatelliteToolbox.J2000toGMST-Tuple{Number}"><code>SatelliteToolbox.J2000toGMST</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">function J2000toGMST(J2000_UT1::Number)</code></pre><p>Compute the Greenwich Mean Sideral Time (GMST) [rad] given the instant <code>J2000_UT1</code> in J2000.0 reference [UT1].</p><p><strong>Remarks</strong></p><p>Based on algorithm in <a href="http://www.navipedia.net/index.php/CEP_to_ITRF">2</a>, accessed at 2015-12-01.</p></div></section></article><article class="docstring"><header><a class="docstring-binding" id="SatelliteToolbox.JD_TTtoUTC-Tuple{Number,Number}" href="#SatelliteToolbox.JD_TTtoUTC-Tuple{Number,Number}"><code>SatelliteToolbox.JD_TTtoUTC</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">function JD_TTtoUTC(JD_TT::Number, ΔAT::Number = 37)</code></pre><p>Convert the Julian Day in TT <code>JD_TT</code> (Terrestrial Time) to the Julian Day in UTC (Terrestrial Time) using the accumulated difference <code>ΔAT</code> between UTC and the International Atomic Time (TAI). If no value is provided, then the leap seconds will be obtained from the table <code>ΔAT_Data</code>. <strong>Notice that, in this case, if a date previous to 1973 is provided, then a fixed value of 10 will be used, leading to wrong computations.</strong></p></div></section></article><article class="docstring"><header><a class="docstring-binding" id="SatelliteToolbox.JD_UT1toUTC-Tuple{Number,Number}" href="#SatelliteToolbox.JD_UT1toUTC-Tuple{Number,Number}"><code>SatelliteToolbox.JD_UT1toUTC</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">function JD_UT1toUTC(JD_UT1::Number, ΔUT1::Number)</code></pre><p>Convert the Julian Day in UT1 <code>JD_UT1</code> to the Julian Day in UTC using the accumulated difference <code>ΔUT1</code>, which is provided by IERS EOP Data.</p></div></section></article><article class="docstring"><header><a class="docstring-binding" id="SatelliteToolbox.JD_UT1toUTC-Tuple{Number,Union{EOPData_IAU1980, EOPData_IAU2000A}}" href="#SatelliteToolbox.JD_UT1toUTC-Tuple{Number,Union{EOPData_IAU1980, EOPData_IAU2000A}}"><code>SatelliteToolbox.JD_UT1toUTC</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">function JD_UTCtoUT1(JD_UTC::Number, eop::Union{EOPData_IAU1980,EOPData_IAU2000A})</code></pre><p>Convert the Julian Day in UT1 <code>JD_UT1</code> to the Julian Day in UTC using the accumulated difference given by the EOP Data <code>eop</code> (see <code>get_iers_eop</code>). Notice that the accumulated difference will be interpolated.</p></div></section></article><article class="docstring"><header><a class="docstring-binding" id="SatelliteToolbox.JD_UTCtoTT-Tuple{Number,Number}" href="#SatelliteToolbox.JD_UTCtoTT-Tuple{Number,Number}"><code>SatelliteToolbox.JD_UTCtoTT</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">function JD_UTCtoTT(JD_UTC::Number [, ΔAT::Number])</code></pre><p>Convert the Julian Day in UTC <code>JD_UTC</code> to the Julian Day in TT (Terrestrial Time) using the accumulated difference <code>ΔAT</code> between UTC and the International Atomic Time (TAI). If no value is provided, then the leap seconds will be obtained from the table <code>ΔAT_Data</code>. <strong>Notice that, in this case, if a date previous to 1973 is provided, then a fixed value of 10 will be used, leading to wrong computations.</strong></p></div></section></article><article class="docstring"><header><a class="docstring-binding" id="SatelliteToolbox.JD_UTCtoUT1-Tuple{Number,Number}" href="#SatelliteToolbox.JD_UTCtoUT1-Tuple{Number,Number}"><code>SatelliteToolbox.JD_UTCtoUT1</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">function JD_UTCtoUT1(JD_UTC::Number, ΔUT1::Number)</code></pre><p>Convert the Julian Day in UTC <code>JD_UTC</code> to the Julian Day in UT1 using the accumulated difference <code>ΔUT1</code>, which is provided by IERS EOP Data.</p></div></section></article><article class="docstring"><header><a class="docstring-binding" id="SatelliteToolbox.JD_UTCtoUT1-Tuple{Number,Union{EOPData_IAU1980, EOPData_IAU2000A}}" href="#SatelliteToolbox.JD_UTCtoUT1-Tuple{Number,Union{EOPData_IAU1980, EOPData_IAU2000A}}"><code>SatelliteToolbox.JD_UTCtoUT1</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">function JD_UTCtoUT1(JD_UTC::Number, eop::Union{EOPData_IAU1980,EOPData_IAU2000A})</code></pre><p>Convert the Julian Day in UTC <code>JD_UTC</code> to the Julian Day in UT1 using the accumulated difference given by the EOP Data <code>eop</code> (see <code>get_iers_eop</code>). Notice that the accumulated difference will be interpolated.</p></div></section></article><article class="docstring"><header><a class="docstring-binding" id="SatelliteToolbox.JDtoDate-Tuple{Number}" href="#SatelliteToolbox.JDtoDate-Tuple{Number}"><code>SatelliteToolbox.JDtoDate</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">function JDtoDate([T,] JD::Number)</code></pre><p>Convert a date represented in Julian Day <code>JD</code> to Gregorian Calendar. The optional parameter <code>T</code> defines the return type. If <code>T</code> is omitted, then it defaults to <code>Int</code>.</p><p><strong>Returns</strong></p><p>If <code>T</code> is omitted or <code>Int</code>, then a tuple with the following data will be returned:</p><ul><li>Year.</li><li>Month (<code>1</code> =&gt; <strong>January</strong>, <code>2</code> =&gt; <strong>February</strong>, ...).</li><li>Day.</li><li>Hour (0 - 24).</li><li>Minute (0 - 59).</li><li>Second (0 - 59).</li></ul><p>Notice that if <code>T</code> is <code>Int</code>, then the seconds field will be Integer. Otherwise, it will be floating point.</p><p>If <code>T</code> is <code>Date</code>, then it will return the Julia structure <code>Date</code>. Notice that the hours, minutes, and seconds will be neglected because the structure <code>Date</code> does not handle them.</p><p>If <code>T</code> is <code>DateTime</code>, then it will return the Julia structure <code>DateTime</code>.</p><p><strong>Remarks</strong></p><p>The algorithm was obtained from [2] (Accessed on 2018-04-11). In [2], there is the following warning:</p><blockquote><p>Note: This method will not give dates accurately on the Gregorian Proleptic Calendar, i.e., the calendar you get by extending the Gregorian calendar backwards to years earlier than 1582. using the Gregorian leap year rules. In particular, the method fails if Y&lt;400.</p></blockquote></div></section></article><article class="docstring"><header><a class="docstring-binding" id="SatelliteToolbox.JDtoGMST-Tuple{Number}" href="#SatelliteToolbox.JDtoGMST-Tuple{Number}"><code>SatelliteToolbox.JDtoGMST</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">function JDtoGMST(JD_UT1::Number)</code></pre><p>Compute the Greenwich Mean Sideral Time (GMST) [rad] for the Julian Day <code>JD_UT1</code> [UT1].</p><p><strong>Remarks</strong></p><p>Based on algorithm in [1, pp. 188].</p></div></section></article><article class="docstring"><header><a class="docstring-binding" id="SatelliteToolbox.M_to_E" href="#SatelliteToolbox.M_to_E"><code>SatelliteToolbox.M_to_E</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">function M_to_E(e::Number, M::Number, tol::Number = 1e-10)</code></pre><p>Compute the eccentric anomaly (0,2π) [rad] given the eccentricity <code>e</code> and the mean anomaly <code>M</code> [rad]. This function uses the Newton-Raphson algorithm and the tolerance to accept the solution is <code>tol</code>.</p></div></section></article><article class="docstring"><header><a class="docstring-binding" id="SatelliteToolbox.M_to_f" href="#SatelliteToolbox.M_to_f"><code>SatelliteToolbox.M_to_f</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">function M_to_f(e::Number, M::Number, tol::Number = 1e-10)</code></pre><p>Compute the true anomaly (0,2π) [rad] given the eccentricity <code>e</code> and the mean anomaly <code>M</code> [rad]. This function uses the Newton-Raphson algorithm and the tolerance to accept the solution is <code>tol</code>.</p></div></section></article><article class="docstring"><header><a class="docstring-binding" id="SatelliteToolbox.adjacent_track_angle_grss-Tuple{Number,Number,Number,Int64,Number}" href="#SatelliteToolbox.adjacent_track_angle_grss-Tuple{Number,Number,Number,Int64,Number}"><code>SatelliteToolbox.adjacent_track_angle_grss</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">function adjacent_track_angle_grss(h::Number, T::Number, i::Number, To::Int, lat::Number)</code></pre><p>Compute the angle between two adjacent ground tracks [rad] in a given latitude <code>lat</code> [rad] measured from the satellite position for a ground repeating, Sun-synchronous orbit with altitude in the Equator <code>h</code> [m], period <code>T</code> [s], inclination <code>i</code> [rad], and orbit cycle <code>To</code> [days].</p><p><strong>Remarks</strong></p><p>The functions <strong>does not</strong> check if the orbit is a GRSS orbit.</p></div></section></article><article class="docstring"><header><a class="docstring-binding" id="SatelliteToolbox.adjacent_track_angle_grss-Tuple{Number,Number,Number,Number,Int64,Number}" href="#SatelliteToolbox.adjacent_track_angle_grss-Tuple{Number,Number,Number,Number,Int64,Number}"><code>SatelliteToolbox.adjacent_track_angle_grss</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">function adjacent_track_angle_grss(h::Number, a::Number, e::Number, i::Number, To::Int, lat::Number)</code></pre><p>Compute the angle between two adjacent ground tracks [rad] in a given latitude <code>lat</code> [rad] measured from the satellite position for a ground repeating, Sun-synchronous orbit with altitude in the Equator <code>h</code> [m], semi-major axis <code>a</code> [m], eccentricity <code>e</code>, inclination <code>i</code> [rad], and orbit cycle <code>To</code> [days].</p><p><strong>Remarks</strong></p><p>The functions <em>does not</em> check if the orbit is a GRSS orbit.</p></div></section></article><article class="docstring"><header><a class="docstring-binding" id="SatelliteToolbox.adjacent_track_distance_grss-Tuple{Number,Number,Int64,Number}" href="#SatelliteToolbox.adjacent_track_distance_grss-Tuple{Number,Number,Int64,Number}"><code>SatelliteToolbox.adjacent_track_distance_grss</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">function adjacent_track_distance_grss(T::Number, i::Number, To::Int, lat::Number)</code></pre><p>Compute the distance between adjacent ground tracks [m] at a given latitude <code>lat</code> [rad] for a ground repeating, Sun-synchronous orbit with period <code>T</code> [s], inclination <code>i</code> [rad], and orbit cycle <code>To</code> [days].</p><p><strong>Remarks</strong></p><p>The functions <strong>does not</strong> check if the orbit is a GRSS orbit.</p></div></section></article><article class="docstring"><header><a class="docstring-binding" id="SatelliteToolbox.adjacent_track_distance_grss-Tuple{Number,Number,Number,Int64,Number}" href="#SatelliteToolbox.adjacent_track_distance_grss-Tuple{Number,Number,Number,Int64,Number}"><code>SatelliteToolbox.adjacent_track_distance_grss</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">function adjacent_track_distance_grss(a::Number, e::Number, i::Number, To::Int, lat::Number)</code></pre><p>Compute the distance between adjacent ground tracks [m] at a given latitude <code>lat</code> [rad] for a ground repeating, Sun-synchronous orbit with semi-major axis <code>a</code> [m], eccentricity <code>e</code>, inclination <code>i</code> [rad], and orbit cycle <code>To</code> [days].</p><p><strong>Remarks</strong></p><p>The functions <em>does not</em> check if the orbit is a GRSS orbit.</p></div></section></article><article class="docstring"><header><a class="docstring-binding" id="SatelliteToolbox.angvel" href="#SatelliteToolbox.angvel"><code>SatelliteToolbox.angvel</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">function angvel(a::Number, e::Number, i::Number, pert::Symbol = :J2)
function angvel(orb::Orbit, pert::Symbol = :J2)</code></pre><p>Compute the angular velocity [rad/s] of an object in an orbit with semi-major axis <code>a</code> [m], eccentricity <code>e</code>, and inclination <code>i</code> [rad], using the perturbation terms specified by the symbol <code>pert</code>. The orbit can also be specified by <code>orb</code>, which is an instance of the structure <code>Orbit</code>.</p><p><code>pert</code> can be:</p><ul><li><code>:J0</code>: Consider a Keplerian orbit.</li><li><code>:J2</code>: Consider the perturbation terms up to J2.</li><li><code>:J4</code>: Consider the perturbation terms J2, J4, and J2².</li></ul><p>If <code>pert</code> is omitted, then it defaults to <code>:J2</code>.</p></div></section></article><article class="docstring"><header><a class="docstring-binding" id="SatelliteToolbox.angvel_to_a" href="#SatelliteToolbox.angvel_to_a"><code>SatelliteToolbox.angvel_to_a</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">function angvel_to_a(n::Number, e::Number, i::Number, pert::Symbol = :J2; μ::Number = m0, max_iter::Int = 20, tol::Number = 1e-10)</code></pre><p>Compute the semi-major axis that will provide an angular velocity <code>n</code> [rad/s] in an orbit with eccentricity <code>e</code> and inclination <code>i</code> [rad], using the perturbation terms specified by the symbol <code>pert</code>.</p><p>Notice that the angular velocity <code>n</code> is related to the nodal period, <em>i.e.</em> the time between two consecutive passages by the ascending node.</p><p><code>pert</code> can be:</p><ul><li><code>:J0</code>: Consider a Keplerian orbit.</li><li><code>:J2</code>: Consider the perturbation terms up to J2.</li><li><code>:J4</code>: Consider the perturbation terms J2, J4, and J2².</li></ul><p>If <code>pert</code> is omitted, then it defaults to <code>:J2</code>.</p><p><strong>Keyword</strong></p><ul><li><code>μ</code>: Standard gravitational parameter for Earth [m^3/s^2].      (<strong>Default</strong> = <code>m0</code>)</li><li><code>max_iter</code>: Maximum number of iterations allowed in the Newton-Raphson             algorithm. (<strong>Default</strong> = 20)</li><li><code>tol</code>: Tolerance to stop the Newton-Raphson algorithm. (<strong>Default</strong> = 1e-10)</li></ul></div></section></article><article class="docstring"><header><a class="docstring-binding" id="SatelliteToolbox.beta_angle" href="#SatelliteToolbox.beta_angle"><code>SatelliteToolbox.beta_angle</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">function beta_angle(JD₀::Number, a::Number, e::Number, i::Number, RAAN::Number, Δt::Integer, pert::Symbol = :J2)</code></pre><p>Compute the beta angle of an orbit with semi-major axis <code>a</code> [m], eccentricity <code>e</code>, inclination <code>i</code> [rad], and initial right ascension of the ascending node <code>RAAN</code> [rad]. The orbit epoch, which is also the day in which the analysis will begin, is <code>JD₀</code> [Julian Day]. The analysis will be performed for each day during <code>Δt</code> days.</p><p>The argument <code>pert</code> can be used to select the perturbation terms that must be used when propagating the right ascencion of the ascending node. The possible values are:</p><ul><li><code>:J0</code>: Consider a Keplerian orbit.</li><li><code>:J2</code>: Consider the perturbation terms up to J2.</li><li><code>:J4</code>: Consider the perturbation terms J2, J4, and J2².</li></ul><p>If <code>pert</code> is omitted, then it defaults to <code>:J2</code>.</p><p><strong>Returns</strong></p><p>An array with two columns. The first one contains the days of the analysis and the second one contains the beta angle [rad] for each day.</p></div></section></article><article class="docstring"><header><a class="docstring-binding" id="SatelliteToolbox.change_oe_frame-Tuple{Number,Number,Number,Number,Number,Number,Vararg{Any,N} where N}" href="#SatelliteToolbox.change_oe_frame-Tuple{Number,Number,Number,Number,Number,Number,Vararg{Any,N} where N}"><code>SatelliteToolbox.change_oe_frame</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">function change_oe_frame(a::Number, e::Number, i::Number, Ω::Number, ω::Number, f::Number, conv_args...)
function change_oe_frame(oe::Orbit, conv_args...)</code></pre><p>Change the reference frame of orbit elements. The orbit elements can be specified by <code>a</code>, <code>e</code>, <code>i</code>, <code>Ω</code>, <code>ω</code>, and <code>f</code>, or the structure <code>oe</code> (see <code>Orbit</code>).</p><p>The conversion arguments <code>conv_args</code> are <strong>the same</strong> arguments that one should pass to the function <code>rECItoECI</code> to convert between the desired frames. For more information, see the documentation of the function <code>rECItoECI</code>.</p><p><strong>Args</strong></p><ul><li><p><code>a</code>: Semi-major axis [m].</p></li><li><p><code>e</code>: Excentricity.</p></li><li><p><code>i</code>: Inclination [rad].</p></li><li><p><code>Ω</code>: Right-ascension of the ascending node [rad].</p></li><li><p><code>ω</code>: Argument of perigee [rad].</p></li><li><p><code>f</code>: True anomaly [rad].</p></li><li><p><code>conv_args...</code>: Conversion arguments, which are the same arguments that one                 would pass to the function <code>rECItoECI</code> to convert between the                 desired frames.</p></li><li><p><code>oe</code>: An instance of the structure <code>Orbit</code> with the orbit elements that will       be converted [SI units].</p></li></ul><p><strong>Returns</strong></p><p>An instance of the structure <code>Orbit</code> with the Keplerian elements [SI units] converted to the new frame.</p><p><strong>Examples</strong></p><pre><code class="language-julia-repl">julia&gt; eop = get_iers_eop(:IAU1980);

julia&gt; teme_epoch = DatetoJD(2016,6,1,11,0,0);

julia&gt; tod_epoch  = DatetoJD(2016,1,1,0,0,0);

julia&gt; oe_teme    = Orbit(0,
                          7130.982e3,
                          0.001111,
                          98.405*pi/180,
                          227.336*pi/180,
                          90*pi/180,
                          320*pi/180)

                 Orbit
  =====================================
                  t =        0.0
    Semi-major axis =     7130.9820 km
       Eccentricity =        0.001111
        Inclination =       98.4050 ˚
               RAAN =      227.3360 ˚
    Arg. of Perigee =       90.0000 ˚
       True Anomaly =      320.0000 ˚

julia&gt; oe_j2000 = change_oe_frame(oe_teme, TEME(), J2000(), teme_epoch, eop)

                 Orbit
  ======================================
                  t =        0.0
    Semi-major axis =     7130.9820 km
       Eccentricity =        0.001111
        Inclination =       98.3365 ˚
               RAAN =      227.1345 ˚
    Arg. of Perigee =       90.0604 ˚
       True Anomaly =      320.0000 ˚

julia&gt; oe_tod   = change_oe_frame(oe_teme, TEME(), teme_epoch, TOD(), tod_epoch, eop)

                 Orbit
  ======================================
                  t =        0.0
    Semi-major axis =     7130.9820 km
       Eccentricity =        0.001111
        Inclination =       98.4037 ˚
               RAAN =      227.3306 ˚
    Arg. of Perigee =       90.0014 ˚
       True Anomaly =      320.0000 ˚</code></pre></div></section></article><article class="docstring"><header><a class="docstring-binding" id="SatelliteToolbox.compute_RAAN_lt-Tuple{Number,Number}" href="#SatelliteToolbox.compute_RAAN_lt-Tuple{Number,Number}"><code>SatelliteToolbox.compute_RAAN_lt</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">function compute_RAAN_lt(JD::Number, asc_node_lt::Number)</code></pre><p>Compute the RAAN (0,2π) [rad] so that the orbit plane local time is <code>asc_node_lt</code> [hour] at the Julian day <code>JD</code>.</p></div></section></article><article class="docstring"><header><a class="docstring-binding" id="SatelliteToolbox.compute_U-Union{Tuple{T}, Tuple{GravityModel_Coefs{T},AbstractArray{T,1} where T}, Tuple{GravityModel_Coefs{T},AbstractArray{T,1} where T,Number}, Tuple{GravityModel_Coefs{T},AbstractArray{T,1} where T,Number,Number}} where T&lt;:Number" href="#SatelliteToolbox.compute_U-Union{Tuple{T}, Tuple{GravityModel_Coefs{T},AbstractArray{T,1} where T}, Tuple{GravityModel_Coefs{T},AbstractArray{T,1} where T,Number}, Tuple{GravityModel_Coefs{T},AbstractArray{T,1} where T,Number,Number}} where T&lt;:Number"><code>SatelliteToolbox.compute_U</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">function compute_U(gm_coefs::GravityModel_Coefs{T}, r::AbstractVector, n_max::Number = -1, m_max::Number = -1) where T&lt;:Number</code></pre><p>Compute the gravitational potential [J/kg] at <code>r</code> (ITRF) [m] using the coefficients <code>gm_coefs</code> (see <code>GravityModel_Coefs</code>). The maximum degree that will be used while computing the spherical harmonics will be <code>n_max</code> and the maximum order is <code>m_max</code>.</p><p>If <code>n_max</code> is negative, then the maximum available degree will be used. If <code>n_max</code> is omitted, then it defaults to 0.</p><p>If <code>m_max</code> is negative or if it is greater than <code>n_max</code>, then it will be set to <code>n_max</code>. If <code>m_max</code> is omitted, then it defaults to 0.</p><div class="admonition is-info"><header class="admonition-header">Info</header><div class="admonition-body"><p>By convention, the result with <code>n_max</code> 0 and 1 will be the same.</p></div></div></div></section></article><article class="docstring"><header><a class="docstring-binding" id="SatelliteToolbox.compute_dU-Union{Tuple{T}, Tuple{GravityModel_Coefs{T},AbstractArray{T,1} where T}, Tuple{GravityModel_Coefs{T},AbstractArray{T,1} where T,Number}, Tuple{GravityModel_Coefs{T},AbstractArray{T,1} where T,Number,Number}} where T&lt;:Number" href="#SatelliteToolbox.compute_dU-Union{Tuple{T}, Tuple{GravityModel_Coefs{T},AbstractArray{T,1} where T}, Tuple{GravityModel_Coefs{T},AbstractArray{T,1} where T,Number}, Tuple{GravityModel_Coefs{T},AbstractArray{T,1} where T,Number,Number}} where T&lt;:Number"><code>SatelliteToolbox.compute_dU</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">function compute_dU(gm_coefs::GravityModel_Coefs{T}, r::AbstractVector, n_max::Number = -1, m_max::Number = -1) where T&lt;:Number</code></pre><p>Compute the derivatives w.r.t. the spherical coordinates of the gravitational field (<code>∂U/∂r</code>, <code>∂U/∂ϕ</code>, <code>∂U/∂λ</code>) defined by the coefficients <code>gm_coefs</code> (see <code>GravityModel_Coefs</code>) at the position <code>r</code> [m] in ITRF. The maximum degree that will be used while computing the spherical harmonics will be <code>n_max</code> and the maximum order is <code>m_max</code>.</p><p>If <code>n_max</code> is negative, then the maximum available degree will be used. If <code>n_max</code> is omitted, then it defaults to 0.</p><p>If <code>m_max</code> is negative or if it is greater than <code>n_max</code>, then it will be set to <code>n_max</code>. If <code>m_max</code> is omitted, then it defaults to 0.</p><div class="admonition is-info"><header class="admonition-header">Info</header><div class="admonition-body"><p>By convention, the result with <code>n_max</code> 0 and 1 will be the same.</p></div></div><p><strong>Returns</strong></p><ul><li>The derivative of the gravitational field w.r.t. the radius (<code>∂U/∂r</code>).</li><li>The derivative of the gravitational field w.r.t. the latitude (<code>∂U/∂ϕ</code>).</li><li>The derivative of the gravitational field w.r.t. the longitude (<code>∂U/∂λ</code>).</li></ul><p><strong>Remarks</strong></p><p>In this case, <code>ϕ</code> is the geocentric latitude and <code>λ</code> is the geocentric longitude.</p></div></section></article><article class="docstring"><header><a class="docstring-binding" id="SatelliteToolbox.compute_g-Union{Tuple{T}, Tuple{GravityModel_Coefs{T},AbstractArray{T,1} where T}, Tuple{GravityModel_Coefs{T},AbstractArray{T,1} where T,Number}, Tuple{GravityModel_Coefs{T},AbstractArray{T,1} where T,Number,Number}} where T&lt;:Number" href="#SatelliteToolbox.compute_g-Union{Tuple{T}, Tuple{GravityModel_Coefs{T},AbstractArray{T,1} where T}, Tuple{GravityModel_Coefs{T},AbstractArray{T,1} where T,Number}, Tuple{GravityModel_Coefs{T},AbstractArray{T,1} where T,Number,Number}} where T&lt;:Number"><code>SatelliteToolbox.compute_g</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">function compute_g(gm_coefs::GravityModel_Coefs{T}, r::AbstractVector, n_max::Number = -1, m_max::Number = -1) where T&lt;:Number</code></pre><p>Compute the gravitational acceleration (ITRF) [m/s²] at position <code>r</code> [m] (ITRF) using the coefficients <code>gm_coefs</code> (see <code>GravityModel_Coefs</code>). The maximum degree that will be used while computing the spherical harmonics will be <code>n_max</code> and the maximum order it <code>m_max</code>.</p><p>If <code>n_max</code> is negative, then the maximum available degree will be used. If <code>n_max</code> is omitted, then it defaults to 0.</p><p>If <code>m_max</code> is negative or if it is greater than <code>n_max</code>, then it will be set to <code>n_max</code>. If <code>m_max</code> is omitted, then it defaults to 0.</p><div class="admonition is-info"><header class="admonition-header">Info</header><div class="admonition-body"><p>By convention, the result with <code>n_max</code> 0 and 1 will be the same.</p></div></div><p><strong>Remarks</strong></p><p>Notice that this function computes the <strong>gravitational acceleration</strong>. Hence, the acceleration due to Earth rotation rate <strong>is not</strong> included.</p></div></section></article><article class="docstring"><header><a class="docstring-binding" id="SatelliteToolbox.compute_ss_orbit_by_ang_vel-Tuple{Number,Number}" href="#SatelliteToolbox.compute_ss_orbit_by_ang_vel-Tuple{Number,Number}"><code>SatelliteToolbox.compute_ss_orbit_by_ang_vel</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">function compute_ss_orbit_by_ang_vel(n::Number, e::Number)</code></pre><p>Compute the Sun-synchronous orbit given the angular velocity <code>n</code> [rad/s] and the eccentricity <code>e</code>.</p><p><strong>Returns</strong></p><ul><li>The semi-major axis [m].</li><li>The inclination [rad].</li><li>The residues of the two functions.</li><li>A boolean variable that indicates if the numerical algorithm converged.</li></ul></div></section></article><article class="docstring"><header><a class="docstring-binding" id="SatelliteToolbox.compute_ss_orbit_by_inclination-Tuple{Number,Number}" href="#SatelliteToolbox.compute_ss_orbit_by_inclination-Tuple{Number,Number}"><code>SatelliteToolbox.compute_ss_orbit_by_inclination</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">function compute_ss_orbit_by_inclination(i::Number, e::Number)</code></pre><p>Compute the Sun-synchronous orbit given the inclination <code>i</code> [rad] and the eccentricity <code>e</code>.</p><p><strong>Returns</strong></p><p>The semi-major axis of the Sun-synchronous orbit [m].</p></div></section></article><article class="docstring"><header><a class="docstring-binding" id="SatelliteToolbox.compute_ss_orbit_by_num_rev_per_day-Tuple{Number,Number}" href="#SatelliteToolbox.compute_ss_orbit_by_num_rev_per_day-Tuple{Number,Number}"><code>SatelliteToolbox.compute_ss_orbit_by_num_rev_per_day</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">function compute_ss_orbit_by_num_rev_per_day(numRevPD::Number, e::Number)</code></pre><p>Compute the Sun-synchronous orbit given the number of revolutions per day <code>numRevPD</code> and the eccentricity <code>e</code>.</p><p><strong>Returns</strong></p><ul><li>The semi-major axis [m].</li><li>The inclination [rad].</li><li>The residues of the two functions.</li><li>A boolean variable that indicates if the numerical algorithm converged.</li></ul></div></section></article><article class="docstring"><header><a class="docstring-binding" id="SatelliteToolbox.compute_ss_orbit_by_semi_major_axis-Tuple{Number,Number}" href="#SatelliteToolbox.compute_ss_orbit_by_semi_major_axis-Tuple{Number,Number}"><code>SatelliteToolbox.compute_ss_orbit_by_semi_major_axis</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">function compute_ss_orbit_by_semi_major_axis(a::Number, e::Number)</code></pre><p>Compute the Sun-synchronous orbit given the semi-major axis <code>a</code> [m] and the eccentricity <code>e</code>.</p><p><strong>Returns</strong></p><p>The inclination of the Sun-synchronous orbit [rad].</p></div></section></article><article class="docstring"><header><a class="docstring-binding" id="SatelliteToolbox.conf_nrlmsise00" href="#SatelliteToolbox.conf_nrlmsise00"><code>SatelliteToolbox.conf_nrlmsise00</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">function conf_nrlmsise00(year::Int, doy::Int, sec::Number, alt::Number, g_lat::Number, g_long::Number, lst::Number, f107A::Number, f107::Number, ap::[Number, AbstractVector], flags::NRLMSISE00_Flags = NRLMSISE00_Flags())</code></pre><p>Create the structure with the proper configuration to call the NRLMSISE-00 model.</p><p>Notice that the input variables have the same units of the original model.</p><p><strong>Args</strong></p><ul><li><code>year</code>: Year (currently ignored).</li><li><code>doy</code>: Day of year.</li><li><code>sec</code>: Seconds in day [UT].</li><li><code>alt</code>: Altitude [km].</li><li><code>g_lat</code>: Geodetic latitude [deg].</li><li><code>g_long</code>: Geodetic longitude [deg].</li><li><code>lst</code>: Local apparent solar time (hours).</li><li><code>f107A</code>: 81 day average of F10.7 flux (centered on day of year <code>doy</code>).</li><li><code>f107</code>: Daily F10.7 flux for previous day.</li><li><code>ap</code>: Magnetic index (daily) if it is a number. If it is an array, then see       <strong>Remarks</strong>.</li><li><code>flags</code>: (OPTIONAL) An instance of the structure <code>NRLMSISE00_Flags</code> with the           configuration flags for NRLMSISE00. If omitted, then the default           configurations will be used.</li></ul><p><strong>Returns</strong></p><p>An instance of the structure <code>NRLMSISE00_Structure</code>.</p><p><strong>Remarks</strong></p><p>If <code>ap</code> is a <code>Vector</code>, then it must be a vector with 7 dimensions as described below:</p><table><tr><th style="text-align: right">Index</th><th style="text-align: left">Description</th></tr><tr><td style="text-align: right">1</td><td style="text-align: left">Daily AP.</td></tr><tr><td style="text-align: right">2</td><td style="text-align: left">3 hour AP index for current time.</td></tr><tr><td style="text-align: right">3</td><td style="text-align: left">3 hour AP index for 3 hours before current time.</td></tr><tr><td style="text-align: right">4</td><td style="text-align: left">3 hour AP index for 6 hours before current time.</td></tr><tr><td style="text-align: right">5</td><td style="text-align: left">3 hour AP index for 9 hours before current time.</td></tr><tr><td style="text-align: right">6</td><td style="text-align: left">Average of eight 3 hour AP indices from 12 to 33 hours prior to current time.</td></tr><tr><td style="text-align: right">7</td><td style="text-align: left">Average of eight 3 hour AP indices from 36 to 57 hours prior to current time.</td></tr></table><p><strong>Notes on input variables</strong></p><p>UT, Local Time, and Longitude are used independently in the model and are not of equal importance for every situation. For the most physically realistic calculation these three variables should be consistent (<code>lst=sec/3600 + g_long/15</code>). The Equation of Time departures from the above formula for apparent local time can be included if available but are of minor importance.</p><p><code>f107</code> and <code>f107A</code> values used to generate the model correspond to the 10.7 cm radio flux at the actual distance of the Earth from the Sun rather than the radio flux at 1 AU. The following site provides both classes of values:</p><pre><code class="language-none">ftp://ftp.ngdc.noaa.gov/STP/SOLAR_DATA/SOLAR_RADIO/FLUX/</code></pre><p><code>f107</code>, <code>f107A</code>, and <code>ap</code> effects are neither large nor well established below 80 km and these parameters should be set to 150, 150, and 4 respectively.</p></div></section></article><article class="docstring"><header><a class="docstring-binding" id="SatelliteToolbox.create_gravity_model_coefs-Tuple{ICGEM}" href="#SatelliteToolbox.create_gravity_model_coefs-Tuple{ICGEM}"><code>SatelliteToolbox.create_gravity_model_coefs</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">function create_gravity_model_coefs(icgem::ICGEM)</code></pre><p>Return an instance of the structure <code>GravityModel_Coefs</code> based on the information obtained from an ICGEM file in <code>icgem</code> (see <code>parse_icgem</code>).</p></div></section></article><article class="docstring"><header><a class="docstring-binding" id="SatelliteToolbox.dArgPer" href="#SatelliteToolbox.dArgPer"><code>SatelliteToolbox.dArgPer</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">function dArgPer(a::Number, e::Number, i::Number, pert::Symbol = :J2)
function dArgPer(orb::Orbit, pert::Symbol = :J2)</code></pre><p>Compute the time-derivative of the argument of perigee [rad/s] of an orbit with semi-major axis <code>a</code> [m], eccentricity <code>e</code>, and inclination <code>i</code> [rad], using the perturbation terms specified by the symbol <code>pert</code>. The orbit can also be specified by <code>orb</code>, which is an instance of the structure <code>Orbit</code>.</p><p><code>pert</code> can be:</p><ul><li><code>:J0</code>: Consider a Keplerian orbit.</li><li><code>:J2</code>: Consider the perturbation terms up to J2.</li><li><code>:J4</code>: Consider the perturbation terms J2, J4, and J2².</li></ul><p>If <code>pert</code> is omitted, then it defaults to <code>:J2</code>.</p></div></section></article><article class="docstring"><header><a class="docstring-binding" id="SatelliteToolbox.dRAAN" href="#SatelliteToolbox.dRAAN"><code>SatelliteToolbox.dRAAN</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">function dRAAN(a::Number, e::Number, i::Number, pert::Symbol = :J2)
function dRAAN(orb::Orbit, pert::Symbol = :J2)</code></pre><p>Compute the time-derivative of the right ascension of the ascending node [rad/s] of an orbit with semi-major axis <code>a</code> [m], eccentricity <code>e</code>, and inclination <code>i</code> [rad], using the perturbation terms specified by the symbol <code>pert</code>. The orbit can also be specified by <code>orb</code>, which is an instance of the structure <code>Orbit</code>.</p><p><code>pert</code> can be:</p><ul><li><code>:J0</code>: Consider a Keplerian orbit.</li><li><code>:J2</code>: Consider the perturbation terms up to J2.</li><li><code>:J4</code>: Consider the perturbation terms J2, J4, and J2².</li></ul><p>If <code>pert</code> is omitted, then it defaults to <code>:J2</code>.</p></div></section></article><article class="docstring"><header><a class="docstring-binding" id="SatelliteToolbox.dlegendre" href="#SatelliteToolbox.dlegendre"><code>SatelliteToolbox.dlegendre</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">function dlegendre([N,] ϕ::Number, n_max::Integer, m_max::Integer = -1, ph_term::Bool = false)</code></pre><p>Compute the first-order derivative of the associated Legendre function <code>P_n,m[cos(ϕ)]</code> w.r.t. <code>ϕ</code> [rad]:</p><pre><code class="language-none">dP_n,m[cos(ϕ)]
--------------
      dϕ</code></pre><p>The maximum degree that will be computed is <code>n_max</code> and the maximum order is <code>m_max</code>. Notice that if <code>m_max</code> is higher than <code>n_max</code> or negative, than it is set to <code>n_max</code>.</p><p>The optional parameter <code>N</code> can be used to select the normalization. The following values are valid:</p><ul><li><code>Val{:full}</code>: Compute the fully normalized associated Legendre function (see               <code>legendre_fully_normalized</code>).</li><li><code>Val{:schmidt}</code>: Compute the Schmidt quasi-normalized associated Legendre                  function (see <code>legendre_schmidt_quasi_normalized</code>).</li><li><code>Val{:conv}</code>: Compute the conventional associated Legendre function (see               <code>dlegendre_conventional!</code>).</li></ul><p>If <code>N</code> is omitted, then the full normalization will be used (<code>Val{:full}</code>).</p><p>If <code>ph_term</code> is set to <code>true</code>, then the Condon-Shortley phase term <code>(-1)ᵐ</code> will be included. If <code>ph_term</code> is not present, then it defaults to <code>false</code>.</p><p><strong>Returns</strong></p><p>A matrix with the first-order derivative of the Legendre associated functions <code>P_n,m[cos(ϕ)]</code>.</p></div></section></article><article class="docstring"><header><a class="docstring-binding" id="SatelliteToolbox.dlegendre!" href="#SatelliteToolbox.dlegendre!"><code>SatelliteToolbox.dlegendre!</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">function dlegendre!([N,] dP::AbstractMatrix, ϕ::Number, P::AbstractMatrix, ph_term::Bool = false)</code></pre><p>Compute the first-order derivative of the associated Legendre function <code>P_n,m[x]</code> w.r.t. <code>ϕ</code> [rad]:</p><pre><code class="language-none">dP_n,m[cos(ϕ)]
--------------
      dϕ</code></pre><p>The derivatives will be stored in the matrix <code>dP</code>. Hence, the maximum degree and order that will be computed are given by the dimensions of this matrix.</p><p>This algorithm needs the matrix <code>P</code> with the associated Legendre function. This can be computed using the function <code>legendre</code>. Notice that this matrix must be computed using the same normalization (see <code>N</code>) as the one selected here.</p><p>The optional parameter <code>N</code> can be used to select the normalization. The following values are valid:</p><ul><li><code>Val{:full}</code>: Compute the fully normalized associated Legendre function (see               <code>dlegendre_fully_normalized!</code>).</li><li><code>Val{:schmidt}</code>: Compute the Schmidt quasi-normalized associated Legendre                  function (see <code>dlegendre_schmidt_quasi_normalized!</code>).</li><li><code>Val{:conv}</code>: Compute the conventional associated Legendre function (see               <code>dlegendre_conventional!</code>).</li></ul><p>If <code>N</code> is omitted, then the full normalization will be used (<code>Val{:full}</code>).</p><p>If <code>ph_term</code> is set to <code>true</code>, then the Condon-Shortley phase term <code>(-1)ᵐ</code> will be included. If <code>ph_term</code> is not present, then it defaults to <code>false</code>.</p></div></section></article><article class="docstring"><header><a class="docstring-binding" id="SatelliteToolbox.dlegendre_conventional!" href="#SatelliteToolbox.dlegendre_conventional!"><code>SatelliteToolbox.dlegendre_conventional!</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">function dlegendre_conventional!(dP::AbstractMatrix, ϕ::Number, P::AbstractMatrix, ph_term::Bool = false)</code></pre><p>Compute the first-order derivative of the conventional associated Legendre function <code>P_n,m[cos(ϕ)]</code> w.r.t. <code>ϕ</code> [rad]:</p><pre><code class="language-none">dP_n,m[cos(ϕ)]
--------------
      dϕ</code></pre><p>The derivatives will be stored in the matrix <code>dP</code>. Hence, the maximum degree and order that will be computed are given by the dimensions of this matrix.</p><p>This algorithm needs the matrix <code>P</code> with the conventional associated Legendre function. This can be computed using the function <code>legendre_conventional</code>.</p><p>If <code>ph_term</code> is set to <code>true</code>, then the Condon-Shortley phase term <code>(-1)ᵐ</code> will be included. If <code>ph_term</code> is not present, then it defaults to <code>false</code>.</p><p><strong>Remarks</strong></p><p>The user is responsible to pass a matrix <code>P</code> with the correct values. For example, if <code>ph_term</code> is <code>true</code>, then <code>P</code> must also be computed with <code>ph_term</code> set to <code>true</code>.</p></div></section></article><article class="docstring"><header><a class="docstring-binding" id="SatelliteToolbox.dlegendre_conventional-Union{Tuple{T}, Tuple{T,Integer}, Tuple{T,Integer,Integer}, Tuple{T,Integer,Integer,Bool}} where T&lt;:AbstractFloat" href="#SatelliteToolbox.dlegendre_conventional-Union{Tuple{T}, Tuple{T,Integer}, Tuple{T,Integer,Integer}, Tuple{T,Integer,Integer,Bool}} where T&lt;:AbstractFloat"><code>SatelliteToolbox.dlegendre_conventional</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">function dlegendre_conventional(ϕ::Number, n_max::Integer, m_max::Integer = -1, ph_term::Bool = false)</code></pre><p>Compute the first-order derivative of the conventional associated Legendre function <code>P_n,m[cos(ϕ)]</code> w.r.t. <code>ϕ</code> [rad]:</p><pre><code class="language-none">dP_n,m[cos(ϕ)]
--------------
      dϕ</code></pre><p>The maximum degree that will be computed is <code>n_max</code> and the maximum order is <code>m_max</code>. Notice that if <code>m_max</code> is higher than <code>n_max</code> or negative, than it is set to <code>n_max</code>.</p><p>If <code>ph_term</code> is set to <code>true</code>, then the Condon-Shortley phase term <code>(-1)ᵐ</code> will be included. If <code>ph_term</code> is not present, then it defaults to <code>false</code>.</p><p><strong>Returns</strong></p><p>A matrix with the first-order derivative of the Legendre associated functions <code>P_n,m[cos(ϕ)]</code>.</p></div></section></article><article class="docstring"><header><a class="docstring-binding" id="SatelliteToolbox.dlegendre_fully_normalized!" href="#SatelliteToolbox.dlegendre_fully_normalized!"><code>SatelliteToolbox.dlegendre_fully_normalized!</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">function dlegendre_fully_normalized!(dP::AbstractMatrix, ϕ::Number, P::AbstractMatrix, ph_term::Bool = false)</code></pre><p>Compute the first-order derivative of the fully normalized associated Legendre function <code>P_n,m[cos(ϕ)]</code> w.r.t. <code>ϕ</code> [rad]:</p><pre><code class="language-none">dP_n,m[cos(ϕ)]
--------------
      dϕ</code></pre><p>The derivatives will be stored in the matrix <code>dP</code>. Hence, the maximum degree and order that will be computed are given by the dimensions of this matrix.</p><p>This algorithm needs the matrix <code>P</code> with the fully normalized associated Legendre function. This can be computed using the function <code>legendre_fully_normalized</code>.</p><p>If <code>ph_term</code> is set to <code>true</code>, then the Condon-Shortley phase term <code>(-1)ᵐ</code> will be included. If <code>ph_term</code> is not present, then it defaults to <code>false</code>.</p><p><strong>Remarks</strong></p><p>The user is responsible to pass a matrix <code>P</code> with the correct values. For example, if <code>ph_term</code> is <code>true</code>, then <code>P</code> must also be computed with <code>ph_term</code> set to <code>true</code>.</p></div></section></article><article class="docstring"><header><a class="docstring-binding" id="SatelliteToolbox.dlegendre_fully_normalized-Union{Tuple{T}, Tuple{T,Integer}, Tuple{T,Integer,Integer}, Tuple{T,Integer,Integer,Bool}} where T&lt;:AbstractFloat" href="#SatelliteToolbox.dlegendre_fully_normalized-Union{Tuple{T}, Tuple{T,Integer}, Tuple{T,Integer,Integer}, Tuple{T,Integer,Integer,Bool}} where T&lt;:AbstractFloat"><code>SatelliteToolbox.dlegendre_fully_normalized</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">function dlegendre_fully_normalized(ϕ::T, n_max::Integer, m_max::Integer = -1, ph_term::Bool = false) where T&lt;:AbstractFloat</code></pre><p>Compute the first-order derivative of the Schmidt fully normalized associated Legendre function <code>P_n,m[cos(ϕ)]</code> w.r.t. <code>ϕ</code> [rad]:</p><pre><code class="language-none">dP_n,m[cos(ϕ)]
--------------
      dϕ</code></pre><p>The maximum degree that will be computed is <code>n_max</code> and the maximum order is <code>m_max</code>. Notice that if <code>m_max</code> is higher than <code>n_max</code> or negative, than it is set to <code>n_max</code>.</p><p>If <code>ph_term</code> is set to <code>true</code>, then the Condon-Shortley phase term <code>(-1)ᵐ</code> will be included. If <code>ph_term</code> is not present, then it defaults to <code>false</code>.</p><p><strong>Returns</strong></p><p>A matrix with the first-order derivative of the Legendre associated functions <code>P_n,m[cos(ϕ)]</code>.</p></div></section></article><article class="docstring"><header><a class="docstring-binding" id="SatelliteToolbox.dlegendre_schmidt_quasi_normalized!" href="#SatelliteToolbox.dlegendre_schmidt_quasi_normalized!"><code>SatelliteToolbox.dlegendre_schmidt_quasi_normalized!</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">function dlegendre_schmidt_quasi_normalized!(dP::AbstractMatrix, ϕ::Number, P::AbstractMatrix, ph_term::Bool = false)</code></pre><p>Compute the first-order derivative of the Schmidt quasi-normalized associated Legendre function <code>P_n,m[cos(ϕ)]</code> w.r.t. <code>ϕ</code> [rad]:</p><pre><code class="language-none">dP_n,m[cos(ϕ)]
--------------
      dϕ</code></pre><p>The derivatives will be stored in the matrix <code>dP</code>. Hence, the maximum degree and order that will be computed are given by the dimensions of this matrix.</p><p>This algorithm needs the matrix <code>P</code> with the Schmidt quasi-normalized associated Legendre function. This can be computed using the function <code>legendre_schmidt_quasi_normalized</code>.</p><p>If <code>ph_term</code> is set to <code>true</code>, then the Condon-Shortley phase term <code>(-1)ᵐ</code> will be included. If <code>ph_term</code> is not present, then it defaults to <code>false</code>.</p><p><strong>Remarks</strong></p><p>The user is responsible to pass a matrix <code>P</code> with the correct values. For example, if <code>ph_term</code> is <code>true</code>, then <code>P</code> must also be computed with <code>ph_term</code> set to <code>true</code>.</p></div></section></article><article class="docstring"><header><a class="docstring-binding" id="SatelliteToolbox.dlegendre_schmidt_quasi_normalized-Union{Tuple{T}, Tuple{T,Integer}, Tuple{T,Integer,Integer}, Tuple{T,Integer,Integer,Bool}} where T&lt;:AbstractFloat" href="#SatelliteToolbox.dlegendre_schmidt_quasi_normalized-Union{Tuple{T}, Tuple{T,Integer}, Tuple{T,Integer,Integer}, Tuple{T,Integer,Integer,Bool}} where T&lt;:AbstractFloat"><code>SatelliteToolbox.dlegendre_schmidt_quasi_normalized</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">function dlegendre_schmidt_quasi_normalized(ϕ::T, n_max::Integer, m_max::Integer = -1, ph_term::Bool = false) where T&lt;:AbstractFloat</code></pre><p>Compute the first-order derivative of the Schmidt quasi-normalized associated Legendre function <code>P_n,m[cos(ϕ)]</code> w.r.t. <code>ϕ</code> [rad]:</p><pre><code class="language-none">dP_n,m[cos(ϕ)]
--------------
      dϕ</code></pre><p>The maximum degree that will be computed is <code>n_max</code> and the maximum order is <code>m_max</code>. Notice that if <code>m_max</code> is higher than <code>n_max</code> or negative, than it is set to <code>n_max</code>.</p><p>If <code>ph_term</code> is set to <code>true</code>, then the Condon-Shortley phase term <code>(-1)ᵐ</code> will be included. If <code>ph_term</code> is not present, then it defaults to <code>false</code>.</p><p><strong>Returns</strong></p><p>A matrix with the first-order derivative of the Legendre associated functions <code>P_n,m[cos(ϕ)]</code>.</p></div></section></article><article class="docstring"><header><a class="docstring-binding" id="SatelliteToolbox.eclipse_time_summary" href="#SatelliteToolbox.eclipse_time_summary"><code>SatelliteToolbox.eclipse_time_summary</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">function eclipse_time_summary(JD₀::Number, a::Number, e::Number, i::Number, RAAN::Number, w::Number, Δd::Integer, relative::Bool = false, Δt₀::AbstractFloat = -1.0)</code></pre><p>Compute the eclipse time of an orbit with semi-major axis <code>a</code> [m], eccentricity <code>e</code>, inclination <code>i</code> [rad], initial right ascension of the ascending node <code>RAAN</code> [rad], and initial argument of perigee <code>w</code> [rad]. The orbit epoch, which is also the day in which the analysis will begin, is <code>JD₀</code> [Julian Day]. The analysis will be performed for each day during <code>Δd</code> days.</p><p>This function will compute the eclipse time of one orbit per day.</p><p>If the argument <code>relative</code> is <code>true</code>, then the computed times will be relative to the nodal period [%]. Otherwise, they will be computed in seconds. By default, <code>relative = false</code>.</p><p>The argument <code>Δt₀</code> can be used to select the time step in which the orbit will be propagated. Notice that this algorithm performs a numerical search to find the beginning of each section (sunlight, penumbra, and umbra) with millisecond precision. Thus, selecting a high number for <code>Δt₀</code> will make the analysis faster, but the accuracy is lost if a region time span is smalled than <code>Δt₀</code>. If this parameter is omitted or if it is negative, then the time step will be selected automatically to match a mean anomaly step of 5°.</p><p>All the analysis is performed using a J2 orbit propagator.</p><p><strong>Returns</strong></p><p>The following table:</p><pre><code class="language-none">    day | Sunlight Time | Penumbra Time | Umbra Time
   -----+---------------+---------------+------------</code></pre></div></section></article><article class="docstring"><header><a class="docstring-binding" id="SatelliteToolbox.epoch-Tuple{OrbitPropagatorJ2}" href="#SatelliteToolbox.epoch-Tuple{OrbitPropagatorJ2}"><code>SatelliteToolbox.epoch</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">function epoch(orbp)</code></pre><p>Return the epoch of the propagator <code>orbp</code> [JD].</p></div></section></article><article class="docstring"><header><a class="docstring-binding" id="SatelliteToolbox.equation_of_time-Tuple{Number}" href="#SatelliteToolbox.equation_of_time-Tuple{Number}"><code>SatelliteToolbox.equation_of_time</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">function equation_of_time(JD::Number)</code></pre><p>Compute the difference between the Sun apparent local time and the Sun mean local time [rad], which is called Equation of Time, at the Julian Day <code>JD</code>. The algorithm was adapted from [1, p. 178, 277-279].</p></div></section></article><article class="docstring"><header><a class="docstring-binding" id="SatelliteToolbox.expatmosphere-Tuple{Number}" href="#SatelliteToolbox.expatmosphere-Tuple{Number}"><code>SatelliteToolbox.expatmosphere</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">function expatmosphere(h::Number)</code></pre><p>Compute the atmospheric density [kg/m³] at the altitude <code>h</code> [m] (above the ellipsoid) using the exponential atmospheric model:</p><pre><code class="language-none">                ┌            ┐
                │    h - h₀  │
ρ(h) = ρ₀ ⋅ exp │ - ──────── │ ,
                │      H     │
                └            ┘</code></pre><p>in which <code>ρ₀</code>, <code>h₀</code>, and <code>H</code> are parameters obtained from tables that depend only on <code>h</code>.</p></div></section></article><article class="docstring"><header><a class="docstring-binding" id="SatelliteToolbox.f_to_E-Tuple{Number,Number}" href="#SatelliteToolbox.f_to_E-Tuple{Number,Number}"><code>SatelliteToolbox.f_to_E</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">function f_to_E(e::Number,f::Number)</code></pre><p>Compute the eccentric anomaly (0,2π) [rad] given the eccentricity <code>e</code> and the true anomaly <code>f</code> [rad].</p></div></section></article><article class="docstring"><header><a class="docstring-binding" id="SatelliteToolbox.f_to_E-Tuple{Orbit}" href="#SatelliteToolbox.f_to_E-Tuple{Orbit}"><code>SatelliteToolbox.f_to_E</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">function f_to_E(orb::Orbit)</code></pre><p>Compute the eccentric anomaly (0,2π) [rad] given the orbit <code>orb</code> (see <code>Orbit</code>).</p></div></section></article><article class="docstring"><header><a class="docstring-binding" id="SatelliteToolbox.f_to_M-Tuple{Number,Number}" href="#SatelliteToolbox.f_to_M-Tuple{Number,Number}"><code>SatelliteToolbox.f_to_M</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">function f_to_M(e::Number, f::Number)</code></pre><p>Compute the mean anomaly (0,2π) [rad] given the eccentricity <code>e</code> and the true anomaly <code>f</code> [rad].</p></div></section></article><article class="docstring"><header><a class="docstring-binding" id="SatelliteToolbox.f_to_M-Tuple{Orbit}" href="#SatelliteToolbox.f_to_M-Tuple{Orbit}"><code>SatelliteToolbox.f_to_M</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">function f_to_M(orb::Orbit)</code></pre><p>Compute the mean anomaly (0,2π) [rad] given the orbit <code>orb</code> (see <code>Orbit</code>).</p></div></section></article><article class="docstring"><header><a class="docstring-binding" id="SatelliteToolbox.geomag_dipole" href="#SatelliteToolbox.geomag_dipole"><code>SatelliteToolbox.geomag_dipole</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">function geomag_dipole(r_e::AbstractVector, pole_lat::Number, pole_lon::Number, m::Number)</code></pre><p>Compute the geomagnetic field [nT] using the simplified dipole model at position <code>r_e</code> (ECEF reference frame). This function considers that the latitude of the South magnetic pole (which lies in the North hemisphere) is <code>pole_lat</code> [rad] and the longitude is <code>pole_lon</code> [rad]. Furthermore, the dipole moment is considered to be <code>m</code> [A.m²].</p><pre><code class="language-none">function geomag_dipole(r_e::AbstractVector, year::Number = 2019)</code></pre><p>Compute the geomagnetic field [nT] using the simplified dipole model at position <code>r_e</code> (ECEF reference frame). This function uses the year <code>year</code> to obtain the position of the South magnetic pole (which lies in the North hemisphere) and the dipole moment. If <code>year</code> is omitted, then it will be considered as 2019.</p><p><strong>Remarks</strong></p><p>In both functions, the output vector will be represented in the ECEF reference frame.</p></div></section></article><article class="docstring"><header><a class="docstring-binding" id="SatelliteToolbox.get_Ap-Tuple{Number}" href="#SatelliteToolbox.get_Ap-Tuple{Number}"><code>SatelliteToolbox.get_Ap</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">function get_Ap(JD::Number; mean::Tuple{Int} = (), daily = false)</code></pre><p>Return the Ap index.</p><p>If <code>mean</code> is a tuple of two integers <code>(hi, hf)</code>, then the average between <code>hi</code> and <code>hf</code> previous hours will be computed.</p><p>If <code>mean</code> is empty and <code>daily</code> is <code>true</code>, then the day average will be computed.</p><p>If <code>mean</code> keyword is empty, and <code>daily</code> keyword is <code>false</code>, then the Ap at Julian day <code>JD</code> will be computed.</p><p>By default, <code>mean</code> is empty and <code>daily</code> is <code>false</code>.</p></div></section></article><article class="docstring"><header><a class="docstring-binding" id="SatelliteToolbox.get_DstΔTc-Tuple{Number}" href="#SatelliteToolbox.get_DstΔTc-Tuple{Number}"><code>SatelliteToolbox.get_DstΔTc</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">get_DstΔTc(JD::Number)</code></pre><p>Get the value of the index <code>DstΔTc</code> at Julian Day <code>JD</code>.</p><p>This function requires the initialization of the variable <code>_dtcfile_data</code>. Otherwise, an exception will be raised. To initialize it, run <code>init_space_indices()</code>.</p></div></section></article><article class="docstring"><header><a class="docstring-binding" id="SatelliteToolbox.get_F10-Tuple{Number}" href="#SatelliteToolbox.get_F10-Tuple{Number}"><code>SatelliteToolbox.get_F10</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">get_F10(JD::Number)</code></pre><p>Get the value of the index <code>F10</code> at Julian Day <code>JD</code>.</p><p>This function requires the initialization of the variable <code>_solfsmy_data</code>. Otherwise, an exception will be raised. To initialize it, run <code>init_space_indices()</code>.</p></div></section></article><article class="docstring"><header><a class="docstring-binding" id="SatelliteToolbox.get_F81a-Tuple{Number}" href="#SatelliteToolbox.get_F81a-Tuple{Number}"><code>SatelliteToolbox.get_F81a</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">get_F81a(JD::Number)</code></pre><p>Get the value of the index <code>F81a</code> at Julian Day <code>JD</code>.</p><p>This function requires the initialization of the variable <code>_solfsmy_data</code>. Otherwise, an exception will be raised. To initialize it, run <code>init_space_indices()</code>.</p></div></section></article><article class="docstring"><header><a class="docstring-binding" id="SatelliteToolbox.get_Kp-Tuple{Number}" href="#SatelliteToolbox.get_Kp-Tuple{Number}"><code>SatelliteToolbox.get_Kp</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">function get_Kp(JD::Number)</code></pre><p>Return the Kp index at Julian Day <code>JD</code>.</p></div></section></article><article class="docstring"><header><a class="docstring-binding" id="SatelliteToolbox.get_M10-Tuple{Number}" href="#SatelliteToolbox.get_M10-Tuple{Number}"><code>SatelliteToolbox.get_M10</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">get_M10(JD::Number)</code></pre><p>Get the value of the index <code>M10</code> at Julian Day <code>JD</code>.</p><p>This function requires the initialization of the variable <code>_solfsmy_data</code>. Otherwise, an exception will be raised. To initialize it, run <code>init_space_indices()</code>.</p></div></section></article><article class="docstring"><header><a class="docstring-binding" id="SatelliteToolbox.get_M81a-Tuple{Number}" href="#SatelliteToolbox.get_M81a-Tuple{Number}"><code>SatelliteToolbox.get_M81a</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">get_M81a(JD::Number)</code></pre><p>Get the value of the index <code>M81a</code> at Julian Day <code>JD</code>.</p><p>This function requires the initialization of the variable <code>_solfsmy_data</code>. Otherwise, an exception will be raised. To initialize it, run <code>init_space_indices()</code>.</p></div></section></article><article class="docstring"><header><a class="docstring-binding" id="SatelliteToolbox.get_S10-Tuple{Number}" href="#SatelliteToolbox.get_S10-Tuple{Number}"><code>SatelliteToolbox.get_S10</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">get_S10(JD::Number)</code></pre><p>Get the value of the index <code>S10</code> at Julian Day <code>JD</code>.</p><p>This function requires the initialization of the variable <code>_solfsmy_data</code>. Otherwise, an exception will be raised. To initialize it, run <code>init_space_indices()</code>.</p></div></section></article><article class="docstring"><header><a class="docstring-binding" id="SatelliteToolbox.get_S81a-Tuple{Number}" href="#SatelliteToolbox.get_S81a-Tuple{Number}"><code>SatelliteToolbox.get_S81a</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">get_S81a(JD::Number)</code></pre><p>Get the value of the index <code>S81a</code> at Julian Day <code>JD</code>.</p><p>This function requires the initialization of the variable <code>_solfsmy_data</code>. Otherwise, an exception will be raised. To initialize it, run <code>init_space_indices()</code>.</p></div></section></article><article class="docstring"><header><a class="docstring-binding" id="SatelliteToolbox.get_Y10-Tuple{Number}" href="#SatelliteToolbox.get_Y10-Tuple{Number}"><code>SatelliteToolbox.get_Y10</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">get_Y10(JD::Number)</code></pre><p>Get the value of the index <code>Y10</code> at Julian Day <code>JD</code>.</p><p>This function requires the initialization of the variable <code>_solfsmy_data</code>. Otherwise, an exception will be raised. To initialize it, run <code>init_space_indices()</code>.</p></div></section></article><article class="docstring"><header><a class="docstring-binding" id="SatelliteToolbox.get_Y81a-Tuple{Number}" href="#SatelliteToolbox.get_Y81a-Tuple{Number}"><code>SatelliteToolbox.get_Y81a</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">get_Y81a(JD::Number)</code></pre><p>Get the value of the index <code>Y81a</code> at Julian Day <code>JD</code>.</p><p>This function requires the initialization of the variable <code>_solfsmy_data</code>. Otherwise, an exception will be raised. To initialize it, run <code>init_space_indices()</code>.</p></div></section></article><article class="docstring"><header><a class="docstring-binding" id="SatelliteToolbox.get_iers_eop" href="#SatelliteToolbox.get_iers_eop"><code>SatelliteToolbox.get_iers_eop</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">function get_iers_eop(data_type::Symbol = :IAU1980; force_download = false)</code></pre><p>Download and parse the IERS EOP C04 data. The data type is specified by <code>data_type</code> symbol. Supported values are:</p><ul><li><code>IAU1980</code>: Get IERS EOP C04 IAU1980 data.</li><li><code>IAU2000A</code>: Get IERS EOP C04 IAU2000A data.</li></ul><p>If <code>data_type</code> is omitted, then it defaults to <code>IAU1980</code>.</p><p>The files are downloaded using the <code>RemoteFile</code> package with daily updates. Hence, if one desires to force a download before the scheduled time, then set the keyword <code>force_download</code> to <code>true</code>.</p><p><strong>Returns</strong></p><p>A structure (<code>EOPData_IAU1980</code> or <code>EOPData_IAU2000A</code>, depending on <code>data_type</code>) with the interpolations of the EOP parameters. Notice that the interpolation indexing is set to the Julian Day.</p></div></section></article><article class="docstring"><header><a class="docstring-binding" id="SatelliteToolbox.get_iers_eop_iau_1980" href="#SatelliteToolbox.get_iers_eop_iau_1980"><code>SatelliteToolbox.get_iers_eop_iau_1980</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">function get_iers_eop_iau_1980(url::String = &quot;https://datacenter.iers.org/data/latestVersion/223_EOP_C04_14.62-NOW.IAU1980223.txt&quot;)</code></pre><p>Get the IERS EOP C04 IAU1980 data from the URL <code>url</code>. If <code>url</code> is omitted, then it defaults to https://datacenter.iers.org/data/latestVersion/223<em>EOP</em>C04_14.62-NOW.IAU1980223.txt</p><p>The file is downloaded using the <code>RemoteFile</code> package with daily updates. Hence, if one desires to force a download before the scheduled time, then set the keyword <code>force_download</code> to <code>true</code>.</p><p><strong>Returns</strong></p><p>The structure <code>EOPData_IAU1980</code> with the interpolations of the EOP parameters. Notice that the interpolation indexing is set to the Julian Day.</p><p><strong>Remarks</strong></p><p>For every field in <code>EOPData_IAU1980</code> to interpolation between two points in the grid is linear. If extrapolation is needed, then if will use the nearest value (flat extrapolation).</p></div></section></article><article class="docstring"><header><a class="docstring-binding" id="SatelliteToolbox.get_iers_eop_iau_2000A" href="#SatelliteToolbox.get_iers_eop_iau_2000A"><code>SatelliteToolbox.get_iers_eop_iau_2000A</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">function get_iers_eop_iau_2000A(url::String = &quot;https://datacenter.iers.org/data/latestVersion/224_EOP_C04_14.62-NOW.IAU2000A224.txt&quot;; force_download = false)</code></pre><p>Get the IERS EOP C04 IAU2000A data from the URL <code>url</code>. If <code>url</code> is omitted, then it defaults to https://datacenter.iers.org/data/latestVersion/224<em>EOP</em>C04_14.62-NOW.IAU2000A224.txt</p><p>The file is downloaded using the <code>RemoteFile</code> package with daily updates. Hence, if one desires to force a download before the scheduled time, then set the keyword <code>force_download</code> to <code>true</code>.</p><p><strong>Returns</strong></p><p>The structure <code>EOPData_IAU2000A</code> with the interpolations of the EOP parameters. Notice that the interpolation indexing is set to the Julian Day.</p><p><strong>Remarks</strong></p><p>For every field in <code>EOPData_IAU2000A</code> to interpolation between two points in the grid is linear. If extrapolation is needed, then if will use the nearest value (flat extrapolation).</p></div></section></article><article class="docstring"><header><a class="docstring-binding" id="SatelliteToolbox.get_space_index-Tuple{Type{Val{:F10}},Number}" href="#SatelliteToolbox.get_space_index-Tuple{Type{Val{:F10}},Number}"><code>SatelliteToolbox.get_space_index</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">function get_space_index(T, JD::Number; ...)</code></pre><p>Return the space index <code>T</code> at the day <code>JD</code> [Julian Day]. <code>T</code> can be:</p><p><strong>Daily 10.7-cm solar flux</strong></p><p>The daily 10.7-cm solar flux can be obtained using:</p><ul><li><code>F10()</code>: 10.7-cm adjusted solar flux [10⁻²² W/(M² Hz)].</li><li><code>F10adj()</code>: 10.7-cm adjusted solar flux [10⁻²² W/(M² Hz)].</li><li><code>F10obs()</code>: 10.7-cm observed solar flux [10⁻²² W/(M² Hz)].</li></ul><p>These indices require <code>fluxtable</code> (see <code>init_space_indices</code>).</p><p><strong>Daily average 10.7-cm solar flux</strong></p><p>The daily average 10.7-cm solar flux, centered at <code>JD</code>, can be obtained using:</p><ul><li><code>F10M()</code>: 10.7-cm adjusted solar flux [10⁻²² W/(M² Hz)].</li><li><code>F10Madj()</code>: 10.7-cm adjusted solar flux [10⁻²² W/(M² Hz)].</li><li><code>F10Mobs()</code>: 10.7-cm observed solar flux [10⁻²² W/(M² Hz)].</li></ul><p>In this case, the keyword <code>window::Int</code> can be passed to select the size of the window. By default, it is selected as 81.</p><p>These indices require <code>fluxtable</code> (see <code>init_space_indices</code>).</p><p><strong>Daily Kp and Ap</strong></p><ul><li><code>Kp()</code>: Kp index (daily mean).</li><li><code>Kp_vect()</code>: A vector containing the Kp index for the following hours of the              day: 0-3h, 3-6h, 6-9h, 9-12h, 12-15h, 15-18h, 18-20h, 20-23h.</li><li><code>Ap()</code>: Ap index (daily mean).</li><li><code>Ap_vect()</code>: A vector containing the Ap index for the following hours of the              day: 0-3h, 3-6h, 6-9h, 9-12h, 12-15h, 15-18h, 18-20h, 20-23h.</li></ul><p>These indices require <code>wdcfiles</code> (see <code>init_space_indices</code>).</p><p><strong>Daily S10, M10, and Y10</strong></p><ul><li><code>S10()</code>: EUV index (26-34 nm) scaled to F10.7.</li><li><code>M10()</code>: MG2 index scaled to F10.7.</li><li><code>Y10()</code>: Solar X-ray &amp; Lya index scaled to F10.7.</li></ul><p>These indices require <code>solfsmy</code> (see <code>init_space_indices</code>).</p><p><strong>81-day centered average of S10, M10, and Y10.</strong></p><ul><li><code>S81a</code>: EUV 81-day averaged centered index.</li><li><code>M81a</code>: MG2 81-day averaged centered index.</li><li><code>Y81a</code>: Solar X-ray &amp; Lya 81-day averaged centered index.</li></ul><p>These indices require <code>solfsmy</code> (see <code>init_space_indices</code>).</p><p><strong>Exospheric temperature variation due to Dst</strong></p><ul><li><code>DstΔTc</code>: Exospheric temperature variation due to <code>Dst</code> [K].</li></ul><p>This index requires <code>dtcfile</code> (see <code>init_space_indices</code>).</p></div></section></article><article class="docstring"><header><a class="docstring-binding" id="SatelliteToolbox.get_ΔAT-Tuple{Number}" href="#SatelliteToolbox.get_ΔAT-Tuple{Number}"><code>SatelliteToolbox.get_ΔAT</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">function get_ΔAT(JD::Number)</code></pre><p>Get the accumulated leap seconds (ΔAT) [s] between UTC and International Atomic Time (TAI) in the given <code>JD</code>. This function search for ΔAT in the array <code>ΔAT_Data</code>.</p><p><strong>Remarks</strong></p><p>If <code>JD</code> is before <code>ΔAT_Data[1,1]</code>, then 10 will be returned. <strong>Notice that this can lead to errors.</strong></p><p>If <code>JD</code> is after <code>ΔAT_Data[end,1]</code>, then <code>ΔAT_Data[end,2]</code> will be returned, because it is not possible yet to predict when leap seconds will be added.</p></div></section></article><article class="docstring"><header><a class="docstring-binding" id="SatelliteToolbox.ground_station_accesses-Tuple{Any,Tuple,Vararg{Any,N} where N}" href="#SatelliteToolbox.ground_station_accesses-Tuple{Any,Tuple,Vararg{Any,N} where N}"><code>SatelliteToolbox.ground_station_accesses</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">function ground_station_accesses(orbp, vrs_e,     Δt, ECI, ECEF, vargs...; kwargs...)
function ground_station_accesses(orbp, [(WGS84)], Δt, ECI, ECEF, vargs...; kwargs...)</code></pre><p>Compute the accesses of a satellite with orbit propagator <code>orbp</code> (see <code>init_orbit_propagator</code>) to the ground stations defined in the vector <code>vrs_e</code>. The analysis interval begins in the propagator epoch and lasts <code>Δt</code> [s].</p><p>The ground stations can be specified by an array of 3×1 vectors describing the ground stations position in an ECEF frame <code>vrs_e</code> or by an array of tuples containing the WGS84 position of each ground station <code>[(WGS84)]</code>:</p><pre><code class="language-none">(latitude [rad], longitude [rad], altitude [m])</code></pre><p><strong>Args</strong></p><ul><li><code>ECI</code>: Earth-Centered Inertial frame in which the state vector of the        propagator is represented.</li><li><code>ECEF</code>: Earth-Centered, Earth-fixed frame to be used for the analysis. It         must be the same frame used to compute the ground station position         vector.</li><li><code>vargs...</code>: list of additional arguments to be passed to the function             <code>rECItoECEF</code> when converting the ECI frame to the ECEF.</li></ul><p><strong>Keywords</strong></p><ul><li><code>θ</code>: Minimum elevation angle for communication between the satellite and the      ground stations [rad]. (<strong>Default</strong> = 10ᵒ)</li><li><code>reduction</code>: A function that receives a boolean vector with the visibility              between the satellite and each ground station. It must return a              boolean value indicating if the access must be computed or not.              This is useful to merge access time between two or more stations.              (<strong>Default</strong> = <code>v-&gt;|(v...)</code> <em>i.e.</em> compute the access if at least              one ground station is visible)</li></ul></div></section></article><article class="docstring"><header><a class="docstring-binding" id="SatelliteToolbox.ground_station_gaps-Tuple{Any,Vararg{Any,N} where N}" href="#SatelliteToolbox.ground_station_gaps-Tuple{Any,Vararg{Any,N} where N}"><code>SatelliteToolbox.ground_station_gaps</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">function ground_station_gaps(args...; kwargs...)</code></pre><p>Compute the gaps between the accesses of ground stations. The arguments and keywords are the same as the ones used in the function <code>ground_station_accesses</code>.</p><p>Notice that the gap analysis starts in the orbit propagator epoch and ends in the instant defined by the argument <code>Δt</code>.</p></div></section></article><article class="docstring"><header><a class="docstring-binding" id="SatelliteToolbox.ground_station_visible-Tuple{AbstractArray{T,1} where T,AbstractArray{T,1} where T,Number}" href="#SatelliteToolbox.ground_station_visible-Tuple{AbstractArray{T,1} where T,AbstractArray{T,1} where T,Number}"><code>SatelliteToolbox.ground_station_visible</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">function ground_station_visible(r_e::AbstractVector, rs_e::AbstractVector, θ::Number)</code></pre><p>Check if the satellite with position vector <code>r_e</code> (ECEF) is inside the visibility circle of a ground station with position vector <code>rs_e</code> (ECEF) and a minimum elevation angle of <code>θ</code> [rad].</p><p>Notice that <code>r_e</code> and <code>rs_e</code> must be represented in the same ECEF frame, and must have the same unit.</p><p>Returns <code>true</code> if the satellite is inside the visibility circle, or <code>false</code> otherwise.</p></div></section></article><article class="docstring"><header><a class="docstring-binding" id="SatelliteToolbox.ground_station_visible-Tuple{AbstractArray{T,1} where T,Number,Number,Number,Number}" href="#SatelliteToolbox.ground_station_visible-Tuple{AbstractArray{T,1} where T,Number,Number,Number,Number}"><code>SatelliteToolbox.ground_station_visible</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">function ground_station_visible(r_e::AbstractVector, lat_s::Number, lon_s::Number, h_s::Number, θ::Number)</code></pre><p>Check if the satellite with position vector <code>r_e</code> (ECEF) is inside the visibility circle of a ground station with latitude <code>lat_s</code> [rad], longitude <code>lon_s</code> [rad], altitude <code>h_s</code> (WGS-84), and a minimum elevation angle of <code>θ</code> [rad].</p><p>Notice that the units of <code>r_e</code> and <code>h_s</code> must be the same.</p><p>Returns <code>true</code> if the satellite is inside the visibility circle, or <code>false</code> otherwise.</p></div></section></article><article class="docstring"><header><a class="docstring-binding" id="SatelliteToolbox.ground_trace-Union{Tuple{OrbitPropagator{N}}, Tuple{N}} where N" href="#SatelliteToolbox.ground_trace-Union{Tuple{OrbitPropagator{N}}, Tuple{N}} where N"><code>SatelliteToolbox.ground_trace</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">function ground_trace(orbp::OrbitPropagator{N}, eop_data::Union{Nothing, EOPData_IAU1980, EOPData_IAU2000A} = nothing; ECI = TEME(), ECEF = PEF(), span = 1.0) where N</code></pre><p>Compute the ground trace of the object with orbit defined by <code>orbp</code>.</p><p>By default, it considers that the orbit elements on the propagator are represented in the True Equator, Mean Equinox (TEME) reference frame and the ground trace will be computed in the Pseudo-Earth Fixed (PEF) reference frame. Hence, no EOP data is needed. However, this can be changed by the keywords presented as follows.</p><p><strong>Keywords</strong></p><ul><li><code>eop_data</code>: EOP data that will be used to convert the ECI reference frame to             the ECEF reference frame. If <code>nothing</code>, then it will not be used             (see <code>rECItoECEF</code>). (<strong>Default</strong> = <code>nothing</code>)</li><li><code>ECI</code>: ECI frame in which the orbit elements in <code>orbp</code> are represented.        (<strong>Default</strong> = <code>TEME()</code>)</li><li><code>ECEF</code>: ECEF frame that will be used to compute the ground trace.         (<strong>Default</strong> = <code>PEF()</code>)</li><li><code>span</code>: Defines for how much time the ground trace will be computed. The unit         is the orbit period. (<strong>Default</strong> = 1.0)</li><li><code>dt</code>: Time interval between two samples [s]. (<strong>Default</strong> = 10.0)</li></ul><p><strong>Returns</strong></p><p>A vector of tuples with the pairs <code>(latitude,longitude)</code> of the ground trace.</p></div></section></article><article class="docstring"><header><a class="docstring-binding" id="SatelliteToolbox.gtd7-Union{Tuple{NRLMSISE00_Structure{T}}, Tuple{T}} where T&lt;:Number" href="#SatelliteToolbox.gtd7-Union{Tuple{NRLMSISE00_Structure{T}}, Tuple{T}} where T&lt;:Number"><code>SatelliteToolbox.gtd7</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">function gtd7(nrlmsise00d::NRLMSISE00_Structure{T}) where T&lt;:Number</code></pre><p><strong>NRLMSISE-00</strong></p><p>Neutral Atmosphere Empirical Model from the surface to lower exosphere.</p><p>This routine computes the NRLMSISE-00 outputs (see <code>NRLMSISE00_Output</code>) using the configurations in the structure <code>nrlmsise00</code> (see <code>NRLMSISE00_Structure</code>).</p><p><strong>Args</strong></p><ul><li><code>nrlmsise00d</code>: An instance of <code>NRLMSISE00_Structure</code>.</li></ul><p><strong>Returns</strong></p><p>An instance of structure <code>NRLMSISE00_Output</code> with the outputs.</p><p>In this case, the total mass <code>den_Total</code> (see <code>NRLMSISE00_Output</code>) is the sum of the mass densities of the species <code>He</code>, <code>O</code>, <code>N₂</code>, <code>O₂</code>, <code>Ar</code>, <code>H</code>, and <code>N</code>, but <strong>does not</strong> include anomalous oxygen.</p><p><strong>Remarks</strong></p><ol><li>The densities of <code>O</code>, <code>H</code>, and <code>N</code> are set to <code>0</code> below <code>72.5 km</code>.</li><li>The exospheric temperature <code>T_exo</code> is set to global average for altitudes below <code>120 km</code>. The <code>120 km</code> gradient is left at global average value for altitudes below <code>72.5 km</code>.</li><li>Anomalous oxygen is defined as hot atomic oxygen or ionized oxygen that can become appreciable at high altitudes (<code>&gt; 500 km</code>) for some ranges of inputs, thereby affection drag on satellites and debris. We group these species under the term <strong>Anomalous Oxygen</strong>, since their individual variations are not presently separable with the drag data used to define this model component.</li></ol></div></section></article><article class="docstring"><header><a class="docstring-binding" id="SatelliteToolbox.gtd7d-Union{Tuple{NRLMSISE00_Structure{T}}, Tuple{T}} where T&lt;:Number" href="#SatelliteToolbox.gtd7d-Union{Tuple{NRLMSISE00_Structure{T}}, Tuple{T}} where T&lt;:Number"><code>SatelliteToolbox.gtd7d</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">function gtd7d(nrlmsise00d::NRLMSISE00_Structure{T}) where T&lt;:Number</code></pre><p><strong>NRLMSISE-00</strong></p><p>Neutral Atmosphere Empirical Model from the surface to lower exosphere.</p><p>This routine computes the NRLMSISE-00 outputs (see <code>NRLMSISE00_Output</code>) using the configurations in the structure <code>nrlmsise00</code> (see <code>NRLMSISE00_Structure</code>).</p><p><strong>Args</strong></p><ul><li><code>nrlmsise00d</code>: An instance of <code>NRLMSISE00_Structure</code>.</li></ul><p><strong>Returns</strong></p><p>An instance of structure <code>NRLMSISE00_Output</code> with the outputs.</p><p>In this case, the total mass <code>den_Total</code> (see <code>NRLMSISE00_Output</code>) is the effective total mass density for drag and is the sum of the mass densities of all species in this model <strong>including</strong> the anomalous oxygen.</p><p><strong>Remarks</strong></p><ol><li>The densities of <code>O</code>, <code>H</code>, and <code>N</code> are set to <code>0</code> below <code>72.5 km</code>.</li><li>The exospheric temperature <code>T_exo</code> is set to global average for altitudes below <code>120 km</code>. The <code>120 km</code> gradient is left at global average value for altitudes below <code>72.5 km</code>.</li><li>Anomalous oxygen is defined as hot atomic oxygen or ionized oxygen that can become appreciable at high altitudes (<code>&gt; 500 km</code>) for some ranges of inputs, thereby affection drag on satellites and debris. We group these species under the term <strong>Anomalous Oxygen</strong>, since their individual variations are not presently separable with the drag data used to define this model component.</li></ol></div></section></article><article class="docstring"><header><a class="docstring-binding" id="SatelliteToolbox.igrf12-NTuple{4,Number}" href="#SatelliteToolbox.igrf12-NTuple{4,Number}"><code>SatelliteToolbox.igrf12</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">function igrf12(date::Number, r::Number, λ::Number, Ω::Number, T; show_warns = true)</code></pre><p><strong>IGRF v12 Model</strong></p><p>Compute the geomagnetic field vector [nT] at the date <code>date</code> [Year A.D.] and position (<code>r</code>, <code>λ</code>, <code>Ω</code>).</p><p>The position representation is defined by <code>T</code>. If <code>T</code> is <code>Val{:geocentric}</code>, then the input must be <strong>geocentric</strong> coordinates:</p><ol><li>Distance from the Earth center <code>r</code> [m];</li><li>Geocentric latitude <code>λ</code> (-π/2, +π/2) [rad]; and</li><li>Geocentric longitude <code>Ω</code> (-π, +π) [rad].</li></ol><p>If <code>T</code> is <code>Val{:geodetic}</code>, then the input must be <strong>geodetic</strong> coordinates:</p><ol><li>Altitude above the reference ellipsoid <code>h</code> (WGS-84) [m];</li><li>Geodetic latitude <code>λ</code> (-π/2, +π/2) [rad]; and</li><li>Geodetic longitude <code>Ω</code> (-π, +π) [rad].</li></ol><p>If <code>T</code> is omitted, then it defaults to <code>Val{:geocentric}</code>.</p><p>Notice that the output vector will be represented in the same reference system selected by the parameter <code>T</code> (geocentric or geodetic). The Y-axis of the output reference system always points East. In case of <strong>geocentric coordinates</strong>, the Z-axis points toward the center of Earth and the X-axis completes a right-handed coordinate system. In case of <strong>geodetic coordinates</strong>, the X-axis is tangent to the ellipsoid at the selected location and points toward North, whereas the Z-axis completes a right-hand coordinate system.</p><p><strong>Keywords</strong></p><ul><li><code>show_warns</code>: Show warnings about the data (<strong>Default</strong> = <code>true</code>).</li></ul><p><strong>Remarks</strong></p><p>The <code>date</code> must be greater or equal to 1900 and less than or equal 2025. Notice that a warning message is printed for dates greater than 2020.</p><p><strong>Disclaimer</strong></p><p>This function is an independent implementation of the IGRF model. It contains a more readable code than the original one in FORTRAN, because it uses features available in Julia language.</p></div></section></article><article class="docstring"><header><a class="docstring-binding" id="SatelliteToolbox.igrf12syn-Tuple{Int64,Number,Int64,Number,Number,Number}" href="#SatelliteToolbox.igrf12syn-Tuple{Int64,Number,Int64,Number,Number,Number}"><code>SatelliteToolbox.igrf12syn</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">function igrf12syn(isv::Int, date::Number, itype::Int, alt::Number, colat::Number, elong::Number; show_warns = true)</code></pre><p>This is a Julia implementation of the official IGRF source code, which was written in Fortran [2]. The input and output variables are exactly the same as the ones described in the function <code>igrf12syn</code> in [2].</p><p><strong>Args</strong></p><ul><li><code>isv</code>: <code>0</code> if main-field values are required, <code>1</code> if secular variation values        are required.</li><li><code>date</code>: Year A.D.</li><li><code>itype</code>: <code>1</code> if geodetic (spheroid), <code>2</code> if geocentric (sphere).</li><li><code>alt</code>: Height above sea level [km] if <code>itype = 1</code>, or distance from the center of        Earth [km] if <code>itype = 2</code> (must be &gt; 3485 km).</li><li><code>colat</code>: Colatitude (0 - 180) [˚].</li><li><code>elong</code>: East-Longitude (0 - 360) [˚].</li></ul><p><strong>Keywords</strong></p><ul><li><code>show_warns</code>: Show warnings about the data (<strong>Default</strong> = <code>true</code>).</li></ul><p><strong>Returns</strong></p><ul><li>The north component [nT] if <code>isv = 0</code>, or [nT/year] if <code>isv = 1</code>.</li><li>The east component [nT] if <code>isv = 0</code>, or [nT/year] if <code>isv = 1</code>.</li><li>The vertical component [nT] if <code>isv = 0</code>, or [nT/year] if <code>isv = 1</code>.</li><li>The total intensity if <code>isv = 0</code>, or rubbish if <code>isv = 1</code>.</li></ul><p><strong>Remarks</strong></p><ul><li>The <code>date</code> must be greater or equal to 1900 and less than or equal 2025.</li></ul><p>Notice that a warning message is printed for dates grated than 2020.</p></div></section></article><article class="docstring"><header><a class="docstring-binding" id="SatelliteToolbox.init_orbit_propagator" href="#SatelliteToolbox.init_orbit_propagator"><code>SatelliteToolbox.init_orbit_propagator</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">function init_orbit_propagator(T, tle::TLE, ...)</code></pre><p>Initialize the orbit propagator <code>T</code> using the TLE <code>tle</code>. The propagator type <code>T</code> can be:</p><ul><li><code>Val{:J2}</code>: J2 orbit propagator;</li><li><code>Val{:J4}</code>: J4 orbit propagator;</li><li><code>Val{:twobody}</code>: Two-body orbit propagator; or</li><li><code>Val{:sgp4}</code>: SGP4 orbit propagator.</li></ul><p><strong>Additional optional arguments for the J2 orbit propagator</strong></p><p>The initialization function of the J2 orbit propagator can receive the following optional parameter:</p><ul><li><code>j2_gc</code>: (OPTIONAL) J2 orbit propagator gravitational constants          (<strong>Default</strong> = <code>j2_gc_egm08</code>).</li></ul><p><strong>Additional optional arguments for the J4 orbit propagator</strong></p><p>The initialization function of the J4 orbit propagator can receive the following optional parameter:</p><ul><li><code>j4_gc</code>: (OPTIONAL) J4 orbit propagator gravitational constants          (<strong>Default</strong> = <code>j4_gc_egm08</code>).</li></ul><p><strong>Additional optional arguments for the two body orbit propagator</strong></p><p>The initialization function of the two body orbit propagator can receive the following optional parameter:</p><ul><li><code>μ</code>: (OPTIONAL) Standard gravitational parameter of the central body      [m^3/s^2] (<strong>Default</strong> = <code>m0</code>).</li></ul><p><strong>Additional optional arguments for the SGP4 orbit propagator</strong></p><p>The initialization function of the SGP4 orbit propagator can receive the following optional parameter:</p><ul><li><code>sgp4_gc</code>: (OPTIONAL) Gravitational constants (<strong>Default</strong> = <code>sgp4_gc_wgs84</code>).</li></ul><p><strong>Returns</strong></p><p>A new instance of the orbit propagator structure that stores the information of the orbit propagator.</p><p><strong>Remarks</strong></p><p>The SGP4 implementation includes also the deep space perturbations, which was originally called SDP4 algorithm. Modern approaches, such as [2] and [3], identifies if the selected orbit must be propagated using the deep space perturbations and automatically applied them. This is sometimes called SGDP4 algorithm.</p></div></section></article><article class="docstring"><header><a class="docstring-binding" id="SatelliteToolbox.init_orbit_propagator-Union{Tuple{T}, Tuple{Type{Val{:J2}},Number,Number,Number,Number,Number,Number,Number}, Tuple{Type{Val{:J2}},Number,Number,Number,Number,Number,Number,Number,Number}, Tuple{Type{Val{:J2}},Number,Number,Number,Number,Number,Number,Number,Number,Number}, Tuple{Type{Val{:J2}},Number,Number,Number,Number,Number,Number,Number,Number,Number,J2_GravCte{T}}} where T" href="#SatelliteToolbox.init_orbit_propagator-Union{Tuple{T}, Tuple{Type{Val{:J2}},Number,Number,Number,Number,Number,Number,Number}, Tuple{Type{Val{:J2}},Number,Number,Number,Number,Number,Number,Number,Number}, Tuple{Type{Val{:J2}},Number,Number,Number,Number,Number,Number,Number,Number,Number}, Tuple{Type{Val{:J2}},Number,Number,Number,Number,Number,Number,Number,Number,Number,J2_GravCte{T}}} where T"><code>SatelliteToolbox.init_orbit_propagator</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">function init_orbit_propagator(T, epoch::Number, a_0::Number, e_0::Number, i_0::Number, Ω_0::Number, ω_0::Number, f_0::Number, ...)
function init_orbit_propagator(T, orb_0::Orbit, ...)</code></pre><p>Initialize the orbit propagator <code>T</code> using the initial mean orbital elements. The propagator type <code>T</code> can be:</p><ul><li><code>Val{:J2}</code>: J2 orbit propagator;</li><li><code>Val{:J4}</code>: J4 orbit propagator; or</li><li><code>Val{:twobody}</code>: Two-body orbit propagator.</li></ul><p>The mean orbital elements can be passed individually of using an instance of the structure <code>Orbit</code>.</p><p><strong>Args</strong></p><ul><li><code>epoch</code>: Initial orbit epoch [Julian Day].</li><li><code>a_0</code>: Initial semi-major axis [m].</li><li><code>e_0</code>: Initial eccentricity.</li><li><code>i_0</code>: Initial inclination [rad].</li><li><code>Ω_0</code>: Initial right ascension of the ascending node [rad].</li><li><code>ω_0</code>: Initial argument of perigee [rad].</li><li><code>f_0</code>: Initial true anomaly [rad].</li><li><code>n_0</code>: Initial angular velocity [rad/s].</li><li><code>M_0</code>: Initial mean anomaly [rad].</li><li><code>orb_0</code>: Instance of the structure <code>Orbit</code> with the initial mean orbital          elements [SI].</li></ul><p><strong>Additional optional arguments for the J2 orbit propagator</strong></p><p>The initialization function of the J2 orbit propagator can receive the following optional parameters:</p><ul><li><code>dn_o2</code>: (OPTIONAL) First time derivative of mean motion divided by 2          [rad/s²] (<strong>Default</strong> = 0).</li><li><code>ddn_o6</code>: (OPTIONAL) Second time derivative of mean motion divided by 6           [rad/s³] (<strong>Default</strong> = 0).</li><li><code>j2_gc</code>: (OPTIONAL) J2 orbit propagator gravitational constants          (<strong>Default</strong> = <code>j2_gc_egm08</code>).</li></ul><p><strong>Additional optional arguments for the J4 orbit propagator</strong></p><p>The initialization function of the J4 orbit propagator can receive the following optional parameters:</p><ul><li><code>dn_o2</code>: (OPTIONAL) First time derivative of mean motion divided by 2          [rad/s²] (<strong>Default</strong> = 0).</li><li><code>ddn_o6</code>: (OPTIONAL) Second time derivative of mean motion divided by 6           [rad/s³] (<strong>Default</strong> = 0).</li><li><code>j4_gc</code>: (OPTIONAL) J4 orbit propagator gravitational constants          (<strong>Default</strong> = <code>j4_gc_egm08</code>).</li></ul><p><strong>Additional optional arguments for the two body orbit propagator</strong></p><p>The initialization function of the two body orbit propagator can receive the following optional parameter:</p><ul><li><code>μ</code>: (OPTIONAL) Standard gravitational parameter of the central body      [m^3/s^2] (<strong>Default</strong> = <code>m0</code>).</li></ul><p><strong>Returns</strong></p><p>A new instance of the orbit propagator structure that stores the information of the orbit propagator.</p><p><strong>Remarks</strong></p><p>If the orbit is defined in terms of the angular velocity (mean motion) instead of the semi-major axis, then it is possible to use the function <code>angvel_to_a</code> to convert.</p></div></section></article><article class="docstring"><header><a class="docstring-binding" id="SatelliteToolbox.init_space_indices-Tuple{}" href="#SatelliteToolbox.init_space_indices-Tuple{}"><code>SatelliteToolbox.init_space_indices</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">function init_space_indices(...)</code></pre><p>Initialize all space indices. The files that will be initialized must be indicated by the array of symbols passed to the keyword argument <code>enabled_files</code>. If this is <code>nothing</code>, which is the default, then all files will be initialized. The symbol related to each file is described next.</p><p>Notice that the initialization process can be changed by a set of keywords as described next.</p><p><strong>DTCFILE</strong></p><p><strong>Symbol</strong>: <code>:dtcfile</code></p><p>This file contains the exospheric temperature variation caused by the Dst index. This is used for the JB2008 atmospheric model.</p><p><strong>Keywords</strong></p><ul><li><code>dtcfile_path</code>: Path for the file <code>DTCFILE.TXT</code>. If <code>nothing</code>, then it will be                 downloaded. (<strong>Default</strong> = <code>nothing</code>)</li><li><code>dtcfile_force_download</code>: If <code>true</code>, then the file will always be downloaded                           if the path is not specified. (<strong>Default</strong> =                           <code>false</code>).</li></ul><p><strong>fluxtable</strong></p><p><strong>Symbol</strong>: <code>:fluxtable</code></p><p>This file contains the F10.7 flux data in different formats.</p><p><strong>Keywords</strong></p><ul><li><code>fluxtable_path</code>: Path for the file <code>fluxtable.txt</code>. If <code>nothing</code>, then it                   will be downloaded. (<strong>Default</strong> = <code>nothing</code>)</li><li><code>fluxtable_force_download</code>: If <code>true</code>, then the file will always be downloaded                             if the path is not specified.                             (<strong>Default</strong> = <code>false</code>).</li></ul><p><strong>SOLFSMY</strong></p><p><strong>Symbol</strong>: <code>:solfsmy</code></p><p>This files contains the indices necessary for the JB2008 atmospheric model.</p><p><strong>Keywords</strong></p><ul><li><code>solfsmy_path</code>: Path for the file <code>SOLFSMY.TXT</code>. If <code>nothing</code>, then it will be                 downloaded. (<strong>Default</strong> = <code>nothing</code>)</li><li><code>solfsmy_force_download</code>: If <code>true</code>, then the file will always be downloaded                           if the path is not specified. (<strong>Default</strong> =                           <code>false</code>).</li></ul><p><strong>WDC Files</strong></p><p><strong>Symbol</strong>: <code>:wdcfiles</code></p><p>This set of files contain the Kp and Ap indices.</p><p><strong>Keywords</strong></p><ul><li><code>wdcfiles_path</code>: Path for the directory with the WDC files. If <code>nothing</code>, then                  they will be downloaded. (<strong>Default</strong> = <code>nothing</code>)</li><li><code>wdcfiles_force_download</code>: If <code>true</code>, then the files will always be downloaded                           if the path is not specified. (<strong>Default</strong> =                           <code>false</code>).</li><li><code>wdcfiles_oldest_year</code>: Oldest year in which the WDC file will be obtained.                         (<strong>Default</strong> = past 3 years).</li><li><code>wdcfiles_newest_year</code>: Newest year in which the WDC file will be obtained. If                         it is <code>nothing</code>, then it defaults to the current year.                         (<strong>Default</strong> = <code>nothing</code>).</li></ul></div></section></article><article class="docstring"><header><a class="docstring-binding" id="SatelliteToolbox.is_leap_year-Tuple{Int64}" href="#SatelliteToolbox.is_leap_year-Tuple{Int64}"><code>SatelliteToolbox.is_leap_year</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">function is_leap_year(year::Int)</code></pre><p>Check if the year <code>year</code> is a leap year. It returns <code>true</code> if <code>year</code> is a leap year, or <code>false</code> otherwise.</p><p><strong>Remarks</strong></p><p>This algorithm was based on [3].</p></div></section></article><article class="docstring"><header><a class="docstring-binding" id="SatelliteToolbox.j2!-Union{Tuple{T}, Tuple{J2_Structure{T},Number}} where T" href="#SatelliteToolbox.j2!-Union{Tuple{T}, Tuple{J2_Structure{T},Number}} where T"><code>SatelliteToolbox.j2!</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">function j2!(j2d::J2_Structure{T}, t::Number) where T</code></pre><p>Propagate the orbit defined in <code>j2d</code> (see <code>J2_Structure</code>) until the time <code>t</code> [s]. Notice that the values in <code>j2d</code> will be modified.</p><p><strong>Returns</strong></p><ul><li>The position vector represented in the inertial frame at time <code>t</code> [m].</li><li>The velocity vector represented in the inertial frame at time <code>t</code> [m/s]</li></ul><p><strong>Remarks</strong></p><p>The inertial frame in which the output is represented depends on which frame it was used to generate the orbit parameters. If the orbit parameters are obtained from a TLE, then the inertial frame will be TEME. Notice, however, that the perturbation theory requires an inertial frame with true equator.</p></div></section></article><article class="docstring"><header><a class="docstring-binding" id="SatelliteToolbox.j2_init-Union{Tuple{T}, Tuple{J2_GravCte{T},Number,Number,Number,Number,Number,Number,Number,Number,Number}} where T" href="#SatelliteToolbox.j2_init-Union{Tuple{T}, Tuple{J2_GravCte{T},Number,Number,Number,Number,Number,Number,Number,Number,Number}} where T"><code>SatelliteToolbox.j2_init</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">function j2_init(j2_gc::J2_GravCte{T}, epoch::Number, a_0::Number, e_0::Number, i_0::Number, Ω_0::Number, ω_0::Number, f_0::Number, dn_o2::Number, ddn_o6::Number) where T</code></pre><p>Initialize the data structure of J2 orbit propagator algorithm.</p><p><strong>Args</strong></p><ul><li><code>j2_gc</code>: J2 orbit propagator gravitational constants (see <code>J2_GravCte</code>).</li><li><code>epoch</code>: Epoch of the orbital elements [Julian Day].</li><li><code>a_0</code>: Initial semi-major axis [m].</li><li><code>e_0</code>: Initial eccentricity.</li><li><code>i_0</code>: Initial inclination [rad].</li><li><code>Ω_0</code>: Initial right ascension of the ascending node [rad].</li><li><code>ω_0</code>: Initial argument of perigee [rad].</li><li><code>f_0</code>: Initial true anomaly [rad].</li><li><code>dn_o2</code>: First time derivative of the mean motion divided by two [rad/s^2].</li><li><code>ddn_o6</code>: Second time derivative of the mean motion divided by six [rad/s^3].</li></ul><p><strong>Returns</strong></p><p>The structure <code>J2_Structure</code> with the initialized parameters.</p><p><strong>Remarks</strong></p><p>The inputs are the mean orbital elements.</p></div></section></article><article class="docstring"><header><a class="docstring-binding" id="SatelliteToolbox.j4!-Union{Tuple{T}, Tuple{J4_Structure{T},Number}} where T" href="#SatelliteToolbox.j4!-Union{Tuple{T}, Tuple{J4_Structure{T},Number}} where T"><code>SatelliteToolbox.j4!</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">function j4!(j4d::J4_Structure{T}, t::Number) where T</code></pre><p>Propagate the orbit defined in <code>j4d</code> (see <code>J4_Structure</code>) until the time <code>t</code> [s]. Notice that the values in <code>j4d</code> will be modified.</p><p><strong>Returns</strong></p><ul><li>The position vector represented in the inertial frame at time <code>t</code> [m].</li><li>The velocity vector represented in the inertial frame at time <code>t</code> [m/s]</li></ul><p><strong>Remarks</strong></p><p>The inertial frame in which the output is represented depends on which frame it was used to generate the orbit parameters. If the orbit parameters are obtained from a TLE, then the inertial frame will be TEME. Notice, however, that the perturbation theory requires an inertial frame with true equator.</p></div></section></article><article class="docstring"><header><a class="docstring-binding" id="SatelliteToolbox.j4_init-Union{Tuple{T}, Tuple{J4_GravCte{T},Number,Number,Number,Number,Number,Number,Number,Number,Number}} where T" href="#SatelliteToolbox.j4_init-Union{Tuple{T}, Tuple{J4_GravCte{T},Number,Number,Number,Number,Number,Number,Number,Number,Number}} where T"><code>SatelliteToolbox.j4_init</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">function j4_init(j4_gc::J4_GravCte{T}, epoch::Number, n_0::Number, e_0::Number, i_0::Number, Ω_0::Number, ω_0::Number, M_0::Number) where T</code></pre><p>Initialize the data structure of J4 orbit propagator algorithm.</p><p><strong>Args</strong></p><ul><li><code>j4_gc</code>: J4 orbit propagator gravitational constants (see <code>J4_GravCte</code>).</li><li><code>epoch</code>: Epoch of the orbital elements [Julian Day].</li><li><code>a_0</code>: Initial semi-major axis [m].</li><li><code>e_0</code>: Initial eccentricity.</li><li><code>i_0</code>: Initial inclination [rad].</li><li><code>Ω_0</code>: Initial right ascension of the ascending node [rad].</li><li><code>ω_0</code>: Initial argument of perigee [rad].</li><li><code>f_0</code>: Initial true anomaly [rad].</li><li><code>dn_o2</code>: First time derivative of the mean motion divided by two [rad/s^2].</li><li><code>ddn_o6</code>: Second time derivative of the mean motion divided by six [rad/s^3].</li></ul><p><strong>Returns</strong></p><p>The structure <code>J4_Structure</code> with the initialized parameters.</p><p><strong>Remarks</strong></p><p>The inputs are the mean orbital elements.</p></div></section></article><article class="docstring"><header><a class="docstring-binding" id="SatelliteToolbox.jb2008-NTuple{4,Number}" href="#SatelliteToolbox.jb2008-NTuple{4,Number}"><code>SatelliteToolbox.jb2008</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">function jb2008(JD::Number, glat::Number, glon::Number, h::Number)
function jb2008(JD::Number, glat::Number, glon::Number, h::Number, F10::Number, F10ₐ::Number, S10::Number, S10ₐ::Number, M10::Number, M10ₐ::Number, Y10::Number, Y10ₐ::Number, DstΔTc::Number)</code></pre><p>Compute the atmospheric density using the Jacchia-Bowman 2008 (JB2008) model.</p><p>If the space indices are not provided (first call), then they will be obtained from the online database. In this case, the function <code>init_space_indices()</code> must be called first and the function will throw an exception if the selected <code>JD</code> is outside of the available data.</p><p>This model is a product of the <strong>Space Environment Technologies</strong>, more information can be seen in the websites:</p><p>http://sol.spacenvironment.net/jb2006/</p><p>http://sol.spacenvironment.net/jb2008/</p><p><strong>Args</strong></p><ul><li><p><code>JD</code>: Julian day.</p></li><li><p><code>glat</code>: Geocentric latitude [rad].</p></li><li><p><code>glon</code>: Geocentric longitude [rad].</p></li><li><p><code>h</code>: Altitude [m].</p></li><li><p><code>F10</code>: 10.7-cm solar flux [10⁻²² W/(M² Hz)] (Tabular time 1 day earlier).</p></li><li><p><code>F10ₐ</code>: 10.7-cm averaged solar flux, 81-day centered on input time (Tabular         time 1 day earlier).</p></li><li><p><code>S10</code>: EUV index (26-34 nm) scaled to F10.7 (Tabular time 1 day earlier).</p></li><li><p><code>S10ₐ</code>: EUV 81-day averaged centered index (Tabular time 1 day earlier).</p></li><li><p><code>M10</code>: MG2 index scaled to F10.7 (Tabular time 2 days earlier).</p></li><li><p><code>M10ₐ</code>: MG2 81-day averaged centered index (Tabular time 2 days earlier).</p></li><li><p><code>Y10</code>: Solar X-ray &amp; Lya index scaled to F10.7 (Tabular time 5 days earlier).</p></li><li><p><code>Y10ₐ</code>: Solar X-ray &amp; Lya 81-day averaged centered index (Tabular time 5 days         earlier).</p></li><li><p><code>DstΔTc</code>: Temperature variation related to the Dst.</p></li></ul><p><strong>Returns</strong></p><p>An instance of the structure <code>JB2008_Output</code> with the computed values.</p></div></section></article><article class="docstring"><header><a class="docstring-binding" id="SatelliteToolbox.jr1971-NTuple{7,Number}" href="#SatelliteToolbox.jr1971-NTuple{7,Number}"><code>SatelliteToolbox.jr1971</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">function jr1971(JD::Number, glat::Number, glon::Number, h::Number, F10::Number, F10ₐ::Number, Kp::Number)</code></pre><p>Compute the atmospheric density using the Jacchia-Roberts 1971 model.</p><p><strong>Args</strong></p><ul><li><code>JD</code>: Julian day.</li><li><code>glat</code>: Geodetic latitude [rad].</li><li><code>glon</code>: Geodetic longitude [rad].</li><li><code>h</code>: Altitude [m].</li><li><code>F10</code>: 10.7-cm solar flux [10⁻²² W/(M² Hz)].</li><li><code>F10ₐ</code>: 10.7-cm averaged solar flux, 81-day centered on input time.</li><li><code>Kp</code>: Kp geomagnetic index (with a delay of 3 hours).</li></ul><p><strong>Returns</strong></p><p>An instance of the structure <code>JR1971_Output</code> with the computed values.</p></div></section></article><article class="docstring"><header><a class="docstring-binding" id="SatelliteToolbox.kepler_to_rv-NTuple{6,Number}" href="#SatelliteToolbox.kepler_to_rv-NTuple{6,Number}"><code>SatelliteToolbox.kepler_to_rv</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">function kepler_to_rv(a::Number, e::Number, i::Number, Ω::Number, ω::Number, f::Number)
function kepler_to_rv(o::Orbit)</code></pre><p>Convert the Keplerian elements (<code>a</code>, <code>e</code>, <code>i</code>, <code>Ω</code>, <code>ω</code>, and <code>f</code>) to a Cartesian representation (position vector <code>r</code> and velocity vector <code>v</code>). The Keplerian elements can also be passed inside an instance of the <code>Orbit</code> structure.</p><p><strong>Args</strong></p><ul><li><code>a</code>: Semi-major axis [m].</li><li><code>e</code>: Excentricity.</li><li><code>i</code>: Inclination [rad].</li><li><code>Ω</code>: Right ascension of the ascending node [rad].</li><li><code>ω</code>: Argument of perigee [rad].</li><li><code>f</code>: True anomaly [rad].</li></ul><p><strong>Returns</strong></p><ul><li>The position vector represented in the inertial reference frame [m].</li><li>The velocity vector represented in the inertial reference frame [m].</li></ul><p><strong>References</strong></p><p>This algorithm was adapted from [1] and [3, p. 37-38].</p></div></section></article><article class="docstring"><header><a class="docstring-binding" id="SatelliteToolbox.kepler_to_sv-Tuple{Orbit}" href="#SatelliteToolbox.kepler_to_sv-Tuple{Orbit}"><code>SatelliteToolbox.kepler_to_sv</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">function kepler_to_sv(orb::Orbit)</code></pre><p>Convert the Keplerian elements in the structure <code>orb</code> to a state vector.</p></div></section></article><article class="docstring"><header><a class="docstring-binding" id="SatelliteToolbox.legendre" href="#SatelliteToolbox.legendre"><code>SatelliteToolbox.legendre</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">function legendre([N,] ϕ::Number, n_max::Integer, m_max::Integer = -1, ph_term::Bool = false)</code></pre><p>Compute the associated Legendre function <code>P_n,m[cos(ϕ)]</code>. The maximum degree that will be computed is <code>n_max</code> and the maximum order is <code>m_max</code>. Notice that if <code>m_max</code> is higher than <code>n_max</code> or negative, than it is set to <code>n_max</code>.</p><p>The optional parameter <code>N</code> can be used to select the normalization. The following values are valid:</p><ul><li><code>Val{:full}</code>: Compute the fully normalized associated Legendre function (see <code>legendre_fully_normalized</code>).</li><li><code>Val{:schmidt}</code>: Compute the Schmidt quasi-normalized associated Legendre function (see <code>legendre_schmidt_quasi_normalized</code>).</li><li><code>Val{:conv}</code>: Compute the conventional associated Legendre function (see <code>legendre_conventional</code>).</li></ul><p>If <code>N</code> is omitted, then the full normalization will be used (<code>Val{:full}</code>).</p><p>If <code>ph_term</code> is set to <code>true</code>, then the Condon-Shortley phase term <code>(-1)ᵐ</code> will be included. If <code>ph_term</code> is not present, then it defaults to <code>false</code>.</p><p><strong>Returns</strong></p><p>A matrix with the Legendre associated functions <code>P_n,m[cos(ϕ)]</code>.</p></div></section></article><article class="docstring"><header><a class="docstring-binding" id="SatelliteToolbox.legendre!" href="#SatelliteToolbox.legendre!"><code>SatelliteToolbox.legendre!</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">function legendre!([N,] P::AbstractMatrix, ϕ::Number, ph_term::Bool = false)</code></pre><p>Compute the associated Legendre function <code>P_n,m[cos(ϕ)]</code>. The maximum degree and order that will be computed are given by the dimensions of matrix <code>P</code>.</p><p>The result will be stored at matrix <code>P</code>.</p><p>The optional parameter <code>N</code> can be used to select the normalization. The following values are valid:</p><ul><li><code>Val{:full}</code>: Compute the fully normalized associated Legendre function (see <code>legendre_fully_normalized!</code>).</li><li><code>Val{:schmidt}</code>: Compute the Schmidt quasi-normalized associated Legendre function (see <code>legendre_schmidt_quasi_normalized!</code>).</li><li><code>Val{:conv}</code>: Compute the conventional associated Legendre function (see <code>legendre_conventional!</code>).</li></ul><p>If <code>N</code> is omitted, then the full normalization will be used.</p><p>If <code>ph_term</code> is set to <code>true</code>, then the Condon-Shortley phase term <code>(-1)ᵐ</code> will be included. If <code>ph_term</code> is not present, then it defaults to <code>false</code>.</p></div></section></article><article class="docstring"><header><a class="docstring-binding" id="SatelliteToolbox.legendre_conventional!" href="#SatelliteToolbox.legendre_conventional!"><code>SatelliteToolbox.legendre_conventional!</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">function legendre_conventional!(P::AbstractMatrix, ϕ::Number, ph_term::Bool = false)</code></pre><p>Compute the conventional associated Legendre function <code>P_n,m[cos(ϕ)]</code>. The maximum degree and order that will be computed are given by the dimensions of matrix <code>P</code>:</p><pre><code class="language-none">maximum degree -&gt; number of rows
maximum order  -&gt; number of columns</code></pre><p>The result will be stored at matrix <code>P</code>.</p><p>If <code>ph_term</code> is set to <code>true</code>, then the Condon-Shortley phase term <code>(-1)ᵐ</code> will be included. If <code>ph_term</code> is not present, then it defaults to <code>false</code>.</p></div></section></article><article class="docstring"><header><a class="docstring-binding" id="SatelliteToolbox.legendre_conventional-Union{Tuple{T}, Tuple{T,Integer}, Tuple{T,Integer,Integer}, Tuple{T,Integer,Integer,Bool}} where T&lt;:AbstractFloat" href="#SatelliteToolbox.legendre_conventional-Union{Tuple{T}, Tuple{T,Integer}, Tuple{T,Integer,Integer}, Tuple{T,Integer,Integer,Bool}} where T&lt;:AbstractFloat"><code>SatelliteToolbox.legendre_conventional</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">function legendre_conventional(ϕ::T, n_max::Integer, m_max::Integer = -1, ph_term::Bool = false) where T&lt;:AbstractFloat</code></pre><p>Compute the conventional associated Legendre function <code>P_n,m[cos(ϕ)]</code>. The maximum degree that will be computed is <code>n_max</code> and the maximum order is <code>m_max</code>. Notice that if <code>m_max</code> is higher than <code>n_max</code> or negative, than it is set to <code>n_max</code>.</p><p>If <code>ph_term</code> is set to <code>true</code>, then the Condon-Shortley phase term <code>(-1)ᵐ</code> will be included. If <code>ph_term</code> is not present, then it defaults to <code>false</code>.</p><p><strong>Returns</strong></p><p>A matrix with the Legendre associated functions <code>P_n,m[cos(ϕ)]</code>.</p></div></section></article><article class="docstring"><header><a class="docstring-binding" id="SatelliteToolbox.legendre_fully_normalized!" href="#SatelliteToolbox.legendre_fully_normalized!"><code>SatelliteToolbox.legendre_fully_normalized!</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">function legendre_fully_normalized!(P::AbstractMatrix, ϕ::Number, ph_term::Bool = false)</code></pre><p>Compute the fully normalized associated Legendre function <code>P_n,m[cos(ϕ)]</code>. The maximum degree and order that will be computed are given by the dimensions of matrix <code>P</code>:</p><pre><code class="language-none">maximum degree -&gt; number of rows
maximum order  -&gt; number of columns</code></pre><p>The result will be stored at matrix <code>P</code>.</p><p>If <code>ph_term</code> is set to <code>true</code>, then the Condon-Shortley phase term <code>(-1)ᵐ</code> will be included. If <code>ph_term</code> is not present, then it defaults to <code>false</code>.</p><p><strong>Remarks</strong></p><p>This algorithm was based on [1]. Our definition of fully normalized associated Legendre function can be seen in [2, p. 546]. The conversion is obtained by:</p><pre><code class="language-none">             _                     -
            |  (n-m)! . k . (2n+1)  |      k = 1 if m  = 0
K_n,m = sqrt| --------------------- |,     k = 2 if m != 0
            |         (n+m)!        |
             -                     -
_
P_n,m = P_n,m * K_n,m,

      _
where P_n,m is the fully normalized Legendre associated function.</code></pre></div></section></article><article class="docstring"><header><a class="docstring-binding" id="SatelliteToolbox.legendre_fully_normalized-Union{Tuple{T}, Tuple{T,Integer}, Tuple{T,Integer,Integer}, Tuple{T,Integer,Integer,Bool}} where T&lt;:AbstractFloat" href="#SatelliteToolbox.legendre_fully_normalized-Union{Tuple{T}, Tuple{T,Integer}, Tuple{T,Integer,Integer}, Tuple{T,Integer,Integer,Bool}} where T&lt;:AbstractFloat"><code>SatelliteToolbox.legendre_fully_normalized</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">function legendre_fully_normalized(ϕ::T, n_max::Integer, m_max::Integer = -1, ph_term::Bool = false) where T&lt;:AbstractFloat</code></pre><p>Compute the fully normalized associated Legendre function <code>P_n,m[cos(ϕ)]</code>. The maximum degree that will be computed is <code>n_max</code> and the maximum order is <code>m_max</code>. Notice that if <code>m_max</code> is higher than <code>n_max</code> or negative, than it is set to <code>n_max</code>.</p><p>If <code>ph_term</code> is set to <code>true</code>, then the Condon-Shortley phase term <code>(-1)ᵐ</code> will be included. If <code>ph_term</code> is not present, then it defaults to <code>false</code>.</p><p><strong>Returns</strong></p><p>A matrix with the Legendre associated functions <code>P_n,m[cos(ϕ)]</code>.</p><p><strong>Remarks</strong></p><p>This algorithm was based on [1]. Our definition of fully normalized associated Legendre function can be seen in [2, p. 546]. The conversion is obtained by:</p><pre><code class="language-none">             _                     -
            |  (n-m)! . k . (2n+1)  |      k = 1 if m  = 0
K_n,m = sqrt| --------------------- |,     k = 2 if m != 0
            |         (n+m)!        |
             -                     -
_
P_n,m = P_n,m * K_n,m,

      _
where P_n,m is the fully normalized Legendre associated function.</code></pre></div></section></article><article class="docstring"><header><a class="docstring-binding" id="SatelliteToolbox.legendre_schmidt_quasi_normalized!" href="#SatelliteToolbox.legendre_schmidt_quasi_normalized!"><code>SatelliteToolbox.legendre_schmidt_quasi_normalized!</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">function legendre_schmidt_quasi_normalized!(P::AbstractMatrix, ϕ::Number, ph_term::Bool = false)</code></pre><p>Compute the Schmidt quasi-normalized associated Legendre function <code>P_n,m[cos(ϕ)]</code> [3,4]. The maximum degree and order that will be computed are given by the dimensions of matrix <code>P</code>:</p><pre><code class="language-none">maximum degree -&gt; number of rows
maximum order  -&gt; number of columns</code></pre><p>The result will be stored at matrix <code>P</code>.</p><p>If <code>ph_term</code> is set to <code>true</code>, then the Condon-Shortley phase term <code>(-1)ᵐ</code> will be included. If <code>ph_term</code> is not present, then it defaults to <code>false</code>.</p><p><strong>Remarks</strong></p><p>This algorithm was based on [3,4]. The conversion is obtained by:</p><pre><code class="language-none">             _           -
            |     (n-m)!  |    k = 1 if m  = 0
K_n,m = sqrt| k. -------- |,   k = 2 if m != 0
            |     (n+m)!  |
             -           -

=
P_n,m = P_n,m * K_n,m,

      =
where P_n,m is the quasi-normalized normalized Legendre associated function.</code></pre></div></section></article><article class="docstring"><header><a class="docstring-binding" id="SatelliteToolbox.legendre_schmidt_quasi_normalized-Union{Tuple{T}, Tuple{T,Integer}, Tuple{T,Integer,Integer}, Tuple{T,Integer,Integer,Bool}} where T&lt;:AbstractFloat" href="#SatelliteToolbox.legendre_schmidt_quasi_normalized-Union{Tuple{T}, Tuple{T,Integer}, Tuple{T,Integer,Integer}, Tuple{T,Integer,Integer,Bool}} where T&lt;:AbstractFloat"><code>SatelliteToolbox.legendre_schmidt_quasi_normalized</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">function legendre_schmidt_quasi_normalized(ϕ::T, n_max::Integer, m_max::Integer = -1, ph_term::Bool = false) where T&lt;:AbstractFloat</code></pre><p>Compute the Schmidt quasi-normalized associated Legendre function <code>P_n,m[cos(ϕ)]</code>. The maximum degree that will be computed is <code>n_max</code> and the maximum order is <code>m_max</code>. Notice that if <code>m_max</code> is higher than <code>n_max</code> or negative, than it is set to <code>n_max</code>.</p><p>If <code>ph_term</code> is set to <code>true</code>, then the Condon-Shortley phase term <code>(-1)ᵐ</code> will be included. If <code>ph_term</code> is not present, then it defaults to <code>false</code>.</p><p><strong>Returns</strong></p><p>A matrix with the Legendre associated functions <code>P_n,m[cos(ϕ)]</code>.</p><p><strong>Remarks</strong></p><p>This algorithm was based on [3,4]. The conversion is obtained by:</p><pre><code class="language-none">             _           -
            |     (n-m)!  |    k = 1 if m  = 0
K_n,m = sqrt| k. -------- |,   k = 2 if m != 0
            |     (n+m)!  |
             -           -

=
P_n,m = P_n,m * K_n,m,

      =
where P_n,m is the quasi-normalized normalized Legendre associated function.</code></pre></div></section></article><article class="docstring"><header><a class="docstring-binding" id="SatelliteToolbox.list_ground_station_accesses-Tuple" href="#SatelliteToolbox.list_ground_station_accesses-Tuple"><code>SatelliteToolbox.list_ground_station_accesses</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">function list_ground_station_accesses(io, vargs...; kwargs...)</code></pre><p>Print the ground station accesses to the io <code>io</code>. The arguments <code>vargs...</code> and keywords <code>kwargs...</code> are those of the function <code>ground_station_accesses</code>.</p><p>Additionally, the following keywords can be used to modify the behavior of this function:</p><ul><li><code>format</code>: If <code>:pretty</code>, then a formatted table will be printed. If <code>:csv</code>,           then the access data will be printed using the CSV format.           (<strong>Default</strong> = <code>:pretty</code>)</li><li><code>time_scale</code>: Select the time scale of the access duration (<code>:s</code> for seconds,               <code>:m</code> for minutes, and <code>:h</code> for hours). (<strong>Default</strong> = <code>:m</code>)</li></ul></div></section></article><article class="docstring"><header><a class="docstring-binding" id="SatelliteToolbox.list_ground_station_gaps-Tuple" href="#SatelliteToolbox.list_ground_station_gaps-Tuple"><code>SatelliteToolbox.list_ground_station_gaps</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">function list_ground_station_gaps(io, vargs...; kwargs...)</code></pre><p>Print the ground station gaps to the io <code>io</code>. The arguments <code>vargs...</code> and keywords <code>kwargs...</code> are those of the function <code>ground_station_gaps</code>.</p><p>Additionally, the following keywords can be used to modify the behavior of this function:</p><ul><li><code>format</code>: If <code>:pretty</code>, then a formatted table will be printed. If <code>:csv</code>,           then the access data will be printed using the CSV format.           (<strong>Default</strong> = <code>:pretty</code>)</li><li><code>time_scale</code>: Select the time scale of the access duration (<code>:s</code> for seconds,               <code>:m</code> for minutes, and <code>:h</code> for hours). (<strong>Default</strong> = <code>:m</code>)</li></ul></div></section></article><article class="docstring"><header><a class="docstring-binding" id="SatelliteToolbox.list_ss_orbits_by_rep_period" href="#SatelliteToolbox.list_ss_orbits_by_rep_period"><code>SatelliteToolbox.list_ss_orbits_by_rep_period</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">function list_ss_orbits_by_rep_period(minRep::Int, maxRep::Int, minAlt::Number=-1.0, maxAlt::Number=-1.0, e::Number=0.0)</code></pre><p>Compute a list of repeating Sun-synchronous orbits.</p><p><strong>Args</strong></p><ul><li><code>minRep</code>: Minimum repetition time of the orbit [days].</li><li><code>maxRep</code>: Maximum repetition time of the orbit [days].</li><li><code>minAlt</code>: Minimum altitude of the orbits on the list [m].</li><li><code>maxAlt</code>: Minimum altitude of the orbits on the list [m].</li><li><code>e</code>: Eccentricity.</li></ul><p><strong>Returns</strong></p><p>A matrix containing the orbits found with the following format:</p><pre><code class="language-none">Semi-major axis [m] | Altitude [m] | Inclination [rad] | Period [s] | Int | Num | Den
--------------------|--------------|-------------------|------------|-----|-----|-----</code></pre><p>in which the period is Int + Num/Den.</p><p><strong>Remarks</strong></p><p>If <code>minAlt</code> or <code>maxAlt</code> is &lt; 0.0, then the altitude will not be checked when a orbit is added to the list.</p></div></section></article><article class="docstring"><header><a class="docstring-binding" id="SatelliteToolbox.load_gravity_model-Tuple{Type{Val{:egm96}}}" href="#SatelliteToolbox.load_gravity_model-Tuple{Type{Val{:egm96}}}"><code>SatelliteToolbox.load_gravity_model</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">function load_gravity_model(T)</code></pre><p>Load an embedded gravity model coefficients <code>T</code> and return an instance of the structure <code>GravityModel_Coefs</code> with the parsed values.</p><p>The current supported values for <code>T</code> are:</p><table><tr><th style="text-align: center"><code>T</code></th><th style="text-align: left">Model Name</th><th style="text-align: left">Maximum Degree</th></tr><tr><td style="text-align: center"><code>EGM96()</code></td><td style="text-align: left">Earth Gravitational Model 1996</td><td style="text-align: left">360</td></tr><tr><td style="text-align: center"><code>JGM2()</code></td><td style="text-align: left">Joint Earth Gravity Model 2</td><td style="text-align: left">70</td></tr><tr><td style="text-align: center"><code>JGM3()</code></td><td style="text-align: left">Joint Earth Gravity Model 3</td><td style="text-align: left">70</td></tr><tr><td style="text-align: center">–––––-</td><td style="text-align: left">––––––––––––––––</td><td style="text-align: left">––––––––</td></tr></table><p>For other models, you can downlad the <code>gfc</code> file at</p><pre><code class="language-none">http://icgem.gfz-potsdam.de/home</code></pre><p>and load it using the functions <code>parse_icgem</code> and <code>create_gravity_model_coefs</code>.</p></div></section></article><article class="docstring"><header><a class="docstring-binding" id="SatelliteToolbox.minimum_half_FOV_grss-Tuple{Real,Real,Real,Integer}" href="#SatelliteToolbox.minimum_half_FOV_grss-Tuple{Real,Real,Real,Integer}"><code>SatelliteToolbox.minimum_half_FOV_grss</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">function minimum_half_FOV_grss(h::Real, T::Real, i::Real, To::Integer)</code></pre><p>Compute the minimum half FOV of a ground repeating Sun-synchronous (GRSS) orbit to cover the entire Equator within the revisit interval.</p><p><strong>Args</strong></p><ul><li><code>h</code>: Orbit altitude in the Equator [m].</li><li><code>T</code>: Orbit period [s].</li><li><code>i</code>: Inclination [rad].</li><li><code>To</code>: Orbit cycle [days].</li></ul><p><strong>Returns</strong></p><p>The minimum half FOV [rad].</p></div></section></article><article class="docstring"><header><a class="docstring-binding" id="SatelliteToolbox.minimum_half_FOV_grss-Tuple{Real,Real,Real,Real,Integer}" href="#SatelliteToolbox.minimum_half_FOV_grss-Tuple{Real,Real,Real,Real,Integer}"><code>SatelliteToolbox.minimum_half_FOV_grss</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">function minimum_half_FOV_grss(h::Real, a::Real, e::Real, i::Real, To::Integer)</code></pre><p>Compute the minimum half FOV of a ground repeating Sun-synchronous (GRSS) orbit to cover the entire Equator within the revisit interval.</p><p><strong>Args</strong></p><ul><li><code>h</code>: Orbit altitude in the Equator [m].</li><li><code>a</code>: Semi-major axis [m].</li><li><code>e</code>: Eccentricity.</li><li><code>i</code>: Inclination [rad].</li><li><code>To</code>: Orbit cycle [days].</li></ul><p><strong>Returns</strong></p><p>The minimum half FOV [rad].</p></div></section></article><article class="docstring"><header><a class="docstring-binding" id="SatelliteToolbox.minimum_swath_grss-Tuple{Real,Real,Integer}" href="#SatelliteToolbox.minimum_swath_grss-Tuple{Real,Real,Integer}"><code>SatelliteToolbox.minimum_swath_grss</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">function minimum_swath_grss(T::Real, i::Real, To::Integer)</code></pre><p>Compute the minimum swath of a ground repeating Sun-synchronous (GRSS) orbit to cover the entire Equator within the revisit interval.</p><p><strong>Args</strong></p><ul><li><code>T</code>: Orbit period [s].</li><li><code>i</code>: Inclination [rad].</li><li><code>To</code>: Orbit cycle [days].</li></ul><p><strong>Returns</strong></p><p>The minimum swath [m].</p></div></section></article><article class="docstring"><header><a class="docstring-binding" id="SatelliteToolbox.minimum_swath_grss-Tuple{Real,Real,Real,Integer}" href="#SatelliteToolbox.minimum_swath_grss-Tuple{Real,Real,Real,Integer}"><code>SatelliteToolbox.minimum_swath_grss</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">function minimum_swath_grss(a::Real, e::Real, i::Real, To::Integer)</code></pre><p>Compute the minimum swath of a ground repeating Sun-synchronous (GRSS) orbit to cover the entire Equator within the revisit interval.</p><p><strong>Args</strong></p><ul><li><code>a</code>: Semi-major axis [m].</li><li><code>e</code>: Eccentricity.</li><li><code>i</code>: Inclination [rad].</li><li><code>To</code>: Orbit cycle [days].</li></ul><p><strong>Returns</strong></p><p>The minimum swath [m].</p></div></section></article><article class="docstring"><header><a class="docstring-binding" id="SatelliteToolbox.moon_position_i-Tuple{Number}" href="#SatelliteToolbox.moon_position_i-Tuple{Number}"><code>SatelliteToolbox.moon_position_i</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">function moon_position_i(JD::Number)</code></pre><p>Compute the Moon position represented in the IAU-76/FK5 (mean-equator, mean-equinox), also called as J2000, at the Julian Day <code>JD</code>. The algorithm was adapted from [1, p. 288].</p></div></section></article><article class="docstring"><header><a class="docstring-binding" id="SatelliteToolbox.nrlmsise00-NTuple{4,Number}" href="#SatelliteToolbox.nrlmsise00-NTuple{4,Number}"><code>SatelliteToolbox.nrlmsise00</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">function nrlmsise00(JD::Number, alt::Number, g_lat::Number, g_long::Number [, f107A::Number, f107::Number, ap::Union{Number,AbstractVector}]; output_si::Bool = true, dversion::Bool = true)</code></pre><p><strong>NRLMSISE-00</strong></p><p>Neutral Atmosphere Empirical Model from the surface to lower exosphere.</p><p>This routine computes the NRLMSISE-00 outputs (see <code>NRLMSISE00_Output</code>) using the configurations in the structure <code>nrlmsise00</code> (see <code>NRLMSISE00_Structure</code>).</p><p>Notice that the NRLMSISE-00 will be run using the default flags (see <code>NRLMSISE00_DEFAULT_FLAGS</code>). The user can only change the value of <code>flags[:output_m_kg]</code> using the keyword <code>output_si</code> to select whether the output must be converted to SI units. If more control is needed, then the user must manually call the function <code>conf_nrlmsise00</code> and then call <code>gtd7</code> or <code>gtd7d</code> with the desired flags.</p><p>If the space indices <code>f107A</code>, <code>f107</code>, and <code>ap</code> are missing, then they will be obtained from the online databases (see <code>init_space_indices()</code>).</p><p><strong>Args</strong></p><ul><li><code>JD</code>: Julian Day [UTC].</li><li><code>alt</code>: Altitude [m].</li><li><code>g_lat</code>: Geodetic latitude [rad].</li><li><code>g_long</code>: Geodetic longitude [rad].</li><li><code>f107A</code>: 81 day average of F10.7 flux (centered on day of year <code>JD</code>).</li><li><code>f107</code>: Daily F10.7 flux for previous day.</li><li><code>ap</code>: Magnetic index (daily) if it is a number. If it is an array, then see       <strong>Remarks</strong>.</li></ul><p><strong>Keywords</strong></p><ul><li><code>output_si</code>: (OPTIONAL) If <code>true</code>, then the output units will be [m⁻³] for              species number density and [kg/m⁻³] for the total density.              Otherwise, the units will be [cm⁻³] and [g/cm⁻³], respectively.</li><li><code>dversion</code>: (OPTIONAL) If <code>true</code>, run <code>gtd7d</code>. Otherwise, run <code>gtd7</code> (see             <strong>Remarks</strong>).</li></ul><p><strong>Returns</strong></p><p>An instance of the structure <code>NRLMSISE00_Output</code>. The result in variable <code>den_Total</code> depends on the value of <code>dversion</code> (see <strong>Remarks</strong>, <strong>Notes on input variables</strong>).</p><p><strong>Remarks</strong></p><ol><li>The densities of <code>O</code>, <code>H</code>, and <code>N</code> are set to <code>0</code> below <code>72.5 km</code>.</li><li>The exospheric temperature <code>T_exo</code> is set to global average for altitudes below <code>120 km</code>. The <code>120 km</code> gradient is left at global average value for altitudes below <code>72.5 km</code>.</li><li>Anomalous oxygen is defined as hot atomic oxygen or ionized oxygen that can become appreciable at high altitudes (<code>&gt; 500 km</code>) for some ranges of inputs, thereby affection drag on satellites and debris. We group these species under the term <strong>Anomalous Oxygen</strong>, since their individual variations are not presently separable with the drag data used to define this model component.</li></ol><p><strong>AP</strong></p><p>If <code>ap</code> is a <code>Vector</code>, then it must be a vector with 7 dimensions as described below:</p><table><tr><th style="text-align: right">Index</th><th style="text-align: left">Description</th></tr><tr><td style="text-align: right">1</td><td style="text-align: left">Daily AP.</td></tr><tr><td style="text-align: right">2</td><td style="text-align: left">3 hour AP index for current time.</td></tr><tr><td style="text-align: right">3</td><td style="text-align: left">3 hour AP index for 3 hours before current time.</td></tr><tr><td style="text-align: right">4</td><td style="text-align: left">3 hour AP index for 6 hours before current time.</td></tr><tr><td style="text-align: right">5</td><td style="text-align: left">3 hour AP index for 9 hours before current time.</td></tr><tr><td style="text-align: right">6</td><td style="text-align: left">Average of eight 3 hour AP indices from 12 to 33 hours prior to current time.</td></tr><tr><td style="text-align: right">7</td><td style="text-align: left">Average of eight 3 hour AP indices from 36 to 57 hours prior to current time.</td></tr></table><p><strong>Notes on input variables</strong></p><p><code>f107</code> and <code>f107A</code> values used to generate the model correspond to the 10.7 cm radio flux at the actual distance of the Earth from the Sun rather than the radio flux at 1 AU. The following site provides both classes of values:</p><pre><code class="language-none">ftp://ftp.ngdc.noaa.gov/STP/SOLAR_DATA/SOLAR_RADIO/FLUX/</code></pre><p><code>f107</code>, <code>f107A</code>, and <code>ap</code> effects are neither large nor well established below 80 km and these parameters should be set to 150, 150, and 4 respectively.</p><p>If <code>dversion</code> is <code>true</code>, then the total mass <code>den_Total</code> (see <code>NRLMSISE00_Output</code>) is the sum of the mass densities of the species <code>He</code>, <code>O</code>, <code>N₂</code>, <code>O₂</code>, <code>Ar</code>, <code>H</code>, and <code>N</code>, but <strong>does not</strong> include anomalous oxygen.</p><p>If <code>dversion</code> is <code>false</code>, then total mass <code>den_Total</code> (see <code>NRLMSISE00_Output</code>) is the effective total mass density for drag and is the sum of the mass densities of all species in this model <strong>including</strong> the anomalous oxygen.</p></div></section></article><article class="docstring"><header><a class="docstring-binding" id="SatelliteToolbox.nutation_fk5" href="#SatelliteToolbox.nutation_fk5"><code>SatelliteToolbox.nutation_fk5</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">function nutation_fk5(JD_TT::Number, n_max::Number = 106, nut_coefs_1980::Matrix = nut_coefs_1980)</code></pre><p>Compute the nutation parameters at the Julian Day <code>JD_TT</code> [Terrestrial Time] using the 1980 IAU Theory of Nutation. The coefficients are <code>nut_coefs_1980</code> that must be a matrix in which each line has the following syntax [1, p. 1043]:</p><pre><code class="language-none">an1  an2  an3  an4  an5  Ai  Bi  Ci  Di</code></pre><p>where the units of <code>Ai</code> and <code>Ci</code> are [0.0001&quot;] and the units of <code>Bi</code> and <code>Di</code> are [0.0001&quot;/JC]. The user can also specify the number of coefficients <code>n_max</code> that will be used when computing the nutation. If <code>n_max</code> is omitted, the it defaults to 106.</p><p><strong>Returns</strong></p><ul><li>The mean obliquity of the ecliptic [rad].</li><li>The nutation in obliquity of the ecliptic [rad].</li><li>The nutation in longitude [rad].</li></ul></div></section></article><article class="docstring"><header><a class="docstring-binding" id="SatelliteToolbox.parse_icgem-Tuple{AbstractString}" href="#SatelliteToolbox.parse_icgem-Tuple{AbstractString}"><code>SatelliteToolbox.parse_icgem</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">function parse_icgem(filename::AbstractString)</code></pre><p>Parse the ICGEM file <code>filename</code> and return an instance of the structure <code>ICGEM</code> with the parsed data.</p></div></section></article><article class="docstring"><header><a class="docstring-binding" id="SatelliteToolbox.period" href="#SatelliteToolbox.period"><code>SatelliteToolbox.period</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">function period(a::Number, e::Number, i::Number, pert::Symbol = :J2)
function period(orb::Orbit, pert::Symbol = :J2)</code></pre><p>Compute the period [s] of an object in an orbit with semi-major axis <code>a</code> [m], eccentricity <code>e</code>, and inclination <code>i</code> [rad], using the perturbation terms specified by the symbol <code>pert</code>. The orbit can also be specified by <code>orb</code>, which is an instance of the structure <code>Orbit</code>.</p><p><code>pert</code> can be:</p><ul><li><code>:J0</code>: Consider a Keplerian orbit.</li><li><code>:J2</code>: Consider the perturbation terms up to J2.</li><li><code>:J4</code>: Consider the perturbation terms J2, J4, and J2².</li></ul><p>If <code>pert</code> is omitted, then it defaults to <code>:J2</code>.</p></div></section></article><article class="docstring"><header><a class="docstring-binding" id="SatelliteToolbox.precession_fk5-Tuple{Number}" href="#SatelliteToolbox.precession_fk5-Tuple{Number}"><code>SatelliteToolbox.precession_fk5</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">function precession_fk5(JD_TT::Number)</code></pre><p>Compute the angles related to the precession movement in the Julian Day <code>JD_TT</code> [Terrestrial Time] using the theory IAU-76/FK5.</p><p><strong>Returns</strong></p><p>The angles (ζ, Θ, z) as described in [1, p. 226-228].</p></div></section></article><article class="docstring"><header><a class="docstring-binding" id="SatelliteToolbox.precession_nutation_iau2006-Tuple{Number}" href="#SatelliteToolbox.precession_nutation_iau2006-Tuple{Number}"><code>SatelliteToolbox.precession_nutation_iau2006</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">function precession_nutation_iau2006(JD_TT::Number)</code></pre><p>Compute the coordinates <code>X</code>, <code>Y</code>, and <code>s</code> related to the Celestial Intermediate Pole (CIP) with respect to the Geocentric Celestial Reference Frame (GCRF). This accounts for the effects of both precession and nutation of the CIP.</p><p><strong>Returns</strong></p><ul><li>The coordinate <code>X</code> of the CIP w.r.t. the GCRF;</li><li>The coordinate <code>Y</code> of the CIP w.r.t. the GCRF;</li><li>The CIO locator <code>s</code> that provides the position of the CIO on the Equator of the CIP corresponding to the kinematical definition of the non-rotation origin in the GCRS when the CIP is moving with respect to the GCRS between the reference epoch and the epoch due to precession and nutation [1, p. 214].</li></ul></div></section></article><article class="docstring"><header><a class="docstring-binding" id="SatelliteToolbox.propagate!-Union{Tuple{T}, Tuple{OrbitPropagatorJ2{T},Number}} where T" href="#SatelliteToolbox.propagate!-Union{Tuple{T}, Tuple{OrbitPropagatorJ2{T},Number}} where T"><code>SatelliteToolbox.propagate!</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">function propagate!(orbp, t::Number) where T
function propagate!(orbp, t::AbstractVector) where T</code></pre><p>If <code>t</code> is a number, then propagate <code>orbp</code> by <code>t</code> [s] from the orbit epoch. Otherwise, if <code>t</code> is an array, then propagate the orbit in <code>orbp</code> using the time instants defined in the vector <code>t</code> [s].</p><p>In both cases, the orbit propagator algorithm is the one related to the structure <code>orbp</code>.</p><p>The structure <code>orbp</code> will contain the elements at the last propagation instant.</p><p><strong>Returns</strong></p><ul><li>The mean Keplerian elements represented in inertial frame in each time instant (see <code>Orbit</code>) [SI units].</li><li>The position vector represented in inertial frame in each time instant [m].</li><li>The velocity vector represented in inertial frame in each time instant [m].</li></ul><p>If <code>t</code> is an array, then those values will be an array containing the information related to each epoch in <code>t</code>.</p><p><strong>Remarks</strong></p><p>The inertial frame in which the output is represented depends on which frame it was used to generate the orbit parameters. If the orbit parameters are obtained from a TLE, then the inertial frame will be TEME. Notice, however, that the perturbation theory requires an inertial frame with true equator.</p></div></section></article><article class="docstring"><header><a class="docstring-binding" id="SatelliteToolbox.propagate_to_epoch!-Union{Tuple{T}, Tuple{OrbitPropagatorJ2{T},Union{Number, AbstractArray{T,1} where T}}} where T" href="#SatelliteToolbox.propagate_to_epoch!-Union{Tuple{T}, Tuple{OrbitPropagatorJ2{T},Union{Number, AbstractArray{T,1} where T}}} where T"><code>SatelliteToolbox.propagate_to_epoch!</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">function propagate_to_epoch!(orbp, JD::Number) where T
function propagate_to_epoch!(orbp, JD::AbstractVector) where T</code></pre><p>If <code>t</code> is a number, then propagate <code>orbp</code> until the epoch <code>JD</code> [Julian Day]. Otherwise, if <code>JD</code> is an array, then propagate the orbit in <code>orbp</code> using the epochs defined in the vector <code>t</code> [Julian Day].</p><p>In both cases, the orbit propagator algorithm is the one related to the structure <code>orbp</code>.</p><p>The structure <code>orbp</code> will contain the elements at the last propagation instant.</p><p><strong>Returns</strong></p><ul><li>The mean Keplerian elements represented in inertial frame in each time instant (see <code>Orbit</code>) [SI units].</li><li>The position vector represented in inertial frame in each time instant [m].</li><li>The velocity vector represented in inertial frame in each time instant [m].</li></ul><p>If <code>JD</code> is an array, then those values will be an array containing the information related to each epoch in <code>JD</code>.</p><p><strong>Remarks</strong></p><p>The inertial frame in which the output is represented depends on which frame it was used to generate the orbit parameters. If the orbit parameters are obtained from a TLE, then the inertial frame will be TEME. Notice, however, that the perturbation theory requires an inertial frame with true equator.</p></div></section></article><article class="docstring"><header><a class="docstring-binding" id="SatelliteToolbox.rCIRStoGCRF_iau2006" href="#SatelliteToolbox.rCIRStoGCRF_iau2006"><code>SatelliteToolbox.rCIRStoGCRF_iau2006</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">function rCIRStoGCRF_iau2006([T::Type,] JD_TT::Number, dX::Number = 0, dY::Number = 0)</code></pre><p>Compute the rotation that aligns the Celestial Intermediate Reference System (CIRS) with the Geocentric Celestial Reference Frame (GCRF) at the Julian Day <code>JD_TT</code> [TT] and considering the IERS EOP Data <code>dX</code> [rad] and <code>dY</code> [rad] (see <code>get_iers_eop</code>). This algorithm uses the IAU-2006 theory.</p><p>The IERS EOP Data <code>dX</code> and <code>dY</code> accounts for the free-core nutation and time dependent effects of the Celestial Intermediate Pole (CIP) position with respect to the GCRF.</p><p>The rotation type is described by the optional variable <code>T</code>. If it is <code>DCM</code>, then a DCM will be returned. Otherwise, if it is <code>Quaternion</code>, then a Quaternion will be returned. In case this parameter is omitted, then it falls back to <code>DCM</code>.</p><p><strong>Returns</strong></p><p>The rotation that aligns the CIRS frame with the GCRF frame. The rotation representation is selected by the optional parameter <code>T</code>.</p></div></section></article><article class="docstring"><header><a class="docstring-binding" id="SatelliteToolbox.rCIRStoTIRS_iau2006-Tuple{Number}" href="#SatelliteToolbox.rCIRStoTIRS_iau2006-Tuple{Number}"><code>SatelliteToolbox.rCIRStoTIRS_iau2006</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">function rCIRStoTIRS_iau2006([T::Type,] JD_UT1::Number)</code></pre><p>Compute the rotation that aligns the Celestial Intermediate Reference System (CIRS) with the Terrestrial Intermediate Reference System (TIRS) at the Julian Day <code>JD_UT1</code> [UT1]. This algorithm uses the IAU-2006 theory.</p><p>The rotation type is described by the optional variable <code>T</code>. If it is <code>DCM</code>, then a DCM will be returned. Otherwise, if it is <code>Quaternion</code>, then a Quaternion will be returned. In case this parameter is omitted, then it falls back to <code>DCM</code>.</p><p><strong>Returns</strong></p><p>The rotation that aligns the CIRS frame with the TIRS frame. The rotation representation is selected by the optional parameter <code>T</code>.</p><p><strong>Remarks</strong></p><p>The reference frames TIRS and CIRS are separated by a rotation about the Z-axis of the Earth Rotation Angle, which is the angle between the Conventional International Origin (CIO) and the Terrestrial Intermediate Origin (TIO) [1]. The latter is a reference meridian on Earth that is located about 100m away from Greenwich meridian along the equator of the Celestial Intermediate Pole (CIP) [1].</p></div></section></article><article class="docstring"><header><a class="docstring-binding" id="SatelliteToolbox.rECEFtoECEF-Tuple{Union{Type{Val{:ITRF}}, Type{Val{:PEF}}},Union{Type{Val{:ITRF}}, Type{Val{:PEF}}},Number,EOPData_IAU1980}" href="#SatelliteToolbox.rECEFtoECEF-Tuple{Union{Type{Val{:ITRF}}, Type{Val{:PEF}}},Union{Type{Val{:ITRF}}, Type{Val{:PEF}}},Number,EOPData_IAU1980}"><code>SatelliteToolbox.rECEFtoECEF</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">function rECEFtoECEF([T,] ECEFo, ECEFf, JD_UTC::Number, eop_data)</code></pre><p>Compute the rotation from an Earth-Centered, Earth-Fixed (<code>ECEF</code>) reference frame to another ECEF reference frame at the Julian Day [UTC] <code>JD_UTC</code>. The rotation description that will be used is given by <code>T</code>, which can be <code>DCM</code> or <code>Quaternion</code>. The origin ECEF frame is selected by the input <code>ECEFo</code> and the destination ECEF frame is selected by the input <code>ECEFf</code>. The model used to compute the rotation is specified by the selection of the origin and destination frames. Currently, there are two models supported: IAU-76/FK5 and IAU-2006 with 2010 conventions (CIO approach only).</p><p><strong>Rotation description</strong></p><p>The rotations that aligns the origin ECEF frame with the destination ECEF frame can be described by Direction Cosine Matrices or Quaternions. This is selected by the parameter <code>T</code>.</p><p>The possible values are:</p><ul><li><code>DCM</code>: The rotation will be described by a Direction Cosine Matrix.</li><li><code>Quaternion</code>: The rotation will be described by a Quaternion.</li></ul><p>If no value is specified, then it falls back to <code>DCM</code>.</p><p><strong>Conversion model</strong></p><p>The model that will be used to compute the rotation is automatically inferred given the selection of the origin and destination frames. <strong>Notice that mixing IAU-76/FK5 and IAU-2006/2010 frames is not supported yet.</strong></p><p><strong>ECEF Frame</strong></p><p>The supported ECEF frames for both origin <code>ECEFo</code> and destination <code>ECEFf</code> are:</p><ul><li><code>ITRF()</code>: ECEF will be selected as the International Terrestrial Reference           Frame (ITRF).</li><li><code>PEF()</code>: ECEF will be selected as the Pseudo-Earth Fixed (PEF) reference          frame.</li><li><code>TIRS()</code>: ECEF will be selected as the Terrestrial Intermediate Reference           System (TIRS).</li></ul><p><strong>EOP Data</strong></p><p>The conversion between the supported ECEF frames <strong>always</strong> depends on EOP Data (see <code>get_iers_eop</code> and <code>read_iers_eop</code>). If IAU-76/FK5 model is used, then the type of <code>eop_data</code> must be <code>EOPData_IAU1980</code>. Otherwise, if IAU-2006/2010 model is used, then the type of <code>eop_data</code> must be <code>EOPData_IAU2000A</code>.</p><p><strong>Returns</strong></p><p>The rotation description represented by <code>T</code> that rotates the ECEF reference frame into alignment with the ECI reference frame.</p><p><strong>Examples</strong></p><pre><code class="language-julia-repl">julia&gt; eop_IAU1980 = get_iers_eop(:IAU1980);

julia&gt; rECEFtoECEF(PEF(), ITRF(), DatetoJD(1986,6,19,21,35,0), eop_IAU1980)
3×3 StaticArrays.SArray{Tuple{3,3},Float64,2,9}:
  1.0          0.0         4.35684e-7
  0.0          1.0         1.44762e-6
 -4.35684e-7  -1.44762e-6  1.0

julia&gt; rECEFtoECEF(Quaternion, PEF(), ITRF(), DatetoJD(1986,6,19,21,35,0), eop_IAU1980)
Quaternion{Float64}:
  + 0.9999999999997147 - 7.236343481310813e-7.i + 2.1765518308012794e-7.j + 0.0.k

julia&gt; eop_IAU2000A = get_iers_eop(:IAU2000A);

julia&gt; rECEFtoECEF(TIRS(), ITRF(), DatetoJD(1986,6,19,21,35,0), eop_IAU2000A)
3×3 StaticArrays.SArray{Tuple{3,3},Float64,2,9}:
  1.0          3.08408e-11  -4.3531e-7
 -3.14708e-11  1.0          -1.44727e-6
  4.3531e-7    1.44727e-6    1.0

julia&gt; rECEFtoECEF(Quaternion, TIRS(), ITRF(), DatetoJD(1986,6,19,21,35,0), eop_IAU2000A)
Quaternion{Float64}:
  + 0.9999999999997146 - 7.236343481345639e-7.i + 2.176551830689726e-7.j + 1.5577911634233308e-11.k</code></pre></div></section></article><article class="docstring"><header><a class="docstring-binding" id="SatelliteToolbox.rECEFtoECI-Tuple{Union{Type{Val{:ITRF}}, Type{Val{:PEF}}},Union{Type{Val{:GCRF}}, Type{Val{:J2000}}, Type{Val{:TOD}}, Type{Val{:MOD}}, Type{Val{:TEME}}},Number,EOPData_IAU1980}" href="#SatelliteToolbox.rECEFtoECI-Tuple{Union{Type{Val{:ITRF}}, Type{Val{:PEF}}},Union{Type{Val{:GCRF}}, Type{Val{:J2000}}, Type{Val{:TOD}}, Type{Val{:MOD}}, Type{Val{:TEME}}},Number,EOPData_IAU1980}"><code>SatelliteToolbox.rECEFtoECI</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">function rECEFtoECI([T,] ECEF, ECI, JD_UTC::Number [, eop_data])</code></pre><p>Compute the rotation from an Earth-Centered, Earth-Fixed (<code>ECEF</code>) reference frame to an Earth-Centered Inertial (<code>ECI</code>) reference frame at the Julian Day [UTC] <code>JD_UTC</code>. The rotation description that will be used is given by <code>T</code>, which can be <code>DCM</code> or <code>Quaternion</code>. The ECEF frame is selected by the input <code>ECEF</code> and the <code>ECI</code> frame is selected by the input <code>ECI</code>. The possible values are listed below. The model used to compute the rotation is specified by the selection of the origin and destination frames. Currently, there are two models supported: IAU-76/FK5 and IAU-2006 with 2010 conventions (CIO approach only).</p><p><strong>Rotation description</strong></p><p>The rotations that aligns the ECEF with ECI can be described by Direction Cosine Matrices or Quaternions. This is selected by the parameter <code>T</code>. The possible values are:</p><ul><li><code>DCM</code>: The rotation will be described by a Direction Cosine Matrix.</li><li><code>Quaternion</code>: The rotation will be described by a Quaternion.</li></ul><p>If no value is specified, then it falls back to <code>DCM</code>.</p><p><strong>Conversion model</strong></p><p>The model that will be used to compute the rotation is automatically inferred given the selection of the origin and destination frames. <strong>Notice that mixing IAU-76/FK5 and IAU-2006/2010 frames is not supported yet.</strong></p><p><strong>ECEF Frame</strong></p><p>The ECEF frame is selected by the parameter <code>ECEF</code>. The possible values are:</p><ul><li><code>ITRF()</code>: ECEF will be selected as the International Terrestrial Reference           Frame (ITRF).</li><li><code>PEF()</code>: ECEF will be selected as the Pseudo-Earth Fixed (PEF) reference          frame.</li><li><code>TIRS()</code>: ECEF will be selected as the Terrestrial Intermediate Reference           System (TIRS).</li></ul><p><strong>ECI Frame</strong></p><p>The ECI frame is selected by the parameter <code>ECI</code>. The possible values are:</p><ul><li><code>TEME()</code>: ECI will be selected as the True Equator Mean Equinox (TEME)           reference frame.</li><li><code>TOD()</code>: ECI will be selected as the True of Date (TOD).</li><li><code>MOD()</code>: ECI will be selected as the Mean of Date (MOD).</li><li><code>J2000()</code>: ECI will be selected as the J2000 reference frame.</li><li><code>GCRF()</code>: ECI will be selected as the Geocentric Celestial Reference Frame           (GCRF).</li><li><code>CIRS()</code>: ECEF will be selected as the Celestial Intermediate Reference System           (CIRS).</li></ul><p><strong>EOP Data</strong></p><p>The conversion between the frames depends on EOP Data (see <code>get_iers_eop</code> and <code>read_iers_eop</code>). If IAU-76/FK5 model is used, then the type of <code>eop_data</code> must be <code>EOPData_IAU1980</code>. Otherwise, if IAU-2006/2010 model is used, then the type of <code>eop_data</code> must be <code>EOPData_IAU2000A</code>. The following table shows the requirements for EOP data given the selected frames.</p><p>|   Model       |  ECEF  |   ECI   |    EOP Data     | |:–––––––|:–––-|:––––|:–––––––-=| | IAU-76/FK5    | <code>ITRF</code> | <code>GCRF</code>  | EOP IAU1980     | | IAU-76/FK5    | <code>ITRF</code> | <code>J2000</code> | EOP IAU1980     | | IAU-76/FK5    | <code>ITRF</code> | <code>MOD</code>   | EOP IAU1980     | | IAU-76/FK5    | <code>ITRF</code> | <code>TOD</code>   | EOP IAU1980     | | IAU-76/FK5    | <code>ITRF</code> | <code>TEME</code>  | EOP IAU1980     | | IAU-76/FK5    | <code>PEF</code>  | <code>GCRF</code>  | EOP IAU1980     | | IAU-76/FK5    | <code>PEF</code>  | <code>J2000</code> | Not required¹   | | IAU-76/FK5    | <code>PEF</code>  | <code>MOD</code>   | Not required¹   | | IAU-76/FK5    | <code>PEF</code>  | <code>TOD</code>   | Not required¹   | | IAU-76/FK5    | <code>PEF</code>  | <code>TEME</code>  | Not required¹   | | IAU-2006/2010 | <code>ITRF</code> | <code>CIRS</code>  | EOP IAU2000A    | | IAU-2006/2010 | <code>ITRF</code> | <code>GCRF</code>  | EOP IAU2000A    | | IAU-2006/2010 | <code>TIRS</code> | <code>CIRS</code>  | Not required¹   | | IAU-2006/2010 | <code>TIRS</code> | <code>GCRF</code>  | Not required¹ ² |</p><p><code>¹</code>: In this case, the Julian Time UTC will be assumed equal to Julian Time UT1 to compute the Greenwich Mean Sidereal Time. This is an approximation, but should be sufficiently accurate for some applications. Notice that, if EOP Data is provided, the Julian Day UT1 will be accurately computed.</p><p><code>²</code>: In this case, the terms that account for the free-core nutation and time dependent effects of the Celestial Intermediate Pole (CIP) position with respect to the GCRF will not be available, reducing the precision.</p><p><strong>MOD and TOD</strong></p><p>In this function, if EOP corrections are not provided, then MOD and TOD frames will be computed considering the original IAU-76/FK5 theory. Otherwise, the corrected frame will be used.</p><p><strong>Returns</strong></p><p>The rotation description represented by <code>T</code> that rotates the ECEF reference frame into alignment with the ECI reference frame.</p><p><strong>Examples</strong></p><pre><code class="language-julia-repl">julia&gt; eop_IAU1980 = get_iers_eop(:IAU1980);

julia&gt; rECEFtoECI(DCM, ITRF(), GCRF(), DatetoJD(1986, 06, 19, 21, 35, 0), eop_IAU1980)
3×3 StaticArrays.SArray{Tuple{3,3},Float64,2,9}:
 -0.619267      0.78518     -0.00132979
 -0.78518      -0.619267     3.33492e-5
 -0.000797313   0.00106478   0.999999

julia&gt; rECEFtoECI(ITRF(), GCRF(), DatetoJD(1986, 06, 19, 21, 35, 0), eop_IAU1980)
3×3 StaticArrays.SArray{Tuple{3,3},Float64,2,9}:
 -0.619267      0.78518     -0.00132979
 -0.78518      -0.619267     3.33492e-5
 -0.000797313   0.00106478   0.999999

julia&gt; rECEFtoECI(PEF(), J2000(), DatetoJD(1986, 06, 19, 21, 35, 0))
3×3 StaticArrays.SArray{Tuple{3,3},Float64,2,9}:
 -0.619271      0.785176    -0.00133066
 -0.785177     -0.619272     3.45854e-5
 -0.000796885   0.00106622   0.999999

julia&gt; rECEFtoECI(PEF(), J2000(), DatetoJD(1986, 06, 19, 21, 35, 0), eop_IAU1980)
3×3 StaticArrays.SArray{Tuple{3,3},Float64,2,9}:
 -0.619267      0.78518     -0.00133066
 -0.78518      -0.619267     3.45854e-5
 -0.000796879   0.00106623   0.999999

julia&gt; rECEFtoECI(Quaternion, ITRF(), GCRF(), DatetoJD(1986, 06, 19, 21, 35, 0), eop_IAU1980)
Quaternion{Float64}:
  + 0.4363098936462618 - 0.0005909969666939257.i + 0.00030510511316206974.j + 0.8997962182293519.k

julia&gt; eop_IAU2000A = get_iers_eop(:IAU2000A);

julia&gt; rECEFtoECI(ITRF(), GCRF(), DatetoJD(1986, 06, 19, 21, 35, 0), eop_IAU2000A)
3×3 StaticArrays.SArray{Tuple{3,3},Float64,2,9}:
 -0.619267      0.78518     -0.00132979
 -0.78518      -0.619267     3.33502e-5
 -0.000797312   0.00106478   0.999999

julia&gt; rECEFtoECI(TIRS(), GCRF(), DatetoJD(1986, 06, 19, 21, 35, 0))
3×3 StaticArrays.SArray{Tuple{3,3},Float64,2,9}:
 -0.619271      0.785176    -0.00133066
 -0.785177     -0.619272     3.45884e-5
 -0.000796885   0.00106623   0.999999

julia&gt; rECEFtoECI(Quaternion, ITRF(), GCRF(), DatetoJD(1986, 06, 19, 21, 35, 0), eop_IAU2000A)
Quaternion{Float64}:
  + 0.4363098936309669 - 0.000590996988144556.i + 0.0003051056555230158.j + 0.8997962182365703.k</code></pre></div></section></article><article class="docstring"><header><a class="docstring-binding" id="SatelliteToolbox.rECItoECEF-Tuple{Union{Type{Val{:GCRF}}, Type{Val{:J2000}}, Type{Val{:TOD}}, Type{Val{:MOD}}, Type{Val{:TEME}}},Union{Type{Val{:ITRF}}, Type{Val{:PEF}}},Number,EOPData_IAU1980}" href="#SatelliteToolbox.rECItoECEF-Tuple{Union{Type{Val{:GCRF}}, Type{Val{:J2000}}, Type{Val{:TOD}}, Type{Val{:MOD}}, Type{Val{:TEME}}},Union{Type{Val{:ITRF}}, Type{Val{:PEF}}},Number,EOPData_IAU1980}"><code>SatelliteToolbox.rECItoECEF</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">function rECItoECEF([T,] ECI, ECEF, JD_UTC::Number [, eop_data])</code></pre><p>Compute the rotation from an Earth-Centered Inertial (<code>ECI</code>) reference frame to an Earth-Centered, Earth-Fixed (<code>ECEF</code>) reference frame at the Julian Day [UTC] <code>JD_UTC</code>. The rotation description that will be used is given by <code>T</code>, which can be <code>DCM</code> or <code>Quaternion</code>. The ECI frame is selected by the input <code>ECI</code> and the <code>ECEF</code> frame is selected by the input <code>ECEF</code>. The possible values are listed below. The model used to compute the rotation is specified by the selection of the origin and destination frames. Currently, there are two models supported: IAU-76/FK5 and IAU-2006 with 2010 conventions (CIO approach only).</p><p><strong>Rotation description</strong></p><p>The rotations that aligns the ECI with ECEF can be described by Direction Cosine Matrices or Quaternions. This is selected by the parameter <code>T</code>. The possible values are:</p><ul><li><code>DCM</code>: The rotation will be described by a Direction Cosine Matrix.</li><li><code>Quaternion</code>: The rotation will be described by a Quaternion.</li></ul><p>If no value is specified, then it falls back to <code>DCM</code>.</p><p><strong>Conversion model</strong></p><p>The model that will be used to compute the rotation is automatically inferred given the selection of the origin and destination frames. <strong>Notice that mixing IAU-76/FK5 and IAU-2006/2010 frames is not supported yet.</strong></p><p><strong>ECI Frame</strong></p><p>The ECI frame is selected by the parameter <code>ECI</code>. The possible values are:</p><ul><li><code>TEME()</code>: ECI will be selected as the True Equator Mean Equinox (TEME)           reference frame.</li><li><code>TOD()</code>: ECI will be selected as the True of Date (TOD).</li><li><code>MOD()</code>: ECI will be selected as the Mean of Date (MOD).</li><li><code>J2000()</code>: ECI will be selected as the J2000 reference frame.</li><li><code>GCRF()</code>: ECI will be selected as the Geocentric Celestial Reference Frame           (GCRF).</li><li><code>CIRS()</code>: ECEF will be selected as the Celestial Intermediate Reference System           (CIRS).</li></ul><p><strong>ECEF Frame</strong></p><p>The ECEF frame is selected by the parameter <code>ECEF</code>. The possible values are:</p><ul><li><code>ITRF()</code>: ECEF will be selected as the International Terrestrial Reference           Frame (ITRF).</li><li><code>PEF()</code>: ECEF will be selected as the Pseudo-Earth Fixed (PEF) reference          frame.</li><li><code>TIRS()</code>: ECEF will be selected as the Terrestrial Intermediate Reference           System (TIRS).</li></ul><p><strong>EOP Data</strong></p><p>The conversion between the frames depends on EOP Data (see <code>get_iers_eop</code> and <code>read_iers_eop</code>). If IAU-76/FK5 model is used, then the type of <code>eop_data</code> must be <code>EOPData_IAU1980</code>. Otherwise, if IAU-2006/2010 model is used, then the type of <code>eop_data</code> must be <code>EOPData_IAU2000A</code>. The following table shows the requirements for EOP data given the selected frames.</p><table><tr><th style="text-align: left">Model</th><th style="text-align: left">ECI</th><th style="text-align: left">ECEF</th><th style="text-align: left">EOP Data</th></tr><tr><td style="text-align: left">IAU-76/FK5</td><td style="text-align: left"><code>GCRF</code></td><td style="text-align: left"><code>ITRF</code></td><td style="text-align: left">EOP IAU1980</td></tr><tr><td style="text-align: left">IAU-76/FK5</td><td style="text-align: left"><code>J2000</code></td><td style="text-align: left"><code>ITRF</code></td><td style="text-align: left">EOP IAU1980</td></tr><tr><td style="text-align: left">IAU-76/FK5</td><td style="text-align: left"><code>MOD</code></td><td style="text-align: left"><code>ITRF</code></td><td style="text-align: left">EOP IAU1980</td></tr><tr><td style="text-align: left">IAU-76/FK5</td><td style="text-align: left"><code>TOD</code></td><td style="text-align: left"><code>ITRF</code></td><td style="text-align: left">EOP IAU1980</td></tr><tr><td style="text-align: left">IAU-76/FK5</td><td style="text-align: left"><code>TEME</code></td><td style="text-align: left"><code>ITRF</code></td><td style="text-align: left">EOP IAU1980</td></tr><tr><td style="text-align: left">IAU-76/FK5</td><td style="text-align: left"><code>GCRF</code></td><td style="text-align: left"><code>PEF</code></td><td style="text-align: left">EOP IAU1980</td></tr><tr><td style="text-align: left">IAU-76/FK5</td><td style="text-align: left"><code>J2000</code></td><td style="text-align: left"><code>PEF</code></td><td style="text-align: left">Not required¹</td></tr><tr><td style="text-align: left">IAU-76/FK5</td><td style="text-align: left"><code>MOD</code></td><td style="text-align: left"><code>PEF</code></td><td style="text-align: left">Not required¹</td></tr><tr><td style="text-align: left">IAU-76/FK5</td><td style="text-align: left"><code>TOD</code></td><td style="text-align: left"><code>PEF</code></td><td style="text-align: left">Not required¹</td></tr><tr><td style="text-align: left">IAU-76/FK5</td><td style="text-align: left"><code>TEME</code></td><td style="text-align: left"><code>PEF</code></td><td style="text-align: left">Not required¹</td></tr><tr><td style="text-align: left">IAU-2006/2010</td><td style="text-align: left"><code>CIRS</code></td><td style="text-align: left"><code>ITRF</code></td><td style="text-align: left">EOP IAU2000A</td></tr><tr><td style="text-align: left">IAU-2006/2010</td><td style="text-align: left"><code>GCRF</code></td><td style="text-align: left"><code>ITRF</code></td><td style="text-align: left">EOP IAU2000A</td></tr><tr><td style="text-align: left">IAU-2006/2010</td><td style="text-align: left"><code>CIRS</code></td><td style="text-align: left"><code>TIRS</code></td><td style="text-align: left">Not required¹</td></tr><tr><td style="text-align: left">IAU-2006/2010</td><td style="text-align: left"><code>GCRF</code></td><td style="text-align: left"><code>TIRS</code></td><td style="text-align: left">Not required¹ ²</td></tr></table><p><code>¹</code>: In this case, the Julian Time UTC will be assumed equal to Julian Time UT1 to compute the Greenwich Mean Sidereal Time. This is an approximation, but should be sufficiently accurate for some applications. Notice that, if EOP Data is provided, the Julian Day UT1 will be accurately computed.</p><p><code>²</code>: In this case, the terms that account for the free-core nutation and time dependent effects of the Celestial Intermediate Pole (CIP) position with respect to the GCRF will not be available, reducing the precision. The conversion between the frames depends on EOP Data (see <code>get_iers_eop</code> and <code>read_iers_eop</code>). If IAU-76/FK5 model is used, then the type of <code>eop_data</code> must be <code>EOPData_IAU1980</code>. The following table shows the requirements for EOP data given the selected frames.</p><p><strong>MOD and TOD</strong></p><p>In this function, if EOP corrections are not provided, then MOD and TOD frames will be computed considering the original IAU-76/FK5 theory. Otherwise, the corrected frame will be used.</p><p><strong>Returns</strong></p><p>The rotation description represented by <code>T</code> that rotates the ECI reference frame into alignment with the ECEF reference frame.</p><p><strong>Examples</strong></p><pre><code class="language-julia-repl">julia&gt; eop_IAU1980 = get_iers_eop(:IAU1980);

julia&gt; rECItoECEF(DCM, GCRF(), ITRF(), DatetoJD(1986, 06, 19, 21, 35, 0), eop_IAU1980)
3×3 StaticArrays.SArray{Tuple{3,3},Float64,2,9}:
 -0.619267    -0.78518     -0.000797313
  0.78518     -0.619267     0.00106478
 -0.00132979   3.33492e-5   0.999999

julia&gt; rECItoECEF(GCRF(), ITRF(), DatetoJD(1986, 06, 19, 21, 35, 0), eop_IAU1980)
3×3 StaticArrays.SArray{Tuple{3,3},Float64,2,9}:
 -0.619267    -0.78518     -0.000797313
  0.78518     -0.619267     0.00106478
 -0.00132979   3.33492e-5   0.999999

julia&gt; rECItoECEF(J2000(), PEF(), DatetoJD(1986, 06, 19, 21, 35, 0))
3×3 StaticArrays.SArray{Tuple{3,3},Float64,2,9}:
 -0.619271    -0.785177    -0.000796885
  0.785176    -0.619272     0.00106622
 -0.00133066   3.45854e-5   0.999999

julia&gt; rECItoECEF(J2000(), PEF(), DatetoJD(1986, 06, 19, 21, 35, 0), eop_IAU1980)
3×3 StaticArrays.SArray{Tuple{3,3},Float64,2,9}:
 -0.619267    -0.78518     -0.000796879
  0.78518     -0.619267     0.00106623
 -0.00133066   3.45854e-5   0.999999

julia&gt; rECItoECEF(Quaternion, GCRF(), ITRF(), DatetoJD(1986, 06, 19, 21, 35, 0), eop_IAU1980)
Quaternion{Float64}:
  + 0.4363098936462618 + 0.0005909969666939257.i - 0.00030510511316206974.j - 0.8997962182293519.k

julia&gt; eop_IAU2000A = get_iers_eop(:IAU2000A);

julia&gt; rECItoECEF(GCRF(), ITRF(), DatetoJD(1986, 06, 19, 21, 35, 0), eop_IAU2000A)
3×3 StaticArrays.SArray{Tuple{3,3},Float64,2,9}:
 -0.619267    -0.78518     -0.000797312
  0.78518     -0.619267     0.00106478
 -0.00132979   3.33502e-5   0.999999

julia&gt; rECItoECEF(GCRF(), TIRS(), DatetoJD(1986, 06, 19, 21, 35, 0))
3×3 StaticArrays.SArray{Tuple{3,3},Float64,2,9}:
 -0.619271    -0.785177    -0.000796885
  0.785176    -0.619272     0.00106623
 -0.00133066   3.45884e-5   0.999999

julia&gt; rECItoECEF(Quaternion, GCRF(), ITRF(), DatetoJD(1986, 06, 19, 21, 35, 0), eop_IAU2000A)
Quaternion{Float64}:
  + 0.4363098936309669 + 0.000590996988144556.i - 0.0003051056555230158.j - 0.8997962182365703.k</code></pre></div></section></article><article class="docstring"><header><a class="docstring-binding" id="SatelliteToolbox.rECItoECI-Tuple{Union{Type{Val{:GCRF}}, Type{Val{:J2000}}, Type{Val{:TOD}}, Type{Val{:MOD}}, Type{Val{:TEME}}},Union{Type{Val{:GCRF}}, Type{Val{:J2000}}, Type{Val{:TOD}}, Type{Val{:MOD}}, Type{Val{:TEME}}},Number,EOPData_IAU1980}" href="#SatelliteToolbox.rECItoECI-Tuple{Union{Type{Val{:GCRF}}, Type{Val{:J2000}}, Type{Val{:TOD}}, Type{Val{:MOD}}, Type{Val{:TEME}}},Union{Type{Val{:GCRF}}, Type{Val{:J2000}}, Type{Val{:TOD}}, Type{Val{:MOD}}, Type{Val{:TEME}}},Number,EOPData_IAU1980}"><code>SatelliteToolbox.rECItoECI</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">function rECEFtoECI([T,] ECIo, ECIf, JD_UTC::Number [, eop_data])
function rECEFtoECI([T,] ECIo, JD_UTCo::Number, ECIf, JD_UTCf::Number [, eop_data])</code></pre><p>Compute the rotation from an Earth-Centered Inertial (<code>ECI</code>) reference frame to another ECI reference frame. If the origin and destination frame contain only one <em>of date</em> frame, then the first signature is used and <code>JD_UTC</code> is the epoch of this frame. On the other hand, if the origin and destination frame contain two <em>of date</em> frame<sup class="footnote-reference"><a id="citeref-1" href="#footnote-1">[1]</a></sup>, e.g. TOD =&gt; MOD, then the second signature must be used in which <code>JD_UTCo</code> is the epoch of the origin frame and <code>JD_UTCf</code> is the epoch of the destination frame.</p><p>The rotation description that will be used is given by <code>T</code>, which can be <code>DCM</code> or <code>Quaternion</code>. The origin ECI frame is selected by the input <code>ECIo</code> and the destination ECI frame is selected by the input <code>ECIf</code>. The model used to compute the rotation is specified by the selection of the origin and destination frames. Currently, there are two models supported: IAU-76/FK5 and IAU-2006 with 2010 conventions (CIO approach only).</p><p><strong>Rotation description</strong></p><p>The rotations that aligns the origin ECI frame with the destination ECI frame can be described by Direction Cosine Matrices or Quaternions. This is selected by the parameter <code>T</code>.</p><p>The possible values are:</p><ul><li><code>DCM</code>: The rotation will be described by a Direction Cosine Matrix.</li><li><code>Quaternion</code>: The rotation will be described by a Quaternion.</li></ul><p>If no value is specified, then it falls back to <code>DCM</code>.</p><p><strong>Conversion model</strong></p><p>The model that will be used to compute the rotation is automatically inferred given the selection of the origin and destination frames. <strong>Notice that mixing IAU-76/FK5 and IAU-2006/2010 frames is not supported yet.</strong></p><p><strong>ECI Frame</strong></p><p>The supported ECI frames for both origin <code>ECIo</code> and destination <code>ECIf</code> are:</p><ul><li><code>TEME()</code>: ECI will be selected as the True Equator Mean Equinox (TEME)           reference frame.</li><li><code>TOD()</code>: ECI will be selected as the True of Date (TOD).</li><li><code>MOD()</code>: ECI will be selected as the Mean of Date (MOD).</li><li><code>J2000()</code>: ECI will be selected as the J2000 reference frame.</li><li><code>GCRF()</code>: ECI will be selected as the Geocentric Celestial Reference Frame           (GCRF).</li><li><code>CIRS()</code>: ECEF will be selected as the Celestial Intermediate Reference System           (CIRS).</li></ul><p><strong>EOP Data</strong></p><p>The conversion between the frames depends on EOP Data (see <code>get_iers_eop</code> and <code>read_iers_eop</code>). If IAU-76/FK5 model is used, then the type of <code>eop_data</code> must be <code>EOPData_IAU1980</code>. Otherwise, if IAU-2006/2010 model is used, then the type of <code>eop_data</code> must be <code>EOPData_IAU2000A</code>. The following table shows the requirements for EOP data given the selected frames.</p><table><tr><th style="text-align: left">Model</th><th style="text-align: left">ECIo</th><th style="text-align: left">ECIf</th><th style="text-align: left">EOP Data</th><th style="text-align: left">Function Signature</th></tr><tr><td style="text-align: left">IAU-76/FK5</td><td style="text-align: left"><code>GCRF</code></td><td style="text-align: left"><code>J2000</code></td><td style="text-align: left">EOP IAU1980</td><td style="text-align: left">First</td></tr><tr><td style="text-align: left">IAU-76/FK5</td><td style="text-align: left"><code>GCRF</code></td><td style="text-align: left"><code>MOD</code></td><td style="text-align: left">EOP IAU1980</td><td style="text-align: left">First</td></tr><tr><td style="text-align: left">IAU-76/FK5</td><td style="text-align: left"><code>GCRF</code></td><td style="text-align: left"><code>TOD</code></td><td style="text-align: left">EOP IAU1980</td><td style="text-align: left">First</td></tr><tr><td style="text-align: left">IAU-76/FK5</td><td style="text-align: left"><code>GCRF</code></td><td style="text-align: left"><code>TEME</code></td><td style="text-align: left">EOP IAU1980</td><td style="text-align: left">First</td></tr><tr><td style="text-align: left">IAU-76/FK5</td><td style="text-align: left"><code>J2000</code></td><td style="text-align: left"><code>GCRF</code></td><td style="text-align: left">EOP IAU1980</td><td style="text-align: left">First</td></tr><tr><td style="text-align: left">IAU-76/FK5</td><td style="text-align: left"><code>J2000</code></td><td style="text-align: left"><code>MOD</code></td><td style="text-align: left">Not required</td><td style="text-align: left">First</td></tr><tr><td style="text-align: left">IAU-76/FK5</td><td style="text-align: left"><code>J2000</code></td><td style="text-align: left"><code>TOD</code></td><td style="text-align: left">Not required</td><td style="text-align: left">First</td></tr><tr><td style="text-align: left">IAU-76/FK5</td><td style="text-align: left"><code>J2000</code></td><td style="text-align: left"><code>TEME</code></td><td style="text-align: left">Not required</td><td style="text-align: left">First</td></tr><tr><td style="text-align: left">IAU-76/FK5</td><td style="text-align: left"><code>MOD</code></td><td style="text-align: left"><code>GCRF</code></td><td style="text-align: left">EOP IAU1980</td><td style="text-align: left">First</td></tr><tr><td style="text-align: left">IAU-76/FK5</td><td style="text-align: left"><code>MOD</code></td><td style="text-align: left"><code>J2000</code></td><td style="text-align: left">Not required</td><td style="text-align: left">First</td></tr><tr><td style="text-align: left">IAU-76/FK5</td><td style="text-align: left"><code>MOD</code></td><td style="text-align: left"><code>TOD</code></td><td style="text-align: left">Not required</td><td style="text-align: left">Second</td></tr><tr><td style="text-align: left">IAU-76/FK5</td><td style="text-align: left"><code>MOD</code></td><td style="text-align: left"><code>TEME</code></td><td style="text-align: left">Not required</td><td style="text-align: left">Second</td></tr><tr><td style="text-align: left">IAU-76/FK5</td><td style="text-align: left"><code>TOD</code></td><td style="text-align: left"><code>GCRF</code></td><td style="text-align: left">EOP IAU1980</td><td style="text-align: left">First</td></tr><tr><td style="text-align: left">IAU-76/FK5</td><td style="text-align: left"><code>TOD</code></td><td style="text-align: left"><code>J2000</code></td><td style="text-align: left">Not required</td><td style="text-align: left">First</td></tr><tr><td style="text-align: left">IAU-76/FK5</td><td style="text-align: left"><code>TOD</code></td><td style="text-align: left"><code>MOD</code></td><td style="text-align: left">Not required</td><td style="text-align: left">Second</td></tr><tr><td style="text-align: left">IAU-76/FK5</td><td style="text-align: left"><code>TOD</code></td><td style="text-align: left"><code>TEME</code></td><td style="text-align: left">Not required</td><td style="text-align: left">Second</td></tr><tr><td style="text-align: left">IAU-76/FK5</td><td style="text-align: left"><code>TEME</code></td><td style="text-align: left"><code>GCRF</code></td><td style="text-align: left">EOP IAU1980</td><td style="text-align: left">First</td></tr><tr><td style="text-align: left">IAU-76/FK5</td><td style="text-align: left"><code>TEME</code></td><td style="text-align: left"><code>J2000</code></td><td style="text-align: left">Not required</td><td style="text-align: left">First</td></tr><tr><td style="text-align: left">IAU-76/FK5</td><td style="text-align: left"><code>TEME</code></td><td style="text-align: left"><code>MOD</code></td><td style="text-align: left">Not required</td><td style="text-align: left">Second</td></tr><tr><td style="text-align: left">IAU-76/FK5</td><td style="text-align: left"><code>TEME</code></td><td style="text-align: left"><code>TOD</code></td><td style="text-align: left">Not required</td><td style="text-align: left">Second</td></tr><tr><td style="text-align: left">IAU-2006/2010</td><td style="text-align: left"><code>GCRF</code></td><td style="text-align: left"><code>CIRS</code></td><td style="text-align: left">Not required¹</td><td style="text-align: left">First</td></tr><tr><td style="text-align: left">IAU-2006/2010</td><td style="text-align: left"><code>CIRS</code></td><td style="text-align: left"><code>CIRS</code></td><td style="text-align: left">Not required¹</td><td style="text-align: left">Second</td></tr></table><p><code>¹</code>: In this case, the terms that account for the free-core nutation and time dependent effects of the Celestial Intermediate Pole (CIP) position with respect to the GCRF will not be available, reducing the precision.</p><p><strong>MOD and TOD</strong></p><p>In this function, if EOP corrections are not provided, then MOD and TOD frames will be computed considering the original IAU-76/FK5 theory. Otherwise, the corrected frame will be used.</p><p><strong>Returns</strong></p><p>The rotation description represented by <code>T</code> that rotates the origin ECI reference frame into alignment with the destination ECI reference frame.</p><p><strong>Examples</strong></p><pre><code class="language-julia-repl">julia&gt; eop_IAU1980 = get_iers_eop(:IAU1980);

julia&gt; rECItoECI(DCM, GCRF(), J2000(), DatetoJD(1986, 6, 19, 21, 35, 0), eop_IAU1980)
3×3 StaticArrays.SArray{Tuple{3,3},Float64,2,9}:
  1.0          -2.45469e-12   4.56602e-10
  2.45466e-12   1.0          -1.84455e-9
 -4.56602e-10   1.84455e-9    1.0

julia&gt; rECItoECI(Quaternion, TEME(), GCRF(), DatetoJD(1986, 6, 19, 21, 35, 0), eop_IAU1980)
Quaternion{Float64}:
  + 0.9999986335698654 + 1.8300414020900853e-5.i + 0.0006653038276169474.j - 0.0015132396749411375.k

julia&gt; rECItoECI(TOD(), DatetoJD(1986,6,19,21,35,0), TOD(), DatetoJD(1987,5,19,3,0,0), eop_IAU1980)
3×3 StaticArrays.SArray{Tuple{3,3},Float64,2,9}:
 1.0          -0.000224087  -9.73784e-5
 0.000224086   1.0          -5.79859e-6
 9.73797e-5    5.77677e-6    1.0

julia&gt; rECItoECI(Quaternion, TOD(), JD_J2000, MOD(), JD_J2000, eop_IAU1980)
Quaternion{Float64}:
  + 0.9999999993282687 - 1.400220690336851e-5.i + 1.3473593746216003e-5.j - 3.107834312843103e-5.k

julia&gt; rECItoECI(J2000(), TEME(), DatetoJD(1986,6,19,21,35,0))
3×3 StaticArrays.SArray{Tuple{3,3},Float64,2,9}:
  0.999995    0.0030265    0.00133055
 -0.00302645  0.999995    -3.86125e-5
 -0.00133066  3.45854e-5   0.999999

julia&gt; eop_IAU2000A = get_iers_eop(:IAU2000A);

julia&gt; rECItoECI(CIRS(), GCRF(), DatetoJD(1986,6,19,21,35,0), eop_IAU2000A)
3×3 StaticArrays.SArray{Tuple{3,3},Float64,2,9}:
 0.999999     3.88379e-8  -0.00133066
 7.18735e-9   1.0          3.45882e-5
 0.00133066  -3.45882e-5   0.999999

julia&gt; rECItoECI(Quaternion, CIRS(), GCRF(), DatetoJD(1986,6,19,21,35,0), eop_IAU2000A)
Quaternion{Float64}:
  + 0.9999997785177528 + 1.7294102099105917e-5.i + 0.0006653310148723835.j + 7.912627369563795e-9.k</code></pre></div></section></article><article class="docstring"><header><a class="docstring-binding" id="SatelliteToolbox.rGCRFtoCIRS_iau2006" href="#SatelliteToolbox.rGCRFtoCIRS_iau2006"><code>SatelliteToolbox.rGCRFtoCIRS_iau2006</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">function rGCRFtoCIRS_iau2006([T::Type,] JD_TT::Number, dX::Number = 0, dY::Number = 0)</code></pre><p>Compute the rotation that aligns the Geocentric Celestial Reference Frame (GCRF) with the Celestial Intermediate Reference System (CIRS) at the Julian Day <code>JD_TT</code> [TT] and considering the IERS EOP Data <code>dX</code> [rad] and <code>dY</code> [rad] (see <code>get_iers_eop</code>). This algorithm uses the IAU-2006 theory.</p><p>The IERS EOP Data <code>dX</code> and <code>dY</code> accounts for the free-core nutation and time dependent effects of the Celestial Intermediate Pole (CIP) position with respect to the GCRF.</p><p>The rotation type is described by the optional variable <code>T</code>. If it is <code>DCM</code>, then a DCM will be returned. Otherwise, if it is <code>Quaternion</code>, then a Quaternion will be returned. In case this parameter is omitted, then it falls back to <code>DCM</code>.</p><p><strong>Returns</strong></p><p>The rotation that aligns the GCRF frame with the CIRS frame. The rotation representation is selected by the optional parameter <code>T</code>.</p></div></section></article><article class="docstring"><header><a class="docstring-binding" id="SatelliteToolbox.rGCRFtoITRF_fk5" href="#SatelliteToolbox.rGCRFtoITRF_fk5"><code>SatelliteToolbox.rGCRFtoITRF_fk5</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">function rGCRFtoITRF_fk5([T,] JD_UT1::Number, JD_TT::Number, x_p::Number, y_p::Number [, δΔϵ_1980::Number, δΔψ_1980::Number])</code></pre><p>Compute the rotation that aligns the Geocentric Celestial Reference Frame (GCRF) with the International Terrestrial Reference Frame (ITRF) at the Julian Day <code>JD_UT1</code> [UT1] and <code>JD_TT</code> [Terrestrial Time], and considering the IERS EOP Data <code>x_p</code> [rad], <code>y_p</code> [rad], <code>δΔϵ_1980</code> [rad], and <code>δΔψ_1980</code> [rad] (see <code>get_iers_eop</code>). This algorithm uses the IAU-76/FK5 theory.</p><p><code>x_p</code> is the polar motion displacement about X-axis, which is the IERS Reference Meridian direction (positive south along the 0˚ longitude meridian). <code>y_p</code> is the polar motion displacement about Y-axis (90˚W or 270˚E meridian). <code>δΔϵ_1980</code> is the nutation in obliquity. <code>δΔψ_1980</code> is the nutation in longitude.</p><p>The Julian Day in UT1 is used to compute the Greenwich Mean Sidereal Time (GMST) (see <code>JDtoGMST</code>), whereas the Julian Day in Terrestrial Time is used to compute the nutation in the longitude. Notice that the Julian Day in UT1 and in Terrestrial Time must be equivalent, i.e. must be related to the same instant. This function <strong>does not</strong> check this.</p><p>The rotation type is described by the optional variable <code>T</code>. If it is <code>DCM</code>, then a DCM will be returned. Otherwise, if it is <code>Quaternion</code>, then a Quaternion will be returned. In case this parameter is omitted, then it falls back to <code>DCM</code>.</p><p><strong>Returns</strong></p><p>The rotation that aligns the GCRF frame with the ITRF frame. The rotation representation is selected by the optional parameter <code>T</code>.</p><p><strong>Remarks</strong></p><p>The EOP data related to the polar motion (<code>x_p</code> and <code>y_p</code>) is required, since this is the only way available to compute the conversion ITRF &lt;=&gt; PEF (the models are highly imprecise since the motion is still not very well understood [1]). However, the EOP data related to the nutation of the obliquity (<code>δΔϵ_1980</code>) and the nutation of the longitude (<code>δΔψ_1980</code>) can be omitted. In this case, the GCRF frame is what is usually called J2000 reference frame.</p></div></section></article><article class="docstring"><header><a class="docstring-binding" id="SatelliteToolbox.rGCRFtoMOD_fk5-Tuple{Number}" href="#SatelliteToolbox.rGCRFtoMOD_fk5-Tuple{Number}"><code>SatelliteToolbox.rGCRFtoMOD_fk5</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">function rGCRFtoMOD_fk5([T,] JD_TT::Number)</code></pre><p>Compute the rotation that aligns the Geocentric Celestial Reference Frame (GCRF) with the Mean of Date (MOD) frame at the Julian Day [Terrestrial Time] <code>JD_TT</code>. This algorithm uses the IAU-76/FK5 theory.</p><p>The rotation type is described by the optional variable <code>T</code>. If it is <code>DCM</code>, then a DCM will be returned. Otherwise, if it is <code>Quaternion</code>, then a Quaternion will be returned. In case this parameter is omitted, then it falls back to <code>DCM</code>.</p><p><strong>Returns</strong></p><p>The rotation that aligns the GCRF frame with the MOD frame. The rotation representation is selected by the optional parameter <code>T</code>.</p><p><strong>Remarks</strong></p><p>The Geocentric Celestial Reference Frame (GCRF) is rotated into the Mean of Date (MOD) frame considering the IAU 1976 Precession model.</p><p>Notice that if the conversion <code>MOD =&gt; TOD</code> is performed <strong>without</strong> considering the EOP corrections, then the GCRF in this rotation is what is usually called the J2000 reference frame.</p></div></section></article><article class="docstring"><header><a class="docstring-binding" id="SatelliteToolbox.rGCRFtoTEME" href="#SatelliteToolbox.rGCRFtoTEME"><code>SatelliteToolbox.rGCRFtoTEME</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">function rGCRFtoTEME([T,] JD_TT::Number [, δΔϵ_1980::Number = 0, δΔψ_1980::Number = 0])</code></pre><p>Compute the rotation that aligns the GCRF frame with the True Equator Mean Equinox (TEME) frame at the Julian Day <code>JD_TT</code> [Terrestrial Time]. This algorithm uses the IAU-76/FK5 theory and TEME definition in [1, p. 233]. Notice that one can provide corrections for the nutation in obliquity (<code>δΔϵ_1980</code>) [rad] and in longitude (<code>δΔψ_1980</code>) [rad] that are usually obtained from IERS EOP Data (see <code>get_iers_eop</code>).</p><p>The rotation type is described by the optional variable <code>T</code>. If it is <code>DCM</code>, then a DCM will be returned. Otherwise, if it is <code>Quaternion</code>, then a Quaternion will be returned. In case this parameter is omitted, then it falls back to <code>DCM</code>.</p><p><strong>Returns</strong></p><p>The rotation that aligns the GCRF frame with the TEME frame. The rotation representation is selected by the optional parameter <code>T</code>.</p><p><strong>Remarks</strong></p><p>The EOP data related to the nutation of the obliquity (<code>δΔϵ_1980</code>) and the nutation of the longitude (<code>δΔψ_1980</code>) can be omitted. In this case, the GCRF frame is what is usually called J2000 reference frame.</p></div></section></article><article class="docstring"><header><a class="docstring-binding" id="SatelliteToolbox.rITRFtoGCRF_fk5" href="#SatelliteToolbox.rITRFtoGCRF_fk5"><code>SatelliteToolbox.rITRFtoGCRF_fk5</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">function rITRFtoGCRF_fk5([T,] JD_UT1::Number, JD_TT::Number, x_p::Number, y_p::Number [, δΔϵ_1980::Number, δΔψ_1980::Number])</code></pre><p>Compute the rotation that aligns the International Terrestrial Reference Frame (ITRF) with the Geocentric Celestial Reference Frame (GCRF) at the Julian Day <code>JD_UT1</code> [UT1] and <code>JD_TT</code> [Terrestrial Time], and considering the IERS EOP Data <code>x_p</code> [rad], <code>y_p</code> [rad], <code>δΔϵ_1980</code> [rad], and <code>δΔψ_1980</code> [rad] (see <code>get_iers_eop</code>). This algorithm uses the IAU-76/FK5 theory.</p><p><code>x_p</code> is the polar motion displacement about X-axis, which is the IERS Reference Meridian direction (positive south along the 0˚ longitude meridian). <code>y_p</code> is the polar motion displacement about Y-axis (90˚W or 270˚E meridian). <code>δΔϵ_1980</code> is the nutation in obliquity. <code>δΔψ_1980</code> is the nutation in longitude.</p><p>The Julian Day in UT1 is used to compute the Greenwich Mean Sidereal Time (GMST) (see <code>JDtoGMST</code>), whereas the Julian Day in Terrestrial Time is used to compute the nutation in the longitude. Notice that the Julian Day in UT1 and in Terrestrial Time must be equivalent, i.e. must be related to the same instant. This function <strong>does not</strong> check this.</p><p>The rotation type is described by the optional variable <code>T</code>. If it is <code>DCM</code>, then a DCM will be returned. Otherwise, if it is <code>Quaternion</code>, then a Quaternion will be returned. In case this parameter is omitted, then it falls back to <code>DCM</code>.</p><p><strong>Returns</strong></p><p>The rotation that aligns the ITRF frame with the GCRF frame. The rotation representation is selected by the optional parameter <code>T</code>.</p><p><strong>Remarks</strong></p><p>The EOP data related to the polar motion (<code>x_p</code> and <code>y_p</code>) is required, since this is the only way available to compute the conversion ITRF &lt;=&gt; PEF (the models are highly imprecise since the motion is still not very well understood [1]). However, the EOP data related to the nutation of the obliquity (<code>δΔϵ_1980</code>) and the nutation of the longitude (<code>δΔψ_1980</code>) can be omitted. In this case, the GCRF frame is what is usually called J2000 reference frame.</p></div></section></article><article class="docstring"><header><a class="docstring-binding" id="SatelliteToolbox.rITRFtoPEF_fk5-Tuple{Number,Number}" href="#SatelliteToolbox.rITRFtoPEF_fk5-Tuple{Number,Number}"><code>SatelliteToolbox.rITRFtoPEF_fk5</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">function rITRFtoPEF_fk5([T,] x_p::Number, y_p::Number)</code></pre><p>Compute the rotation that aligns the International Terrestrial Reference Frame (ITRF) with the Pseudo-Earth Fixed (PEF) frame considering the polar motion represented by the angles <code>x_p</code> [rad] and <code>y_p</code> [rad] that are obtained from IERS EOP Data (see <code>get_iers_eop</code>).</p><p><code>x_p</code> is the polar motion displacement about X-axis, which is the IERS Reference Meridian direction (positive south along the 0˚ longitude meridian). <code>y_p</code> is the polar motion displacement about Y-axis (90˚W or 270˚E meridian).</p><p>The rotation type is described by the optional variable <code>T</code>. If it is <code>DCM</code>, then a DCM will be returned. Otherwise, if it is <code>Quaternion</code>, then a Quaternion will be returned. In case this parameter is omitted, then it falls back to <code>DCM</code>.</p><p><strong>Returns</strong></p><p>The rotation that aligns the ITRF frame with the PEF frame. The rotation representation is selected by the optional parameter <code>T</code>.</p><p><strong>Remarks</strong></p><p>The ITRF is defined based on the International Reference Pole (IRP), which is the location of the terrestrial pole agreed by international committees [1]. The Pseudo-Earth Fixed, on the other hand, is defined based on the Earth axis of rotation, or the Celestial Intermediate Pole (CIP). Hence, PEF XY-plane contains the True Equator. Furthermore, since the recovered latitude and longitude are sensitive to the CIP, then it should be computed considering the PEF frame.</p></div></section></article><article class="docstring"><header><a class="docstring-binding" id="SatelliteToolbox.rITRFtoTIRS_iau2006-Tuple{Number,Number,Number}" href="#SatelliteToolbox.rITRFtoTIRS_iau2006-Tuple{Number,Number,Number}"><code>SatelliteToolbox.rITRFtoTIRS_iau2006</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">function rITRFtoTIRS_iau2006([T::Type,] JD_TT::Number, x_p::Number, y_p::Number)</code></pre><p>Compute the rotation that aligns the International Terrestrial Reference Frame (ITRF) with the Terrestrial Intermediate Reference System (TIRS) considering the polar motion represented by the angles <code>x_p</code> [rad] and <code>y_p</code> [rad] that are obtained from IERS EOP Data (see <code>get_iers_eop</code>).</p><p><code>x_p</code> is the polar motion displacement about X-axis, which is the IERS Reference Meridian direction (positive south along the 0˚ longitude meridian). <code>y_p</code> is the polar motion displacement about Y-axis (90˚W or 270˚E meridian).</p><p>The rotation type is described by the optional variable <code>T</code>. If it is <code>DCM</code>, then a DCM will be returned. Otherwise, if it is <code>Quaternion</code>, then a Quaternion will be returned. In case this parameter is omitted, then it falls back to <code>DCM</code>.</p><p><strong>Returns</strong></p><p>The rotation that aligns the ITRF frame with the TIRS frame. The rotation representation is selected by the optional parameter <code>T</code>.</p><p><strong>Remarks</strong></p><p>The ITRF is defined based on the International Reference Pole (IRP), which is the location of the terrestrial pole agreed by international committees [1]. The Terrestrial Intermediate Reference Frame (TIRS), on the other hand, is defined based on the Earth axis of rotation, or the Celestial Intermediate Pole (CIP). Hence, TIRS XY-plane contains the True Equator. Furthermore, since the recovered latitude and longitude are sensitive to the CIP, then it should be computed considering the TIRS frame.</p><p>The TIRS and PEF (IAU-76/FK5) are virtually the same reference frame, but according to [1] it is convenient to separate the names as the exact formulae differ.</p></div></section></article><article class="docstring"><header><a class="docstring-binding" id="SatelliteToolbox.rMODtoGCRF_fk5-Tuple{Number}" href="#SatelliteToolbox.rMODtoGCRF_fk5-Tuple{Number}"><code>SatelliteToolbox.rMODtoGCRF_fk5</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">function rMODtoGCRF_fk5([T,] JD_TT::Number)</code></pre><p>Compute the rotation that aligns the Mean of Date (MOD) frame with the Geocentric Celestial Reference Frame (GCRF) at the Julian Day [Terrestrial Time] <code>JD_TT</code>. This algorithm uses the IAU-76/FK5 theory.</p><p>The rotation type is described by the optional variable <code>T</code>. If it is <code>DCM</code>, then a DCM will be returned. Otherwise, if it is <code>Quaternion</code>, then a Quaternion will be returned. In case this parameter is omitted, then it falls back to <code>DCM</code>.</p><p><strong>Returns</strong></p><p>The rotation that aligns the MOD frame with the GCRF frame. The rotation representation is selected by the optional parameter <code>T</code>.</p><p><strong>Remarks</strong></p><p>The Mean of Date (MOD) frame is rotated into the Geocentric Celestial Reference Frame (GCRF) considering the IAU 1976 Precession model.</p><p>Notice that if the conversion <code>TOD =&gt; MOD</code> is performed <strong>without</strong> considering the EOP corrections, then the GCRF obtained by this rotation is what is usually called the J2000 reference frame.</p></div></section></article><article class="docstring"><header><a class="docstring-binding" id="SatelliteToolbox.rMODtoPEF_fk5" href="#SatelliteToolbox.rMODtoPEF_fk5"><code>SatelliteToolbox.rMODtoPEF_fk5</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">function rMODtoPEF_fk5([T,] JD_UT1::Number, JD_TT::Number [, δΔϵ_1980::Number, δΔψ_1980::Number])</code></pre><p>Compute the rotation that aligns the Mean of Date (MOD) reference frame with the Pseudo-Earth Fixed (PEF) frame at the Julian Day <code>JD_UT1</code> [UT1] and <code>JD_TT</code> [Terrestrial Time]. This algorithm uses the IAU-76/FK5 theory. Notice that one can provide corrections for the nutation in obliquity (<code>δΔϵ_1980</code>) [rad] and in longitude (<code>δΔψ_1980</code>) [rad] that are usually obtained from IERS EOP Data (see <code>get_iers_eop</code>).</p><p>The Julian Day in UT1 is used to compute the Greenwich Mean Sidereal Time (GMST) (see <code>JDtoGMST</code>), whereas the Julian Day in Terrestrial Time is used to compute the nutation in the longitude. Notice that the Julian Day in UT1 and in Terrestrial Time must be equivalent, i.e. must be related to the same instant. This function <strong>does not</strong> check this.</p><p>The rotation type is described by the optional variable <code>T</code>. If it is <code>DCM</code>, then a DCM will be returned. Otherwise, if it is <code>Quaternion</code>, then a Quaternion will be returned. In case this parameter is omitted, then it falls back to <code>DCM</code>.</p><p><strong>Returns</strong></p><p>The rotation that aligns the MOD frame with the PEF frame. The rotation representation is selected by the optional parameter <code>T</code>.</p></div></section></article><article class="docstring"><header><a class="docstring-binding" id="SatelliteToolbox.rMODtoTEME" href="#SatelliteToolbox.rMODtoTEME"><code>SatelliteToolbox.rMODtoTEME</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">function rMODtoTEME([T,] JD_TT::Number [, δΔϵ_1980::Number = 0, δΔψ_1980::Number = 0])</code></pre><p>Compute the rotation that aligns the Mean of Date (MOD) frame with the True Equator Mean Equinox (TEME) frame at the Julian Day <code>JD_TT</code> [Terrestrial Time]. This algorithm uses the IAU-76/FK5 theory and TEME definition in [1, p. 233]. Notice that one can provide corrections for the nutation in obliquity (<code>δΔϵ_1980</code>) [rad] and in longitude (<code>δΔψ_1980</code>) [rad] that are usually obtained from IERS EOP Data (see <code>get_iers_eop</code>).  .</p><p>The rotation type is described by the optional variable <code>T</code>. If it is <code>DCM</code>, then a DCM will be returned. Otherwise, if it is <code>Quaternion</code>, then a Quaternion will be returned. In case this parameter is omitted, then it falls back to <code>DCM</code>.</p><p><strong>Returns</strong></p><p>The rotation that aligns the MOD frame with the TEME frame. The rotation representation is selected by the optional parameter <code>T</code>.</p></div></section></article><article class="docstring"><header><a class="docstring-binding" id="SatelliteToolbox.rMODtoTOD_fk5" href="#SatelliteToolbox.rMODtoTOD_fk5"><code>SatelliteToolbox.rMODtoTOD_fk5</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">function rMODtoTOD_fk5([T,] JD_TT::Number [, δΔϵ_1980::Number, δΔψ_1980::Number])</code></pre><p>Compute the rotation that aligns the Mean of Date (MOD) frame with the True of Date (TOD) frame at the Julian Day <code>JD_TT</code> [Terrestrial Time]. This algorithm uses the IAU-76/FK5 theory. Notice that one can provide corrections for the nutation in obliquity (<code>δΔϵ_1980</code>) [rad] and in longitude (<code>δΔψ_1980</code>) [rad] that are usually obtained from IERS EOP Data (see <code>get_iers_eop</code>).</p><p>The rotation type is described by the optional variable <code>T</code>. If it is <code>DCM</code>, then a DCM will be returned. Otherwise, if it is <code>Quaternion</code>, then a Quaternion will be returned. In case this parameter is omitted, then it falls back to <code>DCM</code>.</p><p><strong>Returns</strong></p><p>The rotation that aligns the MOD frame with the TOD frame. The rotation representation is selected by the optional parameter <code>T</code>.</p><p><strong>Remarks</strong></p><p>The Mean of Date (MOD) frame is rotated into the True of Date (TOD) frame considering the 1980 IAU Theory of Nutation. The IERS EOP corrections must be added if one wants to make the rotation consistent with the Geocentric Celestial Reference Systems (GCRS).</p></div></section></article><article class="docstring"><header><a class="docstring-binding" id="SatelliteToolbox.rPEFtoITRF_fk5-Tuple{Number,Number}" href="#SatelliteToolbox.rPEFtoITRF_fk5-Tuple{Number,Number}"><code>SatelliteToolbox.rPEFtoITRF_fk5</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">function rPEFtoITRF_fk5([T,] x_p::Number, y_p::Number)</code></pre><p>Compute the rotation that aligns the Pseudo-Earth Fixed (PEF) with the International Terrestrial Reference Frame (ITRF) considering the polar motion represented by the angles <code>x_p</code> [rad] and <code>y_p</code> [rad] that are obtained from IERS EOP Data (see <code>get_iers_eop</code>).</p><p><code>x_p</code> is the polar motion displacement about X-axis, which is the IERS Reference Meridian direction (positive south along the 0˚ longitude meridian). <code>y_p</code> is the polar motion displacement about Y-axis (90˚W or 270˚E meridian).</p><p>The rotation type is described by the optional variable <code>T</code>. If it is <code>DCM</code>, then a DCM will be returned. Otherwise, if it is <code>Quaternion</code>, then a Quaternion will be returned. In case this parameter is omitted, then it falls back to <code>DCM</code>.</p><p><strong>Returns</strong></p><p>The rotation that aligns the PEF frame with the ITRF. The rotation representation is selected by the optional parameter <code>T</code>.</p><p><strong>Remarks</strong></p><p>The ITRF is defined based on the International Reference Pole (IRP), which is the location of the terrestrial pole agreed by international committees [1]. The Pseudo-Earth Fixed, on the other hand, is defined based on the Earth axis of rotation, or the Celestial Intermediate Pole (CIP). Hence, PEF XY-plane contains the True Equator. Furthermore, since the recovered latitude and longitude are sensitive to the CIP, then it should be computed considering the PEF frame.</p></div></section></article><article class="docstring"><header><a class="docstring-binding" id="SatelliteToolbox.rPEFtoMOD_fk5" href="#SatelliteToolbox.rPEFtoMOD_fk5"><code>SatelliteToolbox.rPEFtoMOD_fk5</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">function rPEFtoMOD_fk5([T,] JD_UT1::Number, JD_TT::Number [, δΔϵ_1980::Number, δΔψ_1980::Number])</code></pre><p>Compute the rotation that aligns the Pseudo-Earth Fixed (PEF) frame with the Mean of Date (MOD) at the Julian Day <code>JD_UT1</code> [UT1] and <code>JD_TT</code> [Terrestrial Time]. This algorithm uses the IAU-76/FK5 theory. Notice that one can provide corrections for the nutation in obliquity (<code>δΔϵ_1980</code>) [rad] and in longitude (<code>δΔψ_1980</code>) [rad] that are usually obtained from IERS EOP Data (see <code>get_iers_eop</code>).</p><p>The Julian Day in UT1 is used to compute the Greenwich Mean Sidereal Time (GMST) (see <code>JDtoGMST</code>), whereas the Julian Day in Terrestrial Time is used to compute the nutation in the longitude. Notice that the Julian Day in UT1 and in Terrestrial Time must be equivalent, i.e. must be related to the same instant. This function <strong>does not</strong> check this.</p><p>The rotation type is described by the optional variable <code>T</code>. If it is <code>DCM</code>, then a DCM will be returned. Otherwise, if it is <code>Quaternion</code>, then a Quaternion will be returned. In case this parameter is omitted, then it falls back to <code>DCM</code>.</p><p><strong>Returns</strong></p><p>The rotation that aligns the PEF frame with the TOD frame. The rotation representation is selected by the optional parameter <code>T</code>.</p></div></section></article><article class="docstring"><header><a class="docstring-binding" id="SatelliteToolbox.rPEFtoTEME-Tuple{Number}" href="#SatelliteToolbox.rPEFtoTEME-Tuple{Number}"><code>SatelliteToolbox.rPEFtoTEME</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">function rPEFtoTEME([T,] JD_TT::Number)</code></pre><p>Compute the rotation that aligns the Pseudo-Earth Fixed (PEF) frame with the True Equator Mean Equinox (TEME) frame at the Julian Day <code>JD_TT</code> [Terrestrial Time]. This algorithm uses the IAU-76/FK5 theory and TEME definition in [1, p. 233].</p><p>The rotation type is described by the optional variable <code>T</code>. If it is <code>DCM</code>, then a DCM will be returned. Otherwise, if it is <code>Quaternion</code>, then a Quaternion will be returned. In case this parameter is omitted, then it falls back to <code>DCM</code>.</p><p><strong>Returns</strong></p><p>The rotation that aligns the PEF frame with the TEME frame. The rotation representation is selected by the optional parameter <code>T</code>.</p></div></section></article><article class="docstring"><header><a class="docstring-binding" id="SatelliteToolbox.rPEFtoTOD_fk5" href="#SatelliteToolbox.rPEFtoTOD_fk5"><code>SatelliteToolbox.rPEFtoTOD_fk5</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">function rPEFtoTOD_fk5([T,] JD_UT1::Number, JD_TT::Number [, δΔψ_1980::Number])</code></pre><p>Compute the rotation that aligns the Pseudo-Earth Fixed (PEF) frame with the True of Date (TOD) frame at the Julian Day <code>JD_UT1</code> [UT1] and <code>JD_TT</code> [Terrestrial Time]. This algorithm uses the IAU-76/FK5 theory. Notice that one can provide correction for the nutation in longitude (<code>δΔψ_1980</code>) [rad] that is usually obtained from IERS EOP Data (see <code>get_iers_eop</code>).</p><p>The Julian Day in UT1 is used to compute the Greenwich Mean Sidereal Time (GMST) (see <code>JDtoGMST</code>), whereas the Julian Day in Terrestrial Time is used to compute the nutation in the longitude. Notice that the Julian Day in UT1 and in Terrestrial Time must be equivalent, i.e. must be related to the same instant. This function <strong>does not</strong> check this.</p><p>The rotation type is described by the optional variable <code>T</code>. If it is <code>DCM</code>, then a DCM will be returned. Otherwise, if it is <code>Quaternion</code>, then a Quaternion will be returned. In case this parameter is omitted, then it falls back to <code>DCM</code>.</p><p><strong>Returns</strong></p><p>The rotation that aligns the PEF frame with the TOD frame. The rotation representation is selected by the optional parameter <code>T</code>.</p><p><strong>Remarks</strong></p><p>The Pseudo-Earth Fixed (PEF) frame is rotated into the True of Date (TOD) frame considering the 1980 IAU Theory of Nutation. The IERS EOP corrections must be added if one wants to make the rotation consistent with the Geocentric Celestial Reference Systems (GCRS).</p></div></section></article><article class="docstring"><header><a class="docstring-binding" id="SatelliteToolbox.rTEMEtoGCRF" href="#SatelliteToolbox.rTEMEtoGCRF"><code>SatelliteToolbox.rTEMEtoGCRF</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">function rTEMEtoGCRF([T,] JD_TT::Number [, δΔϵ_1980::Number = 0, δΔψ_1980::Number = 0])</code></pre><p>Compute the rotation that aligns the True Equator Mean Equinox (TEME) frame with the Geocentric Celestial Reference Frame (GCRF) at the Julian Day <code>JD_TT</code> [Terrestrial Time]. This algorithm uses the IAU-76/FK5 theory and TEME definition in [1, p. 233]. Notice that one can provide corrections for the nutation in obliquity (<code>δΔϵ_1980</code>) [rad] and in longitude (<code>δΔψ_1980</code>) [rad] that are usually obtained from IERS EOP Data (see <code>get_iers_eop</code>).</p><p>The rotation type is described by the optional variable <code>T</code>. If it is <code>DCM</code>, then a DCM will be returned. Otherwise, if it is <code>Quaternion</code>, then a Quaternion will be returned. In case this parameter is omitted, then it falls back to <code>DCM</code>.</p><p><strong>Returns</strong></p><p>The rotation that aligns the TEME frame with the GCRF frame. The rotation representation is selected by the optional parameter <code>T</code>.</p><p><strong>Remarks</strong></p><p>The EOP data related to the nutation of the obliquity (<code>δΔϵ_1980</code>) and the nutation of the longitude (<code>δΔψ_1980</code>) can be omitted. In this case, the GCRF frame is what is usually called J2000 reference frame.</p></div></section></article><article class="docstring"><header><a class="docstring-binding" id="SatelliteToolbox.rTEMEtoMOD" href="#SatelliteToolbox.rTEMEtoMOD"><code>SatelliteToolbox.rTEMEtoMOD</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">function rTEMEtoMOD([T,] JD_TT::Number [, δΔϵ_1980::Number = 0, δΔψ_1980::Number = 0])</code></pre><p>Compute the rotation that aligns the True Equator Mean Equinox (TEME) frame with the Mean of Date (MOD) frame at the Julian Day <code>JD_TT</code> [Terrestrial Time]. This algorithm uses the IAU-76/FK5 theory and TEME definition in [1, p. 233]. Notice that one can provide corrections for the nutation in obliquity (<code>δΔϵ_1980</code>) [rad] and in longitude (<code>δΔψ_1980</code>) [rad] that are usually obtained from IERS EOP Data (see <code>get_iers_eop</code>).</p><p>The rotation type is described by the optional variable <code>T</code>. If it is <code>DCM</code>, then a DCM will be returned. Otherwise, if it is <code>Quaternion</code>, then a Quaternion will be returned. In case this parameter is omitted, then it falls back to <code>DCM</code>.</p><p><strong>Returns</strong></p><p>The rotation that aligns the TEME frame with the MOD frame. The rotation representation is selected by the optional parameter <code>T</code>.</p></div></section></article><article class="docstring"><header><a class="docstring-binding" id="SatelliteToolbox.rTEMEtoPEF-Tuple{Number}" href="#SatelliteToolbox.rTEMEtoPEF-Tuple{Number}"><code>SatelliteToolbox.rTEMEtoPEF</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">function rTEMEtoPEF([T,] JD_TT::Number)</code></pre><p>Compute the rotation that aligns the True Equator Mean Equinox (TEME) frame with the Pseudo-Earth Fixed (PEF) frame at the Julian Day <code>JD_TT</code> [Terrestrial Time]. This algorithm uses the IAU-76/FK5 theory and TEME definition in [1, p. 233].</p><p>The rotation type is described by the optional variable <code>T</code>. If it is <code>DCM</code>, then a DCM will be returned. Otherwise, if it is <code>Quaternion</code>, then a Quaternion will be returned. In case this parameter is omitted, then it falls back to <code>DCM</code>.</p><p><strong>Returns</strong></p><p>The rotation that aligns the TEME frame with the PEF frame. The rotation representation is selected by the optional parameter <code>T</code>.</p></div></section></article><article class="docstring"><header><a class="docstring-binding" id="SatelliteToolbox.rTEMEtoTOD" href="#SatelliteToolbox.rTEMEtoTOD"><code>SatelliteToolbox.rTEMEtoTOD</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">function rTEMEtoTOD([T,] JD_TT::Number [, δΔϵ_1980::Number = 0, δΔψ_1980::Number = 0])</code></pre><p>Compute the rotation that aligns the True Equator Mean Equinox (TEME) frame with the True of Date (TOD) frame at the Julian Day <code>JD_TT</code> [Terrestrial Time]. This algorithm uses the IAU-76/FK5 theory and TEME definition in [1, p. 233]. Notice that one can provide corrections for the nutation in obliquity (<code>δΔϵ_1980</code>) [rad] and in longitude (<code>δΔψ_1980</code>) [rad] that are usually obtained from IERS EOP Data (see <code>get_iers_eop</code>).</p><p>The rotation type is described by the optional variable <code>T</code>. If it is <code>DCM</code>, then a DCM will be returned. Otherwise, if it is <code>Quaternion</code>, then a Quaternion will be returned. In case this parameter is omitted, then it falls back to <code>DCM</code>.</p><p><strong>Returns</strong></p><p>The rotation that aligns the TEME frame with the TOD frame. The rotation representation is selected by the optional parameter <code>T</code>.</p></div></section></article><article class="docstring"><header><a class="docstring-binding" id="SatelliteToolbox.rTIRStoCIRS_iau2006-Tuple{Number}" href="#SatelliteToolbox.rTIRStoCIRS_iau2006-Tuple{Number}"><code>SatelliteToolbox.rTIRStoCIRS_iau2006</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">function rTIRStoCIRS_iau2006([T::Type,] JD_UT1::Number)</code></pre><p>Compute the rotation that aligns the Terrestrial Intermediate Reference System (TIRS) with the Celestial Intermediate Reference System (CIRS) at the Julian Day <code>JD_UT1</code> [UT1]. This algorithm uses the IAU-2006 theory.</p><p>The rotation type is described by the optional variable <code>T</code>. If it is <code>DCM</code>, then a DCM will be returned. Otherwise, if it is <code>Quaternion</code>, then a Quaternion will be returned. In case this parameter is omitted, then it falls back to <code>DCM</code>.</p><p><strong>Returns</strong></p><p>The rotation that aligns the TIRS frame with the CIRS frame. The rotation representation is selected by the optional parameter <code>T</code>.</p><p><strong>Remarks</strong></p><p>The reference frames TIRS and CIRS are separated by a rotation about the Z-axis of the Earth Rotation Angle, which is the angle between the Conventional International Origin (CIO) and the Terrestrial Intermediate Origin (TIO) [1]. The latter is a reference meridian on Earth that is located about 100m away from Greenwich meridian along the equator of the Celestial Intermediate Pole (CIP) [1].</p></div></section></article><article class="docstring"><header><a class="docstring-binding" id="SatelliteToolbox.rTIRStoITRF_iau2006-Tuple{Number,Number,Number}" href="#SatelliteToolbox.rTIRStoITRF_iau2006-Tuple{Number,Number,Number}"><code>SatelliteToolbox.rTIRStoITRF_iau2006</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">function rTIRStoITRF_iau2006([T::Type,] JD_TT::Number, x_p::Number, y_p::Number)</code></pre><p>Compute the rotation that aligns the Terrestrial Intermediate Reference System (TIRS) with the International Terrestrial Reference Frame (ITRF) considering the polar motion represented by the angles <code>x_p</code> [rad] and <code>y_p</code> [rad] that are obtained from IERS EOP Data (see <code>get_iers_eop</code>).</p><p><code>x_p</code> is the polar motion displacement about X-axis, which is the IERS Reference Meridian direction (positive south along the 0˚ longitude meridian). <code>y_p</code> is the polar motion displacement about Y-axis (90˚W or 270˚E meridian).</p><p>The rotation type is described by the optional variable <code>T</code>. If it is <code>DCM</code>, then a DCM will be returned. Otherwise, if it is <code>Quaternion</code>, then a Quaternion will be returned. In case this parameter is omitted, then it falls back to <code>DCM</code>.</p><p><strong>Returns</strong></p><p>The rotation that aligns the TIRS frame with the ITRF frame. The rotation representation is selected by the optional parameter <code>T</code>.</p><p><strong>Remarks</strong></p><p>The ITRF is defined based on the International Reference Pole (IRP), which is the location of the terrestrial pole agreed by international committees [1]. The Terrestrial Intermediate Reference Frame (TIRS), on the other hand, is defined based on the Earth axis of rotation, or the Celestial Intermediate Pole (CIP). Hence, TIRS XY-plane contains the True Equator. Furthermore, since the recovered latitude and longitude are sensitive to the CIP, then it should be computed considering the TIRS frame.</p><p>The TIRS and PEF (IAU-76/FK5) are virtually the same reference frame, but according to [1] it is convenient to separate the names as the exact formulae differ.</p></div></section></article><article class="docstring"><header><a class="docstring-binding" id="SatelliteToolbox.rTODtoMOD_fk5" href="#SatelliteToolbox.rTODtoMOD_fk5"><code>SatelliteToolbox.rTODtoMOD_fk5</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">function rTODtoMOD_fk5([T,] JD_TT::Number [, δΔϵ_1980::Number, δΔψ_1980::Number])</code></pre><p>Compute the rotation that aligns the True of Date (TOD) frame with the Mean of Date (MOD) frame at the Julian Day <code>JD_TT</code> [Terrestrial Time]. This algorithm uses the IAU-76/FK5 theory. Notice that one can provide corrections for the nutation in obliquity (<code>δΔϵ_1980</code>) [rad] and in longitude (<code>δΔψ_1980</code>) [rad] that are usually obtained from IERS EOP Data (see <code>get_iers_eop</code>).</p><p>The rotation type is described by the optional variable <code>T</code>. If it is <code>DCM</code>, then a DCM will be returned. Otherwise, if it is <code>Quaternion</code>, then a Quaternion will be returned. In case this parameter is omitted, then it falls back to <code>DCM</code>.</p><p><strong>Returns</strong></p><p>The rotation that aligns the TOD frame with the MOD frame. The rotation representation is selected by the optional parameter <code>T</code>.</p><p><strong>Remarks</strong></p><p>The True of Date (TOD) frame is rotated into the Mean of Date (MOD) frame considering the 1980 IAU Theory of Nutation. The IERS EOP corrections must be added if one wants to make the rotation consistent with the Geocentric Celestial Reference Systems (GCRS).</p></div></section></article><article class="docstring"><header><a class="docstring-binding" id="SatelliteToolbox.rTODtoPEF_fk5" href="#SatelliteToolbox.rTODtoPEF_fk5"><code>SatelliteToolbox.rTODtoPEF_fk5</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">function rTODtoPEF_fk5([T,] JD_UT1::Number, JD_TT::Number [, δΔψ_1980::Number])</code></pre><p>Compute the rotation that aligns the True of Date (TOD) frame with the Pseudo-Earth Fixed (PEF) frame at the Julian Day <code>JD_UT1</code> [UT1] and <code>JD_TT</code> [Terrestrial Time]. This algorithm uses the IAU-76/FK5 theory. Notice that one can provide correction for the nutation in longitude (<code>δΔψ_1980</code>) [rad] that is usually obtained from IERS EOP Data (see <code>get_iers_eop</code>).</p><p>The Julian Day in UT1 is used to compute the Greenwich Mean Sidereal Time (GMST) (see <code>JDtoGMST</code>), whereas the Julian Day in Terrestrial Time is used to compute the nutation in the longitude. Notice that the Julian Day in UT1 and in Terrestrial Time must be equivalent, i.e. must be related to the same instant. This function <strong>does not</strong> check this.</p><p>The rotation type is described by the optional variable <code>T</code>. If it is <code>DCM</code>, then a DCM will be returned. Otherwise, if it is <code>Quaternion</code>, then a Quaternion will be returned. In case this parameter is omitted, then it falls back to <code>DCM</code>.</p><p><strong>Returns</strong></p><p>The rotation that aligns the TOD frame with the PEF frame. The rotation representation is selected by the optional parameter <code>T</code>.</p><p><strong>Remarks</strong></p><p>The True of Date (TOD) frame is rotated into the Pseudo-Earth Fixed (PEF) frame considering the 1980 IAU Theory of Nutation. The IERS EOP corrections must be added if one wants to make the rotation consistent with the Geocentric Celestial Reference Systems (GCRS).</p></div></section></article><article class="docstring"><header><a class="docstring-binding" id="SatelliteToolbox.rTODtoTEME" href="#SatelliteToolbox.rTODtoTEME"><code>SatelliteToolbox.rTODtoTEME</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">function rTODtoTEME([T,] JD_TT::Number [, δΔϵ_1980::Number = 0, δΔψ_1980::Number = 0])</code></pre><p>Compute the rotation that aligns the True of Date (TOD) frame with the True Equator Mean Equinox (TEME) frame at the Julian Day <code>JD_TT</code> [Terrestrial Time]. This algorithm uses the IAU-76/FK5 theory and TEME definition in [1, p. 233]. Notice that one can provide corrections for the nutation in obliquity (<code>δΔϵ_1980</code>) [rad] and in longitude (<code>δΔψ_1980</code>) [rad] that are usually obtained from IERS EOP Data (see <code>get_iers_eop</code>).</p><p>The rotation type is described by the optional variable <code>T</code>. If it is <code>DCM</code>, then a DCM will be returned. Otherwise, if it is <code>Quaternion</code>, then a Quaternion will be returned. In case this parameter is omitted, then it falls back to <code>DCM</code>.</p><p><strong>Returns</strong></p><p>The rotation that aligns the TOD frame with the TEME frame. The rotation representation is selected by the optional parameter <code>T</code>.</p></div></section></article><article class="docstring"><header><a class="docstring-binding" id="SatelliteToolbox.read_iers_eop" href="#SatelliteToolbox.read_iers_eop"><code>SatelliteToolbox.read_iers_eop</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">function read_iers_eop(filename::String, data_type::Symbol = :IAU1980)</code></pre><p>Read IERS EOP Data from the file <code>filename</code>. The user must specify if the data is related to the model IAU 1980 (<code>data_type = :IAU1980</code>), which is the default, or to the model IAU 2000A (<code>data_type = :IAU2000A</code>).</p><p><strong>Returns</strong></p><p>A structure (<code>EOPData_IAU1980</code> or <code>EOPData_IAU2000A</code>, depending on <code>data_type</code>) with the interpolations of the EOP parameters. Notice that the interpolation indexing is set to the Julian Day.</p><p><strong>Remarks</strong></p><p>The input file <strong>must be exactly the same</strong> as provided by IERS. One can download it using the following commands:</p><ul><li><p>IAU 1980</p><pre><code class="language-none">  curl -O https://datacenter.iers.org/data/latestVersion/223_EOP_C04_14.62-NOW.IAU1980223.txt
  wget https://datacenter.iers.org/data/latestVersion/223_EOP_C04_14.62-NOW.IAU1980223.txt</code></pre></li><li><p>IAU 2000A</p><pre><code class="language-none">  curl -O https://datacenter.iers.org/data/latestVersion/224_EOP_C04_14.62-NOW.IAU2000A224.txt
  wget https://datacenter.iers.org/data/latestVersion/224_EOP_C04_14.62-NOW.IAU2000A224.txt</code></pre></li></ul></div></section></article><article class="docstring"><header><a class="docstring-binding" id="SatelliteToolbox.rv_to_kepler" href="#SatelliteToolbox.rv_to_kepler"><code>SatelliteToolbox.rv_to_kepler</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">function rv_to_kepler(r_i::AbstractVector, v_i::AbstractVector, t::Number = 0)</code></pre><p>Convert a Cartesian representation (position vector <code>r</code> [m] and velocity vector <code>v</code> [m/s²]) to the Keplerian elements. Optionally, the user can specify the epoch of the returned elements using the parameter <code>t</code>. It it is omitted, then it default to 0.</p><p><strong>Returns</strong></p><p>An instance of the structure <code>Orbit</code> with the Keplerian elements [SI units].</p><p><strong>Remarks</strong></p><p>The special cases are treated as follows:</p><ul><li><strong>Circular and equatorial</strong>: the right ascension of the ascending node and the argument of perigee are set to 0. Hence, the true anomaly is equal to the true longitude.</li><li><strong>Elliptical and equatorial</strong>: the right ascension of the ascending node is set to 0. Hence, the argument of perigee is equal to the longitude of periapsis.</li><li><strong>Circular and inclined</strong>: the argument of perigee is set to 0. Hence, the true anomaly is equal to the argument of latitude.</li></ul><p><strong>References</strong></p><p>The algorithm was adapted from [1].</p></div></section></article><article class="docstring"><header><a class="docstring-binding" id="SatelliteToolbox.rv_to_kepler-NTuple{6,Number}" href="#SatelliteToolbox.rv_to_kepler-NTuple{6,Number}"><code>SatelliteToolbox.rv_to_kepler</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">function rv_to_kepler(x::Number, y::Number, z::Number, vx::Number, vy::Number, vz::Number)</code></pre><p>Convert a Cartesian representation (position vector <code>[x;y;z]</code> [m] and velocity vector <code>[vx;vy;vz]</code> [m/s²]) to the Keplerian elements.</p><p><strong>Returns</strong></p><p>An instance of the structure <code>Orbit</code> with the Keplerian elements [SI units].</p></div></section></article><article class="docstring"><header><a class="docstring-binding" id="SatelliteToolbox.rv_to_mean_elements_sgp4-Union{Tuple{Tv}, Tuple{T}, Tuple{AbstractArray{T,1},AbstractArray{Tv,1},AbstractArray{Tv,1}}, Tuple{AbstractArray{T,1},AbstractArray{Tv,1},AbstractArray{Tv,1},Any}} where Tv&lt;:(AbstractArray{T,1} where T) where T" href="#SatelliteToolbox.rv_to_mean_elements_sgp4-Union{Tuple{Tv}, Tuple{T}, Tuple{AbstractArray{T,1},AbstractArray{Tv,1},AbstractArray{Tv,1}}, Tuple{AbstractArray{T,1},AbstractArray{Tv,1},AbstractArray{Tv,1},Any}} where Tv&lt;:(AbstractArray{T,1} where T) where T"><code>SatelliteToolbox.rv_to_mean_elements_sgp4</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">function rv_to_mean_elements_sgp4(vJD::AbstractVector{T}, vr::AbstractVector{Tv}, vv::AbstractVector{Tv}, W = I; max_it = 10000, sgp4_gc = sgp4_gc_wgs84) where</code></pre><p>Compute the mean elements for SGP4 based on the position <code>vr</code> and velocity vectors <code>vr</code> represented in TEME reference frame. The epoch of those measurements [Julian Day] must be in <code>vJD</code>.</p><p>The matrix <code>W</code> defined the weights for the least-square algorithm.</p><p>The variable <code>max_it</code> defines the maximum allowed number of iterations.</p><p>The variable <code>sgp4_gc</code> defines which constants should be used when running SGP4.</p><p><strong>Returns</strong></p><ul><li>The epoch of the elements [Julian Day].</li><li>The mean elements for SGP4 algorithm:<ul><li>Mean motion [rad/s];</li><li>Eccentricity [];</li><li>Inclination [rad];</li><li>Right ascension of the ascending node [rad];</li><li>Argument of perigee [rad];</li><li>Mean anomaly [rad];</li><li>BSTAR.</li></ul></li><li>The covariance matrix of the mean elements estimation.</li></ul></div></section></article><article class="docstring"><header><a class="docstring-binding" id="SatelliteToolbox.rv_to_tle-Tuple" href="#SatelliteToolbox.rv_to_tle-Tuple"><code>SatelliteToolbox.rv_to_tle</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">function rv_to_tle(args...; name::String = &quot;UNDEFINED&quot;, sat_num::Int = 9999, classification::Char = &#39;U&#39;, int_designator = &quot;999999&quot;, elem_set_number::Int = 0, rev_num, kwargs...)</code></pre><p>Convert a set of position and velocity vectors represented in TEME reference frame to a TLE. The arguments <code>args</code> and keywords <code>kwargs</code> are the same as those described in the function <code>rv_to_mean_elements_sgp4</code>.</p><p>Additionally, the user can specify some parameters of the generated TLE.</p><p>This function prints the TLE to <code>stdout</code> using the function <code>print_tle</code> and also returns the TLE string.</p></div></section></article><article class="docstring"><header><a class="docstring-binding" id="SatelliteToolbox.satellite_check_Brazil-Tuple{Number,Number}" href="#SatelliteToolbox.satellite_check_Brazil-Tuple{Number,Number}"><code>SatelliteToolbox.satellite_check_Brazil</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">function satellite_check_Brazil(lat::Number, lon::Number)</code></pre><p>Verify if a point described by latitude <code>lat</code> [rad] and longitude <code>lon</code> [rad] is inside Brazil. Returns <code>true</code> if the point is inside Brazil, of <code>false</code> otherwise.</p><p><strong>Remarks</strong></p><p>This function was based on the algorithm sent by Renato Branco to Ronan Arraes by e-mail at 2016-02-16.</p></div></section></article><article class="docstring"><header><a class="docstring-binding" id="SatelliteToolbox.satellite_lighting_condition-Tuple{AbstractArray{T,1} where T,AbstractArray{T,1} where T}" href="#SatelliteToolbox.satellite_lighting_condition-Tuple{AbstractArray{T,1} where T,AbstractArray{T,1} where T}"><code>SatelliteToolbox.satellite_lighting_condition</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">function satellite_lighting_condition(r_i::AbstractVector, s_i::AbstractVector)</code></pre><p>Compute the satellite lighting condition given the Sun unitary vector <code>s_i</code> [m] and the satellite position vector <code>r_i</code> [m].</p><p><strong>Returns</strong></p><ul><li><code>SAT_LIGHTING_SUNLIGHT</code>: Satellite is under sunlight.</li><li><code>SAT_LIGHTING_PENUMBRA</code>: Satellite is at penumbra region.</li><li><code>SAT_LIGHTING_UMBRA</code>: Satellite is at umbra region.</li></ul></div></section></article><article class="docstring"><header><a class="docstring-binding" id="SatelliteToolbox.satellite_position_i-NTuple{6,Number}" href="#SatelliteToolbox.satellite_position_i-NTuple{6,Number}"><code>SatelliteToolbox.satellite_position_i</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">function satellite_position_i(a::Number, e::Number, i::Number, RAAN::Number, w::Number, f::Number)</code></pre><p>Compute the satellite position in the Earth-Centered Inertial (ECI) reference frame given the orbital elements <code>a</code>, <code>e</code>, <code>i</code>, <code>RAAN</code>, <code>w</code>, and <code>f</code>.</p><p>Notice that the ECI frame used will be the same as the frame of the orbital elements.</p><p><strong>Args</strong></p><ul><li><code>a</code>: Semi-major axis.</li><li><code>e</code>: Eccentricity.</li><li><code>i</code>: Inclination [rad].</li><li><code>RAAN</code>: Right ascension of the ascending node [rad].</li><li><code>w</code>: Argument of perigee [rad].</li><li><code>f</code>: True anomaly [rad].</li></ul><p><strong>Returns</strong></p><ul><li>The satellite position vector represented in the ECI reference frame.</li><li>The unit vector perpendicular to the satellite position vector that lies on the orbit plane represented in the ECI reference frame.</li></ul><p><strong>Remarks</strong></p><p>The satellite position vector will have the same unit of the semi-major axis.</p></div></section></article><article class="docstring"><header><a class="docstring-binding" id="SatelliteToolbox.satellite_sun_angle_earth_pointing" href="#SatelliteToolbox.satellite_sun_angle_earth_pointing"><code>SatelliteToolbox.satellite_sun_angle_earth_pointing</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">function satellite_sun_angle_earth_pointing(JD0::Number, a::Number, e::Number, i::Number, RAAN::Number, w::Number, numDays::Integer, fN_k::Function, meanAnomaly::Bool = false, step::Number = 0.1*pi/180.0)</code></pre><p>Compute the Sun angle on a satellite surface for an Earth-pointing mission.</p><p><strong>Args</strong></p><ul><li><code>JD0</code>: Initial instant for the analysis [Julian day].</li><li><code>a</code>: Semi-major axis of the orbit [m].</li><li><code>e</code>: Orbit eccentricity.</li><li><code>i</code>: Orbit inclination [rad].</li><li><code>w</code>: Argument of perigee [rad].</li><li><code>RAAN</code>: Right ascension of the ascending node at <code>JD0</code> [rad].</li><li><code>numDays</code>: Number of days for the analysis.</li><li><code>fN_k</code>: Function <strong>f(s_b)</strong> that describes the solar panel normal at each k-th         sampling step. Notice that <strong>s_b</strong> is the Sun vector represented in         the body coordinate frame.</li><li><code>meanAnomaly</code>: (OPTIONAL) If <strong>true</strong>, compute using angular steps in the mean                anomaly instead of in the orbit latitude (<strong>Default</strong>: false).</li><li><code>step</code>: (OPTIONAL) Mean anomaly step (<strong>Default</strong>: 0.1 deg).</li></ul><p><strong>Returns</strong></p><p>A matrix containing the sun angle [rad] for each position in orbit for each day.</p><p><strong>NOTE</strong>: if the Sun angle is larger than 90 deg or if the satellite is in eclipse, then <code>NaN</code> is returned in the matrix.</p><p><strong>Remarks</strong></p><p>The body reference frame is defined as:</p><ul><li><strong>Z axis</strong> points towards the center of Earth;</li><li><strong>Y axis</strong> points towards the negative direction of orbit normal;</li><li><strong>X axis</strong> completes the right-hand reference frame.</li></ul><p>If the <strong>mean anomaly</strong> is used, then the average value of the output is the average sun radiation received by the satellite surface, because every angular steps have a fixed time interval.</p><p>If the <strong>mean anomaly</strong> is used, then the angle interval is [0, 2π]. Otherwise, the angle interval is [-π,π].</p></div></section></article><article class="docstring"><header><a class="docstring-binding" id="SatelliteToolbox.satellite_sun_angle_earth_pointing" href="#SatelliteToolbox.satellite_sun_angle_earth_pointing"><code>SatelliteToolbox.satellite_sun_angle_earth_pointing</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">function satellite_sun_angle_earth_pointing(JD0::Number, a::Number, e::Number, i::Number, RAAN::Number, w::Number, numDays::Integer, N::AbstractVector, step::Number = 0.1*pi/180.0)</code></pre><p>Compute the Sun angle on a satellite surface for an Earth-pointing mission.</p><p><strong>Args</strong></p><ul><li><code>JD0</code>: Initial instant for the analysis [Julian day].</li><li><code>a</code>: Semi-major axis of the orbit [m].</li><li><code>e</code>: Orbit eccentricity.</li><li><code>i</code>: Orbit inclination [rad].</li><li><code>w</code>: Argument of perigee [rad].</li><li><code>RAAN</code>: Right ascension of the ascending node at <code>JD0</code> [rad].</li><li><code>numDays</code>: Number of days for the analysis.</li><li><code>N</code>: Vector normal to the surface represented in the body reference frame.</li><li><code>meanAnomaly</code>: (OPTIONAL) If <strong>true</strong>, compute using angular steps in the mean                anomaly instead of in the orbit latitude (<strong>Default</strong>: false).</li><li><code>step</code>: (OPTIONAL) Mean anomaly step (<strong>Default</strong>: 0.1 deg).</li></ul><p><strong>Returns</strong></p><p>A matrix containing the Sun angle for each position in orbit for each day.</p><p><strong>NOTE</strong>: if the Sun angle is larger than 90 deg or if the satellite is in eclipse, then <code>NaN</code> is returned in the matrix.</p><p><strong>Remarks</strong></p><p>The body reference frame is defined as:</p><ul><li><strong>Z axis</strong> points towards the center of Earth;</li><li><strong>Y axis</strong> points towards the negative direction of orbit normal;</li><li><strong>X axis</strong> completes the right-hand reference frame.</li></ul><p>If the <strong>mean anomaly</strong> is used, then the average value of the output is the average sun radiation received by the satellite surface, because every angular steps have a fixed time interval.</p><p>If the <strong>mean anomaly</strong> is used, then the angle interval is [0, 2π]. Otherwise, the angle interval is [-π,π].</p></div></section></article><article class="docstring"><header><a class="docstring-binding" id="SatelliteToolbox.satellite_sun_radiation_earth_pointing" href="#SatelliteToolbox.satellite_sun_radiation_earth_pointing"><code>SatelliteToolbox.satellite_sun_radiation_earth_pointing</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">function satellite_sun_radiation_earth_pointing(JD0::Number, a::Number, e::Number, i::Number, RAAN::Number, w::Number, numDays::Integer, N::Vector, meanAnomaly::Bool = false, step::Number = 0.1*pi/180.0)</code></pre><p>Compute the Sun radiation on a satellite surface for an Earth-pointing mission.</p><p><strong>Args</strong></p><ul><li><code>JD0</code>: Initial instant for the analysis [Julian day].</li><li><code>a</code>: Semi-major axis of the orbit [m].</li><li><code>e</code>: Orbit eccentricity.</li><li><code>i</code>: Orbit inclination [rad].</li><li><code>w</code>: Argument of perigee [rad].</li><li><code>RAAN</code>: Right ascension of the ascending node at <code>JD0</code> [rad].</li><li><code>numDays</code>: Number of days for the analysis.</li><li><code>N</code>: Vector normal to the surface represented in the body reference frame.</li><li><code>meanAnomaly</code>: (OPTIONAL) If <strong>true</strong>, compute using angular steps in the mean                anomaly instead of in the orbit latitude (<strong>Default</strong>: false).</li><li><code>step</code>: (OPTIONAL) Mean anomaly step (<strong>Default</strong>: 0.1 deg).</li></ul><p><strong>Returns</strong></p><p>A matrix containing the Sun radiation [W/m²] for each position in orbit for each day.</p><p><strong>NOTE</strong>: if the Sun angle is larger than 90 deg or if the satellite is in eclipse, then <code>NaN</code> is returned in the matrix.</p><p><strong>Remarks</strong></p><p>The body reference frame is defined as:</p><ul><li><strong>Z axis</strong> points towards the center of Earth;</li><li><strong>Y axis</strong> points towards the negative direction of orbit normal;</li><li><strong>X axis</strong> completes the right-hand reference frame.</li></ul><p>If the <strong>mean anomaly</strong> is used, then the average value of the output is the average sun radiation received by the satellite surface, because every angular steps have a fixed time interval.</p><p>If the <strong>mean anomaly</strong> is used, then the angle interval is [0, 2π]. Otherwise, the angle interval is [-π,π].</p></div></section></article><article class="docstring"><header><a class="docstring-binding" id="SatelliteToolbox.satellite_sun_radiation_earth_pointing" href="#SatelliteToolbox.satellite_sun_radiation_earth_pointing"><code>SatelliteToolbox.satellite_sun_radiation_earth_pointing</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">function satellite_sun_radiation_earth_pointing(JD0::Number, a::Number, e::Number, i::Number, RAAN::Number, w::Number, numDays::Integer, fN_k::Function, meanAnomaly::Bool = false, step::Number = 0.1*pi/180.0)</code></pre><p>Compute the Sun radiation on a satellite surface for an Earth-pointing mission.</p><p><strong>Args</strong></p><ul><li><code>JD0</code>: Initial instant for the analysis [Julian day].</li><li><code>a</code>: Semi-major axis of the orbit [m].</li><li><code>e</code>: Orbit eccentricity.</li><li><code>i</code>: Orbit inclination [rad].</li><li><code>w</code>: Argument of perigee [rad].</li><li><code>RAAN</code>: Right ascension of the ascending node at <code>JD0</code> [rad].</li><li><code>numDays</code>: Number of days for the analysis.</li><li><code>fN_k</code>: Function <strong>f(s_b)</strong> that describes the solar panel normal at each k-th         sampling step. Notice that <strong>s_b</strong> is the Sun vector represented in         the body coordinate frame.</li><li><code>meanAnomaly</code>: (OPTIONAL) If <strong>true</strong>, compute using angular steps in the mean                anomaly instead of in the orbit latitude (<strong>Default</strong>: false).</li><li><code>step</code>: (OPTIONAL) Mean anomaly step (<strong>Default</strong>: 0.1 deg).</li></ul><p><strong>Returns</strong></p><p>A matrix containing the Sun radiation [W/m²] for each position in orbit for each day.</p><p><strong>NOTE</strong>: if the Sun angle is larger than 90 deg or if the satellite is in eclipse, then <code>NaN</code> is returned in the matrix.</p><p><strong>Remarks</strong></p><p>The body reference frame is defined as:</p><ul><li><strong>Z axis</strong> points towards the center of Earth;</li><li><strong>Y axis</strong> points towards the negative direction of orbit normal;</li><li><strong>X axis</strong> completes the right-hand reference frame.</li></ul><p>If the <strong>mean anomaly</strong> is used, then the average value of the output is the average sun radiation received by the satellite surface, because every angular steps have a fixed time interval.</p><p>If the <strong>mean anomaly</strong> is used, then the angle interval is [0, 2π]. Otherwise, the angle interval is [-π,π].</p></div></section></article><article class="docstring"><header><a class="docstring-binding" id="SatelliteToolbox.satellite_sun_radiation_earth_pointing_mean" href="#SatelliteToolbox.satellite_sun_radiation_earth_pointing_mean"><code>SatelliteToolbox.satellite_sun_radiation_earth_pointing_mean</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">function satellite_sun_radiation_earth_pointing_mean(JD0::Number, a::Number, e::Number, i::Number, RAAN::Number, w::Number, numDays::Integer, N::AbstractVector, step::Number = 0.1*pi/180.0)</code></pre><p>Compute the mean Sun radiation on a satellite surface for an Earth-pointing mission.</p><p><strong>Args</strong></p><ul><li><code>JD0</code>: Initial instant for the analysis [Julian day].</li><li><code>a</code>: Semi-major axis of the orbit [m].</li><li><code>e</code>: Orbit eccentricity.</li><li><code>i</code>: Orbit inclination [rad].</li><li><code>w</code>: Argument of perigee [rad].</li><li><code>RAAN</code>: Right ascension of the ascending node at <code>JD0</code> [rad].</li><li><code>numDays</code>: Number of days for the analysis.</li><li><code>N</code>: Vector normal to the surface represented in the body reference frame.</li><li><code>meanAnomaly</code>: (OPTIONAL) If <strong>true</strong>, compute using angular steps in the mean                anomaly instead of in the orbit latitude (<strong>Default</strong>: false).</li><li><code>step</code>: (OPTIONAL) Mean anomaly step (<strong>Default</strong>: 0.1 deg).</li></ul><p><strong>Returns</strong></p><p>The mean Sun radiation on a surface [W/m²].</p><p><strong>Remarks</strong></p><p>For more details, see <strong>satellite<em>sun</em>radiation<em>earth</em>pointing</strong>.</p></div></section></article><article class="docstring"><header><a class="docstring-binding" id="SatelliteToolbox.satellite_sun_radiation_earth_pointing_mean" href="#SatelliteToolbox.satellite_sun_radiation_earth_pointing_mean"><code>SatelliteToolbox.satellite_sun_radiation_earth_pointing_mean</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">function satellite_sun_radiation_earth_pointing_mean(JD0::Number, a::Number, e::Number, i::Number, RAAN::Number, w::Number, numDays::Integer, fN_k::Function, step::Number = 0.1*pi/180.0)</code></pre><p>Compute the mean Sun radiation on a satellite surface for an Earth-pointing mission.</p><p><strong>Args</strong></p><ul><li><code>JD0</code>: Initial instant for the analysis [Julian day].</li><li><code>a</code>: Semi-major axis of the orbit [m].</li><li><code>e</code>: Orbit eccentricity.</li><li><code>i</code>: Orbit inclination [rad].</li><li><code>w</code>: Argument of perigee [rad].</li><li><code>RAAN</code>: Right ascension of the ascending node at <code>JD0</code> [rad].</li><li><code>numDays</code>: Number of days for the analysis.</li><li><code>fN_k</code>: Function <strong>f(s_b)</strong> that describes the solar panel normal at each k-th         sampling step. Notice that <strong>s_b</strong> is the Sun vector represented in         the body coordinate frame.</li><li><code>meanAnomaly</code>: (OPTIONAL) If <strong>true</strong>, compute using angular steps in the mean                anomaly instead of in the orbit latitude (<strong>Default</strong>: false).</li><li><code>step</code>: (OPTIONAL) Mean anomaly step (<strong>Default</strong>: 0.1 deg).</li></ul><p><strong>Returns</strong></p><p>The mean Sun radiation on a surface [W/m²].</p><p><strong>Remarks</strong></p><p>For more details, see <strong>satellite<em>sun</em>radiation<em>earth</em>pointing</strong>.</p></div></section></article><article class="docstring"><header><a class="docstring-binding" id="SatelliteToolbox.satsv-Union{Tuple{T4}, Tuple{T3}, Tuple{T2}, Tuple{T1}, Tuple{T1,AbstractArray{T2,1},AbstractArray{T3,1}}, Tuple{T1,AbstractArray{T2,1},AbstractArray{T3,1},AbstractArray{T4,1}}} where T4&lt;:Number where T3&lt;:Number where T2&lt;:Number where T1&lt;:Number" href="#SatelliteToolbox.satsv-Union{Tuple{T4}, Tuple{T3}, Tuple{T2}, Tuple{T1}, Tuple{T1,AbstractArray{T2,1},AbstractArray{T3,1}}, Tuple{T1,AbstractArray{T2,1},AbstractArray{T3,1},AbstractArray{T4,1}}} where T4&lt;:Number where T3&lt;:Number where T2&lt;:Number where T1&lt;:Number"><code>SatelliteToolbox.satsv</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">function satsv(t::T1, r::AbstractVector{T2}, v::AbstractVector{T3} = [0,0,0], a::AbstractVector{T4} = [0,0,0]) where {T1&lt;:Number, T2&lt;:Number, T3&lt;:Number, T4&lt;:Number}
function satsv(t::T1, vec::AbstractVector{T2}) where {T1&lt;:Number, T2&lt;:Number}</code></pre><p>Create a new satellite state vector (see <code>SatelliteStateVector</code>) using the position <code>r</code>, velocity <code>v</code>, and acceleration <code>a</code>. It is also possible to pass a vector <code>vec</code> with the information concatenated.</p><div class="admonition is-info"><header class="admonition-header">Info</header><div class="admonition-body"><p>The vectors <code>r</code>, <code>v</code>, and <code>a</code> must have at least 3 elements. In the case more elements are available, they will be neglected. On the other hand, the vector <code>v</code> must have 6 or 9 dimensions, indicating <code>[r;v]</code>, or <code>[r;v;a]</code>.</p></div></div></div></section></article><article class="docstring"><header><a class="docstring-binding" id="SatelliteToolbox.sim_RAAN_J2-Tuple{Number,Number,Number,Number,Integer}" href="#SatelliteToolbox.sim_RAAN_J2-Tuple{Number,Number,Number,Number,Integer}"><code>SatelliteToolbox.sim_RAAN_J2</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">function sim_RAAN_J2(a::Number, e::Number, i::Number, RAAN_0::Number, numDays::Integer)</code></pre><p>Simulate the RAAN of an orbit with semi-major axis <code>a</code> [m], eccentricity <code>e</code>, inclination <code>i</code> [rad], and initial RAAN <code>RAAN_0</code> [rad] considering J2 perturbations. The analysis is performed for <code>numDays</code> days.</p><p><strong>Returns</strong></p><p>A <code>numDays</code> × 2 matrix in which the i-th line is:</p><pre><code class="language-none">| day | RAAN (0,2π) [rad] |</code></pre></div></section></article><article class="docstring"><header><a class="docstring-binding" id="SatelliteToolbox.sort_list_ss_orbits_by_height-Tuple{Array{T,2} where T}" href="#SatelliteToolbox.sort_list_ss_orbits_by_height-Tuple{Array{T,2} where T}"><code>SatelliteToolbox.sort_list_ss_orbits_by_height</code></a> — <span class="docstring-category">Method</span></header><section><div><p><strong>sort<em>list</em>ss<em>orbits</em>by<em>height(ss</em>orbits::Matrix)</strong></p><p>Sort the list of Sun-synchronous orbits <code>ss_orbits</code> (see <code>list_ss_orbits_by_rep_period</code>) by height and return a new matrix.</p></div></section></article><article class="docstring"><header><a class="docstring-binding" id="SatelliteToolbox.step!-Tuple{OrbitPropagatorJ2,Number}" href="#SatelliteToolbox.step!-Tuple{OrbitPropagatorJ2,Number}"><code>SatelliteToolbox.step!</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">function step!(orbp, Δt::Number)</code></pre><p>Propagate the orbit in <code>orbp</code> by <code>Δt</code> [s] using the algorithm of <code>orbp</code>. The new parameters will be written in <code>orbp</code>.</p><p><strong>Returns</strong></p><ul><li>The Keplerian elements represented in the inertial frame after the step (see <code>Orbit</code>) [SI units].</li><li>The position vector represented in the inertial frame after the step [m].</li><li>The velocity vector represented in the inertial frame after the step [m].</li></ul><p><strong>Remarks</strong></p><p>The inertial frame in which the output is represented depends on which frame it was used to generate the orbit parameters. If the orbit parameters are obtained from a TLE, then the inertial frame will be TEME. Notice, however, that the perturbation theory requires an inertial frame with true equator.</p></div></section></article><article class="docstring"><header><a class="docstring-binding" id="SatelliteToolbox.sun_position_i-Tuple{Number}" href="#SatelliteToolbox.sun_position_i-Tuple{Number}"><code>SatelliteToolbox.sun_position_i</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">function sun_position_i(JD::Number)</code></pre><p>Compute the Sun position represented in the Mean Equinox of Date (MOD) at the Julian Day <code>JD</code>. The algorithm was adapted from [3, p. 277-279].</p></div></section></article><article class="docstring"><header><a class="docstring-binding" id="SatelliteToolbox.sun_velocity_i-Tuple{Number}" href="#SatelliteToolbox.sun_velocity_i-Tuple{Number}"><code>SatelliteToolbox.sun_velocity_i</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">function sun_velocity_i(JD::Number)</code></pre><p>Compute the Sun velocity represented in the Mean Equinox of Date (MOD) at the Julian Day <code>JD</code>. The algorithm was obtained by computing the time derivative of the Sun position in [3, p. 277-279].</p></div></section></article><article class="docstring"><header><a class="docstring-binding" id="SatelliteToolbox.svECEFtoECEF-Tuple{SatelliteToolbox.SatelliteStateVector,Vararg{Any,N} where N}" href="#SatelliteToolbox.svECEFtoECEF-Tuple{SatelliteToolbox.SatelliteStateVector,Vararg{Any,N} where N}"><code>SatelliteToolbox.svECEFtoECEF</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">function svECEFtoECEF(sv::SatelliteStateVector, args...)</code></pre><p>Convert the satellite state vector <code>sv</code> from an ECEF frame to another ECEF frame. The arguments <code>args...</code> must match those of the function <code>rECEFtoECEF</code> <strong>wihtout</strong> the rotation representation.</p></div></section></article><article class="docstring"><header><a class="docstring-binding" id="SatelliteToolbox.svECEFtoECI-Tuple{SatelliteToolbox.SatelliteStateVector,Type{Val{:ITRF}},Union{Type{Val{:GCRF}}, Type{Val{:J2000}}, Type{Val{:TOD}}, Type{Val{:MOD}}, Type{Val{:TEME}}},Number,EOPData_IAU1980}" href="#SatelliteToolbox.svECEFtoECI-Tuple{SatelliteToolbox.SatelliteStateVector,Type{Val{:ITRF}},Union{Type{Val{:GCRF}}, Type{Val{:J2000}}, Type{Val{:TOD}}, Type{Val{:MOD}}, Type{Val{:TEME}}},Number,EOPData_IAU1980}"><code>SatelliteToolbox.svECEFtoECI</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">function svECEFtoECI(sv::SatelliteStateVector, ECEF, ECI, JD_UTC [, eop_data])</code></pre><p>Convert the satellite state vector <code>sv</code> from the Earth-Centered, Earth-Fixed (ECEF) reference frame <code>ECEF</code> to the Earth-Centered Inertial (ECI) reference frame at the Julian day <code>JD_UTC</code> [UTC]. The <code>eop_data</code> may be required depending on the selection of the input and output reference system. For more information, see the documentation of the function <code>rECEFtoECI</code>.</p><div class="admonition is-info"><header class="admonition-header">Info</header><div class="admonition-body"><p>It is assumed that the input velocity and acceleration in <code>sv</code> are obtained by an observer on the ECEF frame. Thus, the output will contain the velocity and acceleration as measured by an observer on the ECI frame.</p></div></div></div></section></article><article class="docstring"><header><a class="docstring-binding" id="SatelliteToolbox.svECItoECEF-Tuple{SatelliteToolbox.SatelliteStateVector,Union{Type{Val{:GCRF}}, Type{Val{:J2000}}, Type{Val{:TOD}}, Type{Val{:MOD}}, Type{Val{:TEME}}},Type{Val{:ITRF}},Number,EOPData_IAU1980}" href="#SatelliteToolbox.svECItoECEF-Tuple{SatelliteToolbox.SatelliteStateVector,Union{Type{Val{:GCRF}}, Type{Val{:J2000}}, Type{Val{:TOD}}, Type{Val{:MOD}}, Type{Val{:TEME}}},Type{Val{:ITRF}},Number,EOPData_IAU1980}"><code>SatelliteToolbox.svECItoECEF</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">function svECItoECEF(sv::SatelliteStateVector, ECI, ECEF, JD_UTC [, eop_data])</code></pre><p>Convert the satellite state vector <code>sv</code> from the Earth-Centered Inertial (ECI) reference frame <code>ECI</code> to the Earth-Centered, Earth-Fixed (ECEF) reference frame at the Julian day <code>JD_UTC</code> [UTC]. The <code>eop_data</code> may be required depending on the selection of the input and output reference system. For more information, see the documentation of the function <code>rECItoECEF</code>.</p><div class="admonition is-info"><header class="admonition-header">Info</header><div class="admonition-body"><p>It is assumed that the input velocity and acceleration in <code>sv</code> are obtained by an observer on the ECI frame. Thus, the output will contain the velocity and acceleration as measured by an observer on the ECEF frame.</p></div></div></div></section></article><article class="docstring"><header><a class="docstring-binding" id="SatelliteToolbox.svECItoECI-Tuple{SatelliteToolbox.SatelliteStateVector,Vararg{Any,N} where N}" href="#SatelliteToolbox.svECItoECI-Tuple{SatelliteToolbox.SatelliteStateVector,Vararg{Any,N} where N}"><code>SatelliteToolbox.svECItoECI</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">function svECItoECI(sv::SatelliteStateVector, args...)</code></pre><p>Convert the satellite state vector <code>sv</code> from an ECI frame to another ECI frame. The arguments <code>args...</code> must match those of the function <code>rECItoECI</code> <strong>wihtout</strong> the rotation representation.</p></div></section></article><article class="docstring"><header><a class="docstring-binding" id="SatelliteToolbox.sv_to_kepler-Tuple{SatelliteToolbox.SatelliteStateVector}" href="#SatelliteToolbox.sv_to_kepler-Tuple{SatelliteToolbox.SatelliteStateVector}"><code>SatelliteToolbox.sv_to_kepler</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">function sv_to_kepler(sv::SatelliteStateVector)</code></pre><p>Convert the state vector <code>sv</code> to Keplerian elements represented by an instance of the structure <code>Orbit</code>.</p></div></section></article><article class="docstring"><header><a class="docstring-binding" id="SatelliteToolbox.swath_width-Tuple{Real,Real}" href="#SatelliteToolbox.swath_width-Tuple{Real,Real}"><code>SatelliteToolbox.swath_width</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">function swath_width(h::real, HalfFOV::real)</code></pre><p>Compute the swath width given the orbit altitude and the half FOV.</p><p><strong>Args</strong></p><ul><li><code>h</code>: Orbit altitude [m].</li><li><code>HalfFOV</code>: Half field of view [rad].</li></ul><p><strong>Returns</strong></p><p>The swath width [m].</p></div></section></article><article class="docstring"><header><a class="docstring-binding" id="SatelliteToolbox.twobody!-Tuple{TwoBody_Structure,Number}" href="#SatelliteToolbox.twobody!-Tuple{TwoBody_Structure,Number}"><code>SatelliteToolbox.twobody!</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">function twobody!(tbd::TwoBody_Structure, t::Number)</code></pre><p>Propagate the orbit defined in <code>tbd</code> (see <code>TwoBody_Structure</code>) until the time <code>t</code> [s]. Notice that the values in <code>tbd</code> will be modified.</p><p><strong>Returns</strong></p><ul><li>The position vector represented in the inertial frame at time <code>t</code> [m].</li><li>The velocity vector represented in the inertial frame at time <code>t</code> [m/s]</li></ul><p><strong>Remarks</strong></p><p>The inertial frame in which the output is represented depends on which frame it was used to generate the orbit parameters. If the orbit parameters are obtained from a TLE, then the inertial frame will be TEME.</p></div></section></article><article class="docstring"><header><a class="docstring-binding" id="SatelliteToolbox.twobody_init-Union{Tuple{T}, Tuple{Number,Number,Number,Number,Number,Number,Number,T}} where T" href="#SatelliteToolbox.twobody_init-Union{Tuple{T}, Tuple{Number,Number,Number,Number,Number,Number,Number,T}} where T"><code>SatelliteToolbox.twobody_init</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">function twobody_init(epoch::Number, a_0::Number, e_0::Number, i_0::Number, Ω_0::Number, ω_0::Number, f_0::Number, μ::T) where T</code></pre><p>Initialize the data structure of Two Body orbit propagator algorithm.</p><p><strong>Args</strong></p><ul><li><code>epoch</code>: Epoch of the orbital elements [s].</li><li><code>a_0</code>: Initial semi-major axis [m].</li><li><code>e_0</code>: Initial eccentricity.</li><li><code>i_0</code>: Initial inclination [rad].</li><li><code>Ω_0</code>: Initial right ascension of the ascending node [rad].</li><li><code>ω_0</code>: Initial argument of perigee [rad].</li><li><code>f_0</code>: Initial true anomaly.</li><li><code>μ</code>: Standard gravitational parameter of the central body [m^3/s^2].</li></ul><p><strong>Returns</strong></p><p>The structure <code>TwoBody_Structure</code> with the initialized parameters.</p></div></section></article><article class="docstring"><header><a class="docstring-binding" id="SatelliteToolbox.@check_orbit-Tuple{Any,Any}" href="#SatelliteToolbox.@check_orbit-Tuple{Any,Any}"><code>SatelliteToolbox.@check_orbit</code></a> — <span class="docstring-category">Macro</span></header><section><div><pre><code class="language-julia">macro check_orbit(a, e)</code></pre><p>Verify if the orbit with semi-major axis <code>a</code> [m] and eccentricity <code>e</code> is valid. This macro throws an exception if the orbit is not valid.</p><p>Return <code>true</code> is the orbit is valid, and <code>false</code> otherwise.</p></div></section></article><article class="docstring"><header><a class="docstring-binding" id="SatelliteToolbox._expatmosphere_H" href="#SatelliteToolbox._expatmosphere_H"><code>SatelliteToolbox._expatmosphere_H</code></a> — <span class="docstring-category">Constant</span></header><section><div><p>Scale height for the exponential atmospheric model [km].</p></div></section></article><article class="docstring"><header><a class="docstring-binding" id="SatelliteToolbox._expatmosphere_h₀" href="#SatelliteToolbox._expatmosphere_h₀"><code>SatelliteToolbox._expatmosphere_h₀</code></a> — <span class="docstring-category">Constant</span></header><section><div><p>Base altitude for the exponential atmospheric model [km].</p></div></section></article><article class="docstring"><header><a class="docstring-binding" id="SatelliteToolbox._expatmosphere_ρ₀" href="#SatelliteToolbox._expatmosphere_ρ₀"><code>SatelliteToolbox._expatmosphere_ρ₀</code></a> — <span class="docstring-category">Constant</span></header><section><div><p>Nominal density for the exponential atmospheric model [kg/m³].</p></div></section></article><article class="docstring"><header><a class="docstring-binding" id="SatelliteToolbox._jr1971_constants" href="#SatelliteToolbox._jr1971_constants"><code>SatelliteToolbox._jr1971_constants</code></a> — <span class="docstring-category">Constant</span></header><section><div><p>Constants for the Jacchia-Roberts 1971 Atmospheric Model.</p></div></section></article><article class="docstring"><header><a class="docstring-binding" id="SatelliteToolbox._jr1971_id" href="#SatelliteToolbox._jr1971_id"><code>SatelliteToolbox._jr1971_id</code></a> — <span class="docstring-category">Constant</span></header><section><div><p>Index of the species for the Jacchia-Roberts 1971 Atmospheric Model.</p></div></section></article><article class="docstring"><header><a class="docstring-binding" id="SatelliteToolbox.JR1971_CONSTANTS" href="#SatelliteToolbox.JR1971_CONSTANTS"><code>SatelliteToolbox.JR1971_CONSTANTS</code></a> — <span class="docstring-category">Type</span></header><section><div><p>Structure with the constants for the Jacchia-Roberts 1971 Atmospheric Model.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaLang/julia/blob/2d5741174ce3e6a394010d2e470e4269ca54607f/base/#L0-L3">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="SatelliteToolbox.SatelliteStateVector" href="#SatelliteToolbox.SatelliteStateVector"><code>SatelliteToolbox.SatelliteStateVector</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia">mutable struct StateVector{T}</code></pre><p>Store the state vector of the satellite.</p><p><strong>Fields</strong></p><ul><li><code>t</code>: Epoch [Julian Day].</li><li><code>r</code>: Position vector [m].</li><li><code>v</code>: Velocity vector [m/s].</li><li><code>a</code>: Acceleration vector [m/s²].</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaLang/julia/blob/2d5741174ce3e6a394010d2e470e4269ca54607f/base/#L0-L12">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="SatelliteToolbox._DTCFILE_Structure" href="#SatelliteToolbox._DTCFILE_Structure"><code>SatelliteToolbox._DTCFILE_Structure</code></a> — <span class="docstring-category">Type</span></header><section><div><p>Structure to store the interpolations of the data in <code>DTCFILE.TXT</code> file.</p><p><strong>Fields</strong></p><ul><li><code>DstΔTc</code>: Temperature variation due to Dst [K].</li></ul></div></section></article><article class="docstring"><header><a class="docstring-binding" id="SatelliteToolbox._SOLFSMY_Structure" href="#SatelliteToolbox._SOLFSMY_Structure"><code>SatelliteToolbox._SOLFSMY_Structure</code></a> — <span class="docstring-category">Type</span></header><section><div><p>Structure to store the interpolations of the data in <code>SOLFSMY.TXT</code> file.</p><p><strong>Fields</strong></p><ul><li><code>F10</code>: 10.7-cm solar flux [10⁻²² W/(m² Hz)].</li><li><code>F81a</code>: 10.7-cm averaged solar flux, 81-day centered on input time.</li><li><code>S10</code>: EUV index.</li><li><code>S81a</code>: EUV 81-day averaged centered index.</li><li><code>M10</code>: MG2 index scaled to F10.</li><li><code>M81a</code>: MG2 81-day averaged centered index.</li><li><code>Y81a</code>: Solar X-ray &amp; Lya 81-day averaged centered index.</li><li><code>Y81a</code>: Solar X-ray &amp; Lya 81-day averaged centered index.</li></ul></div></section></article><article class="docstring"><header><a class="docstring-binding" id="SatelliteToolbox._WDC_Structure" href="#SatelliteToolbox._WDC_Structure"><code>SatelliteToolbox._WDC_Structure</code></a> — <span class="docstring-category">Type</span></header><section><div><p>Structure to store the interpolations of the data in WDC files.</p><p><strong>Fields</strong></p><ul><li><code>Kp</code>: Kp index.</li><li><code>Ap</code>: Ap index.</li></ul></div></section></article><article class="docstring"><header><a class="docstring-binding" id="SatelliteToolbox._ccor-Union{Tuple{T}, NTuple{4,T}} where T&lt;:Number" href="#SatelliteToolbox._ccor-Union{Tuple{T}, NTuple{4,T}} where T&lt;:Number"><code>SatelliteToolbox._ccor</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">function _ccor(alt::T, r::T, h1::T, zh::T) where T&lt;:Number</code></pre><p>Chemistry / Dissociation correction for MSIS models.</p><p><strong>Args</strong></p><ul><li><code>alt</code>: Altitude.</li><li><code>r</code>: Target ratio.</li><li><code>h1</code>: Transition scale length.</li><li><code>zh</code>: Altitude of <code>1/2 r</code>.</li></ul><p><strong>Returns</strong></p><p>The chemistry / dissociation correction.</p></div></section></article><article class="docstring"><header><a class="docstring-binding" id="SatelliteToolbox._ccor2-Union{Tuple{T}, NTuple{5,T}} where T&lt;:Number" href="#SatelliteToolbox._ccor2-Union{Tuple{T}, NTuple{5,T}} where T&lt;:Number"><code>SatelliteToolbox._ccor2</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">function _ccor2(alt::T, r::T, h1::T, zh::T, h2::T) where T&lt;:Number</code></pre><p>Chemistry / Dissociation correction for MSIS models.</p><p><strong>Args</strong></p><ul><li><code>alt</code>: Altitude.</li><li><code>r</code>: Target ration.</li><li><code>h1</code>: Transition scale length.</li><li><code>zh</code>: Altitude of <code>1/2 r</code>.</li><li><code>h2</code>: Transition scale length 2.</li></ul><p><strong>Returns</strong></p><p>The chemistry / dissociation correction.</p></div></section></article><article class="docstring"><header><a class="docstring-binding" id="SatelliteToolbox._densm-Union{Tuple{N3}, Tuple{N2}, Tuple{T}, Tuple{T,T,T,T,T,T,StaticArrays.StaticArray{Tuple{N3},T,1},AbstractArray{T,1},AbstractArray{T,1},StaticArrays.StaticArray{Tuple{N2},T,1},AbstractArray{T,1},AbstractArray{T,1}}} where N3 where N2 where T&lt;:Number" href="#SatelliteToolbox._densm-Union{Tuple{N3}, Tuple{N2}, Tuple{T}, Tuple{T,T,T,T,T,T,StaticArrays.StaticArray{Tuple{N3},T,1},AbstractArray{T,1},AbstractArray{T,1},StaticArrays.StaticArray{Tuple{N2},T,1},AbstractArray{T,1},AbstractArray{T,1}}} where N3 where N2 where T&lt;:Number"><code>SatelliteToolbox._densm</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">function _densm(re::T, gsurf::T, alt::T, d0::T, xm::T, tz::T, zn3::StaticVector{N3,T}, tn3::AbstractVector{T}, tgn3::AbstractVector{T}, zn2::StaticVector{N2,T}, tn2::AbstractVector{T}, tgn2::AbstractVector{T}) where T&lt;:Number where N2 where N3</code></pre><p>Compute the temperature and density profiles for lower atmosphere.</p><p><strong>Returns</strong></p><ul><li>The density.</li><li>The temperature.</li></ul></div></section></article><article class="docstring"><header><a class="docstring-binding" id="SatelliteToolbox._densu-Union{Tuple{N}, Tuple{T}, Tuple{T,T,T,T,T,T,T,T,T,T,StaticArrays.StaticArray{Tuple{N},T,1},AbstractArray{T,1},AbstractArray{T,1}}} where N where T&lt;:Number" href="#SatelliteToolbox._densu-Union{Tuple{N}, Tuple{T}, Tuple{T,T,T,T,T,T,T,T,T,T,StaticArrays.StaticArray{Tuple{N},T,1},AbstractArray{T,1},AbstractArray{T,1}}} where N where T&lt;:Number"><code>SatelliteToolbox._densu</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">function _densu(re::T, gsurf::T, alt::T, dlb::T, tinf::T, tlb::T, xm::T, alpha::T, zlb::T, s2::T, zn1::StaticVector{N,T}, tn1::AbstractVector{T}, tgn1::AbstractVector{T}) where T&lt;:Number where N</code></pre><p>Compute the temperature and density profiles for MSIS models.</p><p>This algorithm uses new lower thermo polynomial.</p><p><strong>Returns</strong></p><ul><li>The density.</li><li>The temperature.</li></ul></div></section></article><article class="docstring"><header><a class="docstring-binding" id="SatelliteToolbox._dnet-Union{Tuple{T}, NTuple{5,T}} where T&lt;:Number" href="#SatelliteToolbox._dnet-Union{Tuple{T}, NTuple{5,T}} where T&lt;:Number"><code>SatelliteToolbox._dnet</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">function _dnet(dd::T, dm::T, zhm::T, xmm::T, xm::T) where T&lt;:Number</code></pre><p>Turbopause correction for MSIS models.</p><p><strong>Args</strong></p><ul><li><code>dd</code>: Diffusive density.</li><li><code>dm</code>: Full mixed density.</li><li><code>zhm</code>: Transition scale length.</li><li><code>xmm</code>: Full mixed molecular weight.</li><li><code>xm</code>: Species molecular weight.</li></ul><p><strong>Returns</strong></p><p>The combined density.</p></div></section></article><article class="docstring"><header><a class="docstring-binding" id="SatelliteToolbox._glob7s-Union{Tuple{T}, Tuple{AbstractArray{T,1},NRLMSISE00_Structure{T}}} where T&lt;:Number" href="#SatelliteToolbox._glob7s-Union{Tuple{T}, Tuple{AbstractArray{T,1},NRLMSISE00_Structure{T}}} where T&lt;:Number"><code>SatelliteToolbox._glob7s</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">function _glob7s(p::AbstractVector{T}, nrlmsise00d::NRLMSISE00_Structure{T}) where T&lt;:Number</code></pre><p>Version of Globe for lower atmosphere (1999-10-26).</p><p><strong>Args</strong></p><ul><li><code>p</code>: Vector with the coefficients.</li><li><code>nrlmsise00d</code>: NRLMSISE-00 structure (see <code>NRLMSISE00_Structure</code>).</li></ul><p><strong>Returns</strong></p><p>The temperature (?).</p></div></section></article><article class="docstring"><header><a class="docstring-binding" id="SatelliteToolbox._globe7!-Union{Tuple{T}, Tuple{AbstractArray{T,1},NRLMSISE00_Structure{T}}} where T&lt;:Number" href="#SatelliteToolbox._globe7!-Union{Tuple{T}, Tuple{AbstractArray{T,1},NRLMSISE00_Structure{T}}} where T&lt;:Number"><code>SatelliteToolbox._globe7!</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">function _globe7!(p::AbstractVector{T}, nrlmsise00d::NRLMSISE00_Structure{T}) where T&lt;:Number</code></pre><p>Compute G(L) function.</p><p>Notice that the parameters <code>apt</code> and <code>apdf</code> of structure <code>nrlmsise00d</code> are modified.</p><p><strong>Args</strong></p><ul><li><code>p</code>: Vector with the coefficients.</li><li><code>nrlmsise00d</code>: NRLMSISE-00 structure (see <code>NRLMSISE00_Structure</code>).</li></ul><p><strong>Returns</strong></p><p>The temperature (?).</p></div></section></article><article class="docstring"><header><a class="docstring-binding" id="SatelliteToolbox._init_dtcfile-Tuple{}" href="#SatelliteToolbox._init_dtcfile-Tuple{}"><code>SatelliteToolbox._init_dtcfile</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">function _init_dctfile(;force_download = false, local_path = nothing)</code></pre><p>Initialize the data in the file <code>DTCFILE.TXT</code> by creating <code>_dtcfile_data</code>. The initialization process is composed of:</p><ol><li>Download the file, if it is necessary;</li><li>Parse the file;</li><li>Create the interpolations and the structures.</li></ol><p>If the keyword <code>force_download</code> is <code>true</code>, then the file will always be downloaded.</p><p>The user can also specify a location for the file using the keyword <code>local_path</code>. If it is <code>nothing</code>, which is the default, then the file will be downloaded.</p></div></section></article><article class="docstring"><header><a class="docstring-binding" id="SatelliteToolbox._init_fluxtable-Tuple{}" href="#SatelliteToolbox._init_fluxtable-Tuple{}"><code>SatelliteToolbox._init_fluxtable</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">function _init_fluxtable(;force_download = false, local_path = nothing)</code></pre><p>Initialize the data in the file <code>fluxtable.txt</code> by creating <code>_fluxtable_data</code>. The initialization process is composed of:</p><ol><li>Download the file, if it is necessary;</li><li>Parse the file;</li><li>Create the interpolations and the structures.</li></ol><p>If the keyword <code>force_download</code> is <code>true</code>, then the file will always be downloaded.</p><p>The user can also specify a location for the file using the keyword <code>local_path</code>. If it is <code>nothing</code>, which is the default, then the file will be downloaded.</p></div></section></article><article class="docstring"><header><a class="docstring-binding" id="SatelliteToolbox._init_solfsmy-Tuple{}" href="#SatelliteToolbox._init_solfsmy-Tuple{}"><code>SatelliteToolbox._init_solfsmy</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">function _init_solfsmy(;force_download = false, local_path = nothing)</code></pre><p>Initialize the data in the file <code>SOLFSMY.TXT</code> by creating <code>_solfsmy_data</code>. The initialization process is composed of:</p><ol><li>Download the file, if it is necessary;</li><li>Parse the file;</li><li>Create the interpolations and the structures.</li></ol><p>If the keyword <code>force_download</code> is <code>true</code>, then the file will always be downloaded.</p><p>The user can also specify a location for the file using the keyword <code>local_path</code>. If it is <code>nothing</code>, which is the default, then the file will be downloaded.</p></div></section></article><article class="docstring"><header><a class="docstring-binding" id="SatelliteToolbox._init_wdcfiles-Tuple{}" href="#SatelliteToolbox._init_wdcfiles-Tuple{}"><code>SatelliteToolbox._init_wdcfiles</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">function _init_wdcfiles(;force_download = false, local_dir = nothing, wdcfiles_oldest_year = year(now())-3)</code></pre><p>Initialize the data in the WDC files by creating <code>_wdcfiles_data</code>. The initialization process is composed of:</p><ol><li>Download the files, if it is necessary;</li><li>Parse the files;</li><li>Create the interpolations and the structures.</li></ol><p>If the keyword <code>force_download</code> is <code>true</code>, then the files will always be downloaded.</p><p>The user can also specify a location for the directory with the WDC files using the keyword <code>local_dir</code>. If it is <code>nothing</code>, which is the default, then the file will be downloaded.</p><p>The user can select what is the oldest year in which the data will be downloaded by the keyword <code>wdcfiles_oldest_year</code>. By default, it will download the data from 3 previous years.</p><p>The user can select what is the newest year in which the data will be downloaded by the keyword <code>wdcfiles_newest_year</code>. It it is <code>nothing</code>, which is the default, then it is set to the current year.</p></div></section></article><article class="docstring"><header><a class="docstring-binding" id="SatelliteToolbox._jb2008_M-Union{Tuple{R}, Tuple{R}} where R" href="#SatelliteToolbox._jb2008_M-Union{Tuple{R}, Tuple{R}} where R"><code>SatelliteToolbox._jb2008_M</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">function _jb2008_M(z::R) where R</code></pre><p>Compute the mean molecular mass at altitude <code>z</code> [km] using the empirical profile in eq. 1 [3].</p></div></section></article><article class="docstring"><header><a class="docstring-binding" id="SatelliteToolbox._jb2008_T-Union{Tuple{R}, Tuple{R,R,R}} where R&lt;:Number" href="#SatelliteToolbox._jb2008_T-Union{Tuple{R}, Tuple{R,R,R}} where R&lt;:Number"><code>SatelliteToolbox._jb2008_T</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">function _jb2008_T(z::R, Tx::R, T∞::R) where R&lt;:Number</code></pre><p>Compute the temperature [K] at height <code>z</code> [km] given the temperature <code>Tx</code> [K] at the inflection point, and the exospheric temperature <code>T∞</code> [K] according to the theory of the model Jacchia 1971 [3].</p><p>The inflection point is considered to by <code>z = 125 km</code>.</p></div></section></article><article class="docstring"><header><a class="docstring-binding" id="SatelliteToolbox._jb2008_grav-Union{Tuple{R}, Tuple{R}} where R" href="#SatelliteToolbox._jb2008_grav-Union{Tuple{R}, Tuple{R}} where R"><code>SatelliteToolbox._jb2008_grav</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">function _jb2008_grav(z::R) where R</code></pre><p>Compute the gravity [m/s] at altitude <code>z</code> [km] according to the model Jacchia 1971 [3].</p></div></section></article><article class="docstring"><header><a class="docstring-binding" id="SatelliteToolbox._jb2008_highaltitude-Tuple{Number,Number}" href="#SatelliteToolbox._jb2008_highaltitude-Tuple{Number,Number}"><code>SatelliteToolbox._jb2008_highaltitude</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">function _jb2008_highaltitude(h::Number, F10ₐ::Number)</code></pre><p>Compute the high altitude exospheric density correction factor in altitude <code>h</code> [km] and the averaged 10.7-cm solar flux (81-day centered on input time) [10⁻²² W/(M² Hz)].</p><p>This function uses the model in Section 6.2 of [2].</p></div></section></article><article class="docstring"><header><a class="docstring-binding" id="SatelliteToolbox._jb2008_int-Tuple{Number,Number,Number,Number,Number,Function}" href="#SatelliteToolbox._jb2008_int-Tuple{Number,Number,Number,Number,Number,Function}"><code>SatelliteToolbox._jb2008_int</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">function _jb2008_int(z₀::Number, z₁::Number, R::Number, Tx::Number, T∞::Number, δf::Function)</code></pre><p>Compute the integral of the function <code>δf</code> between <code>z₀</code> and <code>z₁</code> using the Newton-Cotes 4th degree method. <code>R</code> is a number that defines the step size, <code>Tx</code> is the temperature at the inflection point, and <code>T∞</code> is the exospheric temperature.</p><p>The signature of the function <code>δf</code> is:</p><pre><code class="language-none">δf(z, Tx, T∞)</code></pre><p>and it must be <code>_jb2008_δf1</code> or <code>_jb2008_δf2</code>.</p><p>This function returns a tuple containing the integral and last value of <code>z</code> used in the numerical algorithm.</p></div></section></article><article class="docstring"><header><a class="docstring-binding" id="SatelliteToolbox._jb2008_semiannual-NTuple{5,Number}" href="#SatelliteToolbox._jb2008_semiannual-NTuple{5,Number}"><code>SatelliteToolbox._jb2008_semiannual</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">function _jb2008_semiannual(doy::Number, h::Number, F10ₐ::Number, S10ₐ::Number, M10ₐ::Number)</code></pre><p>Compute the semiannual variation of the density considering the JB2008 model [1].</p><p><strong>Args</strong></p><ul><li><code>doy</code>: Day of the year + fraction of the day.</li><li><code>h</code>: Height [km].</li><li><code>F10ₐ</code>: Averaged 10.7-cm flux (81-day centered on input-time)         [10⁻²² W/(M² Hz)].</li><li><code>S10ₐ</code>: EUV 81-day averaged centered index.</li><li><code>M10ₐ</code>: MG2 81-day averaged centered index.</li></ul><p><strong>Returns</strong></p><ul><li>Semiannual F(z) heigh function.</li><li>Semiannual G(t) yearly periodic function.</li><li>Semiannual variation of the density <code>Δsalog₁₀ρ</code>.</li></ul></div></section></article><article class="docstring"><header><a class="docstring-binding" id="SatelliteToolbox._jb2008_ΔTc-NTuple{4,Number}" href="#SatelliteToolbox._jb2008_ΔTc-NTuple{4,Number}"><code>SatelliteToolbox._jb2008_ΔTc</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">function _jb2008_ΔTc(F10::Number, lst::Number, glat::Number, h::Number)</code></pre><p>Compute the correction in the <code>Tc</code> for Jacchia-Bowman model.</p><p>This correction is mention in [2]. However, the equations do not seem to match those in the source-code. The ones implemented here are exactly the same as in the source-code.</p><p><strong>Args</strong></p><ul><li><code>F10</code>: F10.7 flux.</li><li><code>lst</code>: Local solar time (0 - 24) [hr].</li><li><code>glat</code>: Geocentric latitude [rad].</li><li><code>h</code>: Altitude [km].</li></ul><p><strong>Returns</strong></p><p>The correction <code>ΔTc</code> [K].</p></div></section></article><article class="docstring"><header><a class="docstring-binding" id="SatelliteToolbox._jb2008_δf1-Tuple{Any,Any,Any}" href="#SatelliteToolbox._jb2008_δf1-Tuple{Any,Any,Any}"><code>SatelliteToolbox._jb2008_δf1</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">function _jb2008_δf1(z, Tx, T∞)</code></pre><p>Auxiliary function to compute the integrand in <code>_jb2008_int</code>.</p></div></section></article><article class="docstring"><header><a class="docstring-binding" id="SatelliteToolbox._jb2008_δf2-Tuple{Any,Any,Any}" href="#SatelliteToolbox._jb2008_δf2-Tuple{Any,Any,Any}"><code>SatelliteToolbox._jb2008_δf2</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">function _jb2008_δf2(z, Tx, T∞)</code></pre><p>Auxiliary function to compute the integrand in <code>_jb2008_int</code>.</p></div></section></article><article class="docstring"><header><a class="docstring-binding" id="SatelliteToolbox._jr1971_M-Union{Tuple{R}, Tuple{R}} where R" href="#SatelliteToolbox._jr1971_M-Union{Tuple{R}, Tuple{R}} where R"><code>SatelliteToolbox._jr1971_M</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">function _jr1971_M(z::R) where R</code></pre><p>Compute the mean molecular mass at altitude <code>z</code> [km] using the empirical profile in eq. 1 [3,4].</p></div></section></article><article class="docstring"><header><a class="docstring-binding" id="SatelliteToolbox._jr1971_T-Union{Tuple{R}, Tuple{R,R,R}} where R&lt;:Number" href="#SatelliteToolbox._jr1971_T-Union{Tuple{R}, Tuple{R,R,R}} where R&lt;:Number"><code>SatelliteToolbox._jr1971_T</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">function _jr1971_T(z::R, Tx::R, T∞::R) where R&lt;:Number</code></pre><p>Compute the temperature [K] at height <code>z</code> [km] given the temperature <code>Tx</code> [K] at the inflection point, and the exospheric temperature <code>T∞</code> [K] according to the theory of the model Jacchia-Roberts 1971 [1,3,4].</p><p>The inflection point is considered to by <code>z = 125 km</code>.</p></div></section></article><article class="docstring"><header><a class="docstring-binding" id="SatelliteToolbox._jr1971_roots-Union{Tuple{Array{R,1}}, Tuple{R}} where R" href="#SatelliteToolbox._jr1971_roots-Union{Tuple{Array{R,1}}, Tuple{R}} where R"><code>SatelliteToolbox._jr1971_roots</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">function _jr1971_roots(p::Polynomial{R}) where R</code></pre><p>Compute the roots of the polynomial <code>p</code> necessary to compute the density below 125 km. It returns the value <code>r₁</code>, <code>r₂</code>, <code>x</code>, and <code>y</code>.</p></div></section></article><article class="docstring"><header><a class="docstring-binding" id="SatelliteToolbox._parse_dtcfile-Tuple{AbstractString}" href="#SatelliteToolbox._parse_dtcfile-Tuple{AbstractString}"><code>SatelliteToolbox._parse_dtcfile</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">function _parse_dtcfile(path::AbstractString)</code></pre><p>Parse the <code>DTCFILE.TXT</code> file in <code>path</code> and return an instance of the structure <code>_DTCFILE_Structure</code> with the initialized interpolations.</p><p>The format of the file <code>DTCFILE.TXT</code> must be:</p><pre><code class="language-none">DTC YYYY DOY DTC_0h DTC_1h DTC_2h ... DTC_22h DTC_23h</code></pre><p>in which <code>DOY</code> is the day of the year and <code>DTC_Xh</code> is the <code>ΔTc</code> at hour <code>X</code>.</p></div></section></article><article class="docstring"><header><a class="docstring-binding" id="SatelliteToolbox._parse_fluxtable-Tuple{AbstractString}" href="#SatelliteToolbox._parse_fluxtable-Tuple{AbstractString}"><code>SatelliteToolbox._parse_fluxtable</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">function _parse_fluxtable(path::AbstractString)</code></pre><p>Parse the <code>fluxtable.txt</code> file in <code>path</code> and return an instance of the structure <code>_fluxtable_Structure</code> with the initialize interpolations.</p></div></section></article><article class="docstring"><header><a class="docstring-binding" id="SatelliteToolbox._parse_solfsmy-Tuple{AbstractString}" href="#SatelliteToolbox._parse_solfsmy-Tuple{AbstractString}"><code>SatelliteToolbox._parse_solfsmy</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">function _parse_solfsmy(path::AbstractString)</code></pre><p>Parse the <code>SOLFSMY.TXT</code> file in <code>path</code> and retur an instance of the structure <code>_SOLFSMY_Structure</code> with the initialized interpolations.</p><p>The format of the file <code>SOLFSMY.TXT</code> must be:</p><pre><code class="language-none">YYYY DDD   JulianDay  F10   F81c  S10   S81c  M10   M81c  Y10   Y81c  Ssrc</code></pre></div></section></article><article class="docstring"><header><a class="docstring-binding" id="SatelliteToolbox._parse_wdcfiles-Tuple{Array{String,1},Array{Int64,1}}" href="#SatelliteToolbox._parse_wdcfiles-Tuple{Array{String,1},Array{Int64,1}}"><code>SatelliteToolbox._parse_wdcfiles</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">function _parse_wdcfiles(filepaths::Vector{String}, years::Vector{Int})</code></pre><p>Parse the WDC files with paths in <code>filepaths</code> related to the years in <code>years</code>.</p><p><strong>Notice that the files must be sorted by the year!</strong></p></div></section></article><article class="docstring"><header><a class="docstring-binding" id="SatelliteToolbox._prepare_wdc_remote_files-Tuple{Number,Number}" href="#SatelliteToolbox._prepare_wdc_remote_files-Tuple{Number,Number}"><code>SatelliteToolbox._prepare_wdc_remote_files</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">function _prepare_wdc_remote_files(oldest_year::Number, newest_year::Number)</code></pre><p>Configure all the WDC remote files between <code>newest_year</code> and <code>oldest_year</code>. Notice that previous years will never be updated whereas the current year will be updated daily.</p><p>If <code>oldest_year</code> is greater than current year, then only the files from the current year will be downloaded.</p><p>If <code>newest_year</code> is smaller than <code>oldest_year</code>, then only the files from the <code>oldest_year</code> will be downloaded.</p><p>This function modifies the global variable <code>_wdcfiles</code>.</p></div></section></article><article class="docstring"><header><a class="docstring-binding" id="SatelliteToolbox._spline-Union{Tuple{N}, Tuple{T}, Tuple{StaticArrays.StaticArray{Tuple{N},T,1},StaticArrays.StaticArray{Tuple{N},T,1},T,T}} where N where T&lt;:Number" href="#SatelliteToolbox._spline-Union{Tuple{N}, Tuple{T}, Tuple{StaticArrays.StaticArray{Tuple{N},T,1},StaticArrays.StaticArray{Tuple{N},T,1},T,T}} where N where T&lt;:Number"><code>SatelliteToolbox._spline</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">function _spline(x::StaticVector{N,T}, y::StaticVector{N,T}, yp1::T, ypn::T) where {T&lt;:Number,N}</code></pre><p>Compute the 2nd derivatives of cubic spline interpolation function tabulated by <code>x</code> and <code>y</code> given the 2nd derivatives values at <code>x[1]</code> (<code>yp1</code>) and at <code>x[N]</code> (<code>ypn</code>).</p><p>This function was adapted from Numerical Recipes.</p><p><strong>Args</strong></p><ul><li><code>x</code>: X components of the tabulated function in ascending order.</li><li><code>y</code>: Y components of the tabulated function evaluated at <code>x</code>.</li><li><code>yp1</code>: 2nd derivative value at <code>x[1]</code>.</li><li><code>ypn</code>: 2nd derivative value at <code>x[N]</code>.</li></ul><p><strong>Returns</strong></p><p>The 2nd derivative of cubic spline interpolation function evaluated at <code>x</code>.</p><p><strong>Remarks</strong></p><p>Values higher than <code>1e30</code> in the 2nd derivatives at the borders (<code>yp1</code> and <code>ypn</code>) are interpreted as <code>0</code>.</p></div></section></article><article class="docstring"><header><a class="docstring-binding" id="SatelliteToolbox._splini-Union{Tuple{N}, Tuple{T}, Tuple{StaticArrays.StaticArray{Tuple{N},T,1},StaticArrays.StaticArray{Tuple{N},T,1},StaticArrays.StaticArray{Tuple{N},T,1},T}} where N where T&lt;:Number" href="#SatelliteToolbox._splini-Union{Tuple{N}, Tuple{T}, Tuple{StaticArrays.StaticArray{Tuple{N},T,1},StaticArrays.StaticArray{Tuple{N},T,1},StaticArrays.StaticArray{Tuple{N},T,1},T}} where N where T&lt;:Number"><code>SatelliteToolbox._splini</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">function _splini(xa::StaticVector{N,T}, ya::StaticVector{N,T}, y2a::StaticVector{N,T}, x::T) where {T&lt;:Number,N}</code></pre><p>Compute the integral of the cubic spline function from <code>xa[1]</code> to <code>x</code>.</p><p><strong>Args</strong></p><ul><li><code>xa</code>: X components of the tabulated function in ascending order.</li><li><code>ya</code>: Y components of the tabulated function evaluated at <code>xa</code>.</li><li><code>y2a</code>: Second derivatives.</li><li><code>x</code>: Abscissa endpoint for integration.</li></ul><p><strong>Returns</strong></p><p>The integral of cubic spline function from <code>xa[1]</code> to <code>x</code>.</p></div></section></article><article class="docstring"><header><a class="docstring-binding" id="SatelliteToolbox._splint-Union{Tuple{N}, Tuple{T}, Tuple{StaticArrays.StaticArray{Tuple{N},T,1},StaticArrays.StaticArray{Tuple{N},T,1},StaticArrays.StaticArray{Tuple{N},T,1},T}} where N where T&lt;:Number" href="#SatelliteToolbox._splint-Union{Tuple{N}, Tuple{T}, Tuple{StaticArrays.StaticArray{Tuple{N},T,1},StaticArrays.StaticArray{Tuple{N},T,1},StaticArrays.StaticArray{Tuple{N},T,1},T}} where N where T&lt;:Number"><code>SatelliteToolbox._splint</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">function _splint(xa::StaticVector{N,T}, ya::StaticVector{N,T}, y2a::StaticVector{N,T}, x::T) where {T&lt;:Number,N}</code></pre><p>Compute the cubic spline interpolation value at <code>x</code>.</p><p>This function was adapted from Numerical Recipes.</p><p><strong>Args</strong></p><ul><li><code>xa</code>: X components of the tabulated function in ascending order.</li><li><code>ya</code>: Y components of the tabulated function evaluated at <code>xa</code>.</li><li><code>y2a</code>: Second derivatives.</li><li><code>x</code>: Abscissa endpoint for interpolation.</li></ul><p><strong>Returns</strong></p><p>The cubic spline interpolation value at <code>x</code>.</p></div></section></article><article class="docstring"><header><a class="docstring-binding" id="SatelliteToolbox.find_crossing-Tuple{Function,Number,Number,Any,Any,Vararg{Any,N} where N}" href="#SatelliteToolbox.find_crossing-Tuple{Function,Number,Number,Any,Any,Vararg{Any,N} where N}"><code>SatelliteToolbox.find_crossing</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">function find_crossing(f::Function, t₀::Number, t₁::Number, s₀, s₁; Δ = 1e-3, max = 100)</code></pre><p>Return the crossing time <code>tc</code> in which the function <code>f(t)</code> goes from the state <code>s₀</code> to the state <code>s₁</code>. It is assumed that <code>f(t₀) = s₀</code> and <code>f(t₁) = s₁</code>.</p><p>If the computed interval is smalled than <code>Δ</code> or if the number of iterations is higher than <code>max</code>, then the algorithm stops.</p></div></section></article><article class="docstring"><header><a class="docstring-binding" id="SatelliteToolbox.gts7-Union{Tuple{NRLMSISE00_Structure{T}}, Tuple{T}} where T&lt;:Number" href="#SatelliteToolbox.gts7-Union{Tuple{NRLMSISE00_Structure{T}}, Tuple{T}} where T&lt;:Number"><code>SatelliteToolbox.gts7</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">function gts7(nrlmsise00d::NRLMSISE00_Structure{T}) where T&lt;:Number</code></pre><p>Thermospheric portion of NRLMSISE-00. This function should not be called to compute NRLMSISE-00. Use <code>gtd7</code> or <code>gtd7d</code> instead.</p><p><strong>Args</strong></p><ul><li><code>nrlmsise00d</code>: An instance of <code>NRLMSISE00_Structure</code>.</li></ul><p><strong>Returns</strong></p><p>An instance of structure <code>NRLMSISE00_Structure</code> with the outputs.</p></div></section></article><article class="docstring"><header><a class="docstring-binding" id="SatelliteToolbox.@_keyword_found-Tuple{Any,Any,Any}" href="#SatelliteToolbox.@_keyword_found-Tuple{Any,Any,Any}"><code>SatelliteToolbox.@_keyword_found</code></a> — <span class="docstring-category">Macro</span></header><section><div><pre><code class="language-julia">macro _keyword_found(keyword, keywords_found, current_line)</code></pre><p>Check if the <code>keyword</code> exists in the list <code>keywords_found</code>. If <code>true</code>, then throw an error indicating that the problem occurred on the <code>current_line</code>.</p></div></section></article><article class="docstring"><header><a class="docstring-binding" id="SatelliteToolbox.@_parse_float-Tuple{Any}" href="#SatelliteToolbox.@_parse_float-Tuple{Any}"><code>SatelliteToolbox.@_parse_float</code></a> — <span class="docstring-category">Macro</span></header><section><div><pre><code class="language-julia">macro _parse_float(input)</code></pre><p>Parse the <code>input</code> to float substituting all <code>D</code>s and <code>d</code>s  to <code>e</code>, so that we can convert numbers in FORTRAN format.</p></div></section></article><section class="footnotes is-size-7"><ul><li class="footnote" id="footnote-1"><a class="tag is-link" href="#citeref-1">1</a>TEME is an <em>of date</em> frame.</li></ul></section></article><nav class="docs-footer"><a class="docs-footer-prevpage" href="../../man/transformations/geodetic_geocentric/">« Geodetic and Geocentric</a></nav></div><div class="modal" id="documenter-settings"><div class="modal-background"></div><div class="modal-card"><header class="modal-card-head"><p class="modal-card-title">Settings</p><button class="delete"></button></header><section class="modal-card-body"><p><label class="label">Theme</label><div class="select"><select id="documenter-themepicker"><option value="documenter-light">documenter-light</option><option value="documenter-dark">documenter-dark</option></select></div></p><hr/><p>This document was generated with <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> on <span class="colophon-date" title="Monday 10 February 2020 16:49">Monday 10 February 2020</span>. Using Julia version 1.3.1.</p></section><footer class="modal-card-foot"></footer></div></div></div></body></html>
